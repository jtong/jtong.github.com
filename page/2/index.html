<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-07/" class="post-title-link" itemprop="url">像机器一样思考（七） —— 跨应用思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>（本文不适合初学者阅读，目前只是为了方便培训的时候预习而写，也不适合无后续服务的人阅读）<br>现在，我们把上一篇的应用变成网络版。这个时候，你至少有了两个应用，一个客户端应用，一个服务端应用。到这一刻，我们就算具有了一个系统。</p>
<p>当我们有一个系统的时候，我们需要一种框架来简化思考我们的应用。这里又需要我们再次展示我们的概念性思考能力，这时我会采用Linux的模型来思考这个问题，所以应用程序一般我会分为三层：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-07/pic-01.png" alt="layer-of-application"></p>
<p>core层是我的核心逻辑，核心的计算部分放在这里。（Linux里是Kernel，不过Kernel这词比较偏门，咱们这教程的目标是为了尽量降低门槛，还是用core吧）<br>shell层是我链接核心层和用户的地方，你可以简单理解为解析用户输入，包装核心层的计算结果，变成用户看到的输出。Shell层还有一个作用，当我们有多个应用的时候，彼此之间的shell层是互相交互的，Core层是互相不知道彼此的存在的。<br>config层比较难理解，从工程的角度，我们的Core层和Shell层，都不应该控制彼此的生命周期，它们所有的依赖都应该是外部配置的，它们只依赖抽象的接口而不是具体实现。config层就是这一层配置，在Linux的Shell里对应的就是环境变量这个概念。</p>
<p>引入这些概念有什么好处呢？如果用这些概念来解释我们的应用，可以支撑非常大的架构的思考。</p>
<p>我们想象一下，系统随着演进而变大，出现原本的小东西也会变的非常庞大。比如上一篇main函数里的几行代码，随着系统变大，相应的Router也不可能自己写了，Router和Command的关系自然也是在文件里配置的，慢慢的我们就开始需要一个IOC容器。Service本身会变得很复杂，彼此之间可能会有关系，而且甚至可能是别的应用提供的Service。如果我们再使用应用框架里的概念，那么思考也好，交流也好，都会变得很低效。所以我们才引出了config，shell，core这三个概念来简化应用的内部，这样就可以思考大量的应用之间的关系是应该是一个什么样的架构了，不过这个方向是一个更复杂的问题，这里就不展开了。</p>
<p>回到我们的系统上，在一个刚刚出现了前后端概念的系统里，我们的新概念们能帮助我们理解架构的演进，下面就基于这些概念带着大家推演一遍现代常用的一些软件框架是因为哪些力量驱动出来的。</p>
<h2 id="Core的重新定义"><a href="#Core的重新定义" class="headerlink" title="Core的重新定义"></a>Core的重新定义</h2><p>当我们把系统分为客户端和服务端的时候，那么客户端要做什么呢？服务端要做什么呢？</p>
<p>往往客户端是需要更多的照顾用户体验，填平服务端的接口和用户体验之间的沟壑。</p>
<p>服务端则要保证数据读写的性能，安全性和易于被客户端使用。</p>
<p>从这两点来看，客户端应该考虑的是用户体验，而不是让用户体验为服务端扭曲。所以客户端的core层更多的是那层填平服务端接口和用户体验之间沟壑的那堆代码，而它给shell的接口应该是以shell好调用为导向的。</p>
<p>那么怎么算是好用呢？</p>
<h2 id="边界与无限"><a href="#边界与无限" class="headerlink" title="边界与无限"></a>边界与无限</h2><p>刚才谈到，在我们的边界处，好用是一个非常重要的需求。怎么算好用呢？最重要的是边界要找对，如果你过界了，做了事情也会被埋怨。当我们思考系统的时候，边界往往是不好找的。这就需要引入一个新的架构模式： MVC。</p>
<p>所谓的MVC就是Model-View-Controller。一个常见系统，往往Model层负责核心基本元素和基本算法，View层负责展示和表达数据，Controller层负责调度和组合，把Model层和View层连接在一起。</p>
<p>一般来讲，Model层通常是我们的Core，Controller层往往就是我们的shell，View层就是shell返回的数据。这个时候边界的思考就清楚了，谁是我们的model和model相关的核心计算，谁就是我们的core。谁是我们的Controller负责调度组合和内外相连，谁就是我们的shell。而我们的计算结果，也就是我们的View层，是会离开我们的应用供别人使用的，那它是我们的最外面的边界。我们思考边界只需要关注在View层，思考清楚我们的View是否在一个抽象层次上就可以了。</p>
<p>但是，世界不是这么简单的分三层就可以结束了，世界是往复循环以致无穷的。所以我们的MVC也是循环迭代的，也就是说MVC中的某一层还可能再分MVC。那么是哪一层呢？View层。还记得我们第一篇讲得，数据和过程是不严格区分的，所以我们返回的数据，可以被解析为新的过程，新的过程再产生新的数据，从而往复循环以致无穷。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-07/pic-02.png" alt="MVC"></p>
<p>所以可以认为服务端是原应用的Core层进化出来的。</p>
<p>如果我们把View层进化下去，我们前面提到的客户端的Shell返回的数据，还会再划分，就会有新的组件层(Component)，模版层(Layout)，页面层(Page，也有人爱用Container)等等。</p>
<p>随着出现了MVC，再进一步思考就会逐渐发现，其实core层不应该关心后端代码，它应该关心前端的领域对象，以用户眼中的模型为基础计算，而不是后端业务人员眼中的模型为基础来计算。所以他会把弥合后端和前端的工作交给shell层，而shell层会夹在三方面很难受，他一方面要对接后端，一方面要对接core，还有一方面要适配真正的前端模型。前端和后端的拉锯战就会出现，在这股力量的挤压之下，我们的BFF就会自然而然的出现，所谓的前后端分离也就是自然而然的事情了。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="题外话1"><a href="#题外话1" class="headerlink" title="题外话1"></a>题外话1</h3><p>对于有经验的同学要说一句：数据库不是核心，你的代码才是核心。数据库就是系统的另外一个应用而已，虽然数据库厂商希望你把核心放在它里面，但你不要被厂商的策略绑架了你的自由。</p>
<h2 id="题外话2"><a href="#题外话2" class="headerlink" title="题外话2"></a>题外话2</h2><p>面向对象，有一位同学总是在给我纠结这个面向对象怎么画。其实之所以有此问并不是不知道怎么用强类型语言来画图，如我们第二篇所述，你换成类图也是一样的。主要的纠结点在于，那个函数放在哪个类里这个问题。</p>
<p>之所以一直没讲，是因为面向对象是纯粹的人类思考问题的方式，它是非常不精确的，把哪个函数放在哪个类里这个事情是一门艺术而不是一门科学。当我们有一个Dog类的时候，有一个bark方法是非常明显的。当我们有一个货物类（Goods)的时候，算税应该是它的方法吗？当我们有一个数据库实体的时候，比如User，Item等等，那么存储算他的方法吗？如果我们做一个CRM系统，Client明显跟所有的业务都有关系，总不能Client这个类上有所有业务的方法吧？所以我们无论怎么放，都可能是有问题的，而且在变化来临前，我们没有什么客观的标准来判断当前的做法是否合理。</p>
<p>如果只是画图来表达的话，其实我们的方块上，也表达出了哪个函数属于哪个类，这样已经便于有经验的人发现问题并解决问题了。只是没有任何客观的公式可以帮助大家轻松的解决问题。我们只能帮你这么多了，毕竟方法，从来也不是为弱者服务的。</p>
<h2 id="题外话3"><a href="#题外话3" class="headerlink" title="题外话3"></a>题外话3</h2><p>你这个是不是六边形架构？<br>其实可以看作是六边形架构的一种变种，我只是比较讨厌六边形这个词，它太容易让人纠结为啥是六个边，不是八个？比如我叫八卦可不可以？所以我们也不要太纠结他叫什么，领会精神就好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/bad-smell-of-visualize-arch-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/bad-smell-of-visualize-arch-design/" class="post-title-link" itemprop="url">架构可视化的坏味道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="抽象的坏味道"><a href="#抽象的坏味道" class="headerlink" title="抽象的坏味道"></a>抽象的坏味道</h2><p><a href="https://www.jianshu.com/p/1e496225b6b6" target="_blank" rel="noopener">上文</a>说过，C4说穿了就是几个东西：关系-线、元素-方块和角色（角色不过是图形不同的方块）、关系表述-线上的文字、元素的描述-方块里的文字，虚线框（如前文所说，在C4里面虚线框的表达力被极大的限制了。）</p>
<p>这些东西一点都不新，我们自己随便找个白板，无非也是用这几个东西来表达架构，它的优点在于引进了一些分层，使得我们思路不是特别混乱，容易给别人看懂我们的思路，也容易帮助自己整理思路。</p>
<p>所以C4不能帮你做好架构设计，但是它能让你的设计中的问题暴露出来。被自己或其他人纠正。</p>
<p>可视化的威力就在这里，但根据我的经验，即便你用上了C4也不见得就能表达清楚，不过好消息是，终于我们可以聊一些高级的表达问题了。</p>
<p>可视化之后，我们能看到自己的表达问题，大概的问题有两个：抽象层次和抽象粒度。这个是表达方面永恒的问题，也就是软件设计永恒的问题，没有万灵丹，但是用上了可视化手段之后还是有机会让生活更美好一点的。</p>
<p>这两个问题可能太抽象了，不容易意识到，那我们可以看图，从图上的具体表现来发现坏味道。一般会有几个迹象表明我们有可视化的坏味道：</p>
<ol>
<li>一张图上过分密密麻麻的线</li>
<li>一张图上太过多元素（也就是方块）也是坏味道</li>
<li>一张图上太少的元素，比如角色特别少</li>
<li>每个图上文字表达不契合，有的太泛泛，有的太细节也是问题。</li>
<li>无限制的画更多张图，基本上也就失去了使用图形化表达的意义。</li>
</ol>
<p>那么对应的手段就有：</p>
<h2 id="合成更大的元素"><a href="#合成更大的元素" class="headerlink" title="合成更大的元素"></a>合成更大的元素</h2><p>当我们发现密密麻麻的线、太多的元素，闻到这个味道的时候。我们可以考虑是不是该把里面的一些元素合成更大的元素了。Component可以合成Container，Container可以合成System，这样就会分成更多的图，每张图就变得没那么多线和元素了。</p>
<p>紧接着会面临下一个问题：怎么合成一个更大的系统，Container是明确的，所以Component合成Container不是问题，问题是Container怎么合成一个系统，为什么是这些Container合成这个系统，而不是另外几个？或者多加几个、减几个？</p>
<p>这个问题没有标准答案，但是有一些其他的框架可以提供一些思考的维度。</p>
<p>比如可以结合akf扩展立方来思考</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-01.png" alt="akf扩展立方"></p>
<p>X轴就比较容易，一方面看你的容器本身的描述来发现设计上是不是支持横向复制的，另一方面则是看你的部署图。<br>Z轴相对难一些，只是比较偏技术。比如当技术上有性能瓶颈，则需要注意这一个维度，有时不得不搞出一些特殊的容器出来，有时已经存在这些容器了，他们可能单独属于一个系统（类似于大数据分析的系统），或者一个系统的某一个局部（这就是我说的虚线框的表达力被限制的地方）。</p>
<p>Y轴给人的感觉是最容易操作的，但实际上却是最难的做好的，Y轴的背后是业务，往往我们觉得就按业务切成多张图就好了么。这种想法就表现出我们其实很看轻理解业务的难度，于是也总是出问题的地方。如果你能跨过这个心理障碍，决定去认真做一下，那么也有一些工具可以帮助我们做好。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-02.jpg" alt="领域模型与架构设计"></p>
<p>最经典的工具组合就是求助于DDD，结合康威定律和步速，考虑维护的团队、使用的角色、变化的节奏，这块展开就复杂了，有机会再聊。</p>
<p>这里说一个最简单的做法。按照用户角色分。同一种角色，由于它的，公司里的职能，他的职责都是已经被定好的。天然在系统上就有一种隔离性。比如招聘专员、会计、出纳。他们使用的系统肯定是不一样。</p>
<p>但说简单，其实也不简单。我见过一些图，上面的角色只有两个，内部用户和外部用户。而另一些图，细化到了persona的级别，或者把职级都放上去了。所以无论再简单的原则，最后都会掉进抽象的坑。</p>
<h2 id="画一些共识图来忽略掉一些通用的元素"><a href="#画一些共识图来忽略掉一些通用的元素" class="headerlink" title="画一些共识图来忽略掉一些通用的元素"></a>画一些共识图来忽略掉一些通用的元素</h2><p>有时候合成了更大的元素，元素依然很多，线条依然很密。画多张图也不够切分的。这个时候我们可以求助于共识。</p>
<p>人与人交流，彼此之间如果已经有一些共识存在就可以少废很多话，共识多到一定程度只需要确认一个眼神就完成交流了。所以毫无疑问做好共识管理，就可以大幅简化我们的架构图。</p>
<p>所以在我们做架构可视化的时候，经常会先画一个技术共识图，比如以一个我们的能力建设的数字平台为例，我们就画了一个下面这样的技术共识图。：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-03.png" alt="技术共识图"></p>
<p>然后在后面画具体的图的时候，我就可以省略掉一些共识的元素，像nginx和数据库就没有了，可以更关注在业务上，而不是技术上来画图。</p>
<h2 id="通过制定主题，限制文字的抽象层次"><a href="#通过制定主题，限制文字的抽象层次" class="headerlink" title="通过制定主题，限制文字的抽象层次"></a>通过制定主题，限制文字的抽象层次</h2><p>其实上面的技术共识图就是类似的做法，只是用于技术方面，如果用于业务方面，我们可以用一些抽象的名词或动词来代替一类业务，比如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-04.jpg" alt="数字平台系统景观图"></p>
<p>上图是一个系统景观图。当前这个主题是希望，人们一眼看清楚这个系统里面的相关角色都在使用什么系统，并且他们关注什么，职责是什么。所以具体学什么，怎么学的，都不是那么重要。所以我们就用学习一词代表了一系列的业务。</p>
<p>当主题确定的时候，很多纷杂的信息就没有了。一定要克制住自己，试图在一张图上，表达足够多信息的冲动。</p>
<h2 id="只画重要的图，剩下的交流的时候再画。"><a href="#只画重要的图，剩下的交流的时候再画。" class="headerlink" title="只画重要的图，剩下的交流的时候再画。"></a>只画重要的图，剩下的交流的时候再画。</h2><p>除了像上面说的，不要试图在一张图上给他足够的信息。同时也，不要试图把所有的信息都表达出来。</p>
<p>绝大多数的图可能只在交流具体业务的时候才画，推荐使用动态图。<br>这个手边没有例子，找到再说吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>即便有了C4这么，好用的可视化工具。我们依然会看到，自己会掉进抽象的坑。所以在使用的时候一定要注意坏味道，经常检察是不是犯了抽象层次和抽象力度的错，才能做好可视化。这件事上，没有谁能幸免，所以要时常自省，与诸君共勉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/reuse-obsession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/reuse-obsession/" class="post-title-link" itemprop="url">复用的着相</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>着相是佛家用语，指的是执着于外相偏离了本质。<br>仙剑奇侠传中有一个故事。讲的是一个成精了的佛珠。想要让更多的人向佛，于是施法，让这些人失去了记忆，只想一心礼佛。使人向佛，本来是好事，但强人所难，脱离了本质，便是着了相，也可以说反而是入了魔。<br>这个小故事告诉我们，在认知的世界里，我们很容易被表象所欺骗，忽略了本质。为此，佛家发明了这么一个名词来专门指出这种现象。</p>
<p>复用也是一样。复用本来是通过消除重复的方式。得到一系列可以复用的组件。从而在未来的开发工作中，更快速的响应需求变化，也就是所谓的提升响应力。<br>然而很多复用的结果，会造成代码是变少了，改起来却更难了。复用是增加了，可读性却下降了。考虑到软件开发是一个团队协作的工作，而我们这个行业的离职率又能到百分之二十之多。难以学习的代码确实是难以维护的，尽管你可以抱怨接手的人无能，但总之是降低了响应力，也就违背了复用的本质。<br>什么情况下会出现这样的场景呢？主要是因为视角的单一，只从自己单一的视角看到了重复而不是在做全局优化。这个说法可能稍微有些抽象，那我说几个相对具体的情况。</p>
<h2 id="当我们只关注功能视角的时候"><a href="#当我们只关注功能视角的时候" class="headerlink" title="当我们只关注功能视角的时候"></a>当我们只关注功能视角的时候</h2><p>需求有很多的描述视角，可以只在功能角度描述，比如“网站要有任务卡，任务卡上有文字版学习内容，视频讲解、也有作业题。”也可以加入业务视角，比如“学生要报名特训营，才能参加特训营。学生进入特训营后，就看到了任务卡列表。学生在任务卡上阅读学习资料，阅读完学习资料后做题来验证他是否学到，做完后提交交由助教审阅。”当我们只看功能视角的时候，可能会忽视业务上的不同，变的在功能角度过分抽象，最后当业务变化的时候，反而响应速度比较弱。<br>一个简单的后台，我们看起来所有东西长得都一样，不过是列表页面，添加页面修改页面，再加点儿删除什么的功能。说穿了都是crud，干脆我把这事弄成一一个组件好了，每个页面只需要简单配置一下，就可以出来自己的一套，增删改查页面。<br>这种视角完全没有考虑到，不同的实体，它们其实所在的业务是不一样的，关心它们的人也是不一样的。最后，彼此的演化方向也总会出现一些不同，你把它定义成一种东西，对于我每做一个修改，都要背负着其他所有实体的特异性。于是就逐渐拖慢了我改变的速度，降低了响应能力。</p>
<h2 id="无谓的自动化"><a href="#无谓的自动化" class="headerlink" title="无谓的自动化"></a>无谓的自动化</h2><p>有追求的程序员一定会考虑提升工作效率，通过一些自动化的手段来缩短流程，提高效率。不过有时候，这种追求也会有害。<br>在我们的系统里有一个面包屑功能，就是典型的“页面A / 页面B / 页面C”那种面包屑。团队成员提出，一个个页面写面包屑好烦啊，干脆做一个根据URL生成面包屑的功能吧。乍一看好像提高了效率，但实际上URL上的名词和你想显示在面包屑上的名字是可能出现不同的。<br>比如在我们的场景里，我们提供一个任务卡的预览功能，你的面包屑可能是“xx后台 / xx 训练营管理界面 / xx卡预览”，而学生正式使用任务卡的时候，他可能是 “ 学习中心 / xx 训练营 / xx卡 ”。而他们的url里可能都会出现’/programs/$pid/tasks/$tid’。同样的program、task翻译出来的文字完全不同。你为了支持这点不同，又要扩展一些额外功能来做这种区分，做来做去，可能还不如直接写来的方便，至多抽几个常量来简单的消除一下重复。</p>
<h2 id="当我们只从代码上看重复性的时候"><a href="#当我们只从代码上看重复性的时候" class="headerlink" title="当我们只从代码上看重复性的时候"></a>当我们只从代码上看重复性的时候</h2><p>这个我就不举例子了，其实很多犯这个错误的人都是重构的支持者，不过学艺不太精。因为如果你仔细看的话，重构里好多怀味道都有一个跟他对立的怀味道，比如发散式变化和霰弹式修改。如果我们只看代码就会违背复用的本质——更好的响应变化。<br>这个跟我说的第一个场景，只关注功能视角是类似的问题，这个可能更具象一点，只关注代码。</p>
<h2 id="无视上下文的时候"><a href="#无视上下文的时候" class="headerlink" title="无视上下文的时候"></a>无视上下文的时候</h2><p>这个可以看作是只有功能视角的一种情况，很多功能我们觉得有重复性，提升成一个概念，然而其实根本是两个东西，他们只是刚好叫一个名字。<br>比如过去很多软件里，是有一个统一的用户组概念，不管你在哪个业务上下文里，你都需要扩展这个用户组的概念来管理用户的权限。这个带来的结果就是用户组变得越来越臃肿，每次修改都要改一下别的组的功能。在我们的网校数字平台里，学生学习有学习小组，老师出题有出题小组，这两个小组业务完全不一样，这个时候如果都用统一的用户组来管理的话，那就势必会造成无谓的耦合，损害响应力。</p>
<p>这些故事告诉我们，我们不是在真空里去做复用。我们做的软件都是有它的商业目的。我们的工程实践也都是为商业目的服务的。当我们说tech@core的时候，让我们说技术就是业务的时候。诚然，他给技术人员带来了更多的权利，然而权利越大，责任也越大。技术人员也需要跳出技术，具备更多的业务视角和体验视角。而不仅仅是沉浸在技术得自high当中。才能真正的发挥出各种实践的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/deliberate-practice-for-digital-talent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/deliberate-practice-for-digital-talent/" class="post-title-link" itemprop="url">数字人才的刻“意”练习——开篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="系列背后的故事"><a href="#系列背后的故事" class="headerlink" title="系列背后的故事"></a>系列背后的故事</h2><p>不知道你有没有灵魂画手的体验。所谓灵魂画手，又叫手残党，当它们想画一个东西的时候，画出来的图大都是这样的：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/deliberate-practice-for-digital-talent/pic-01.png" alt="灵魂画作"></p>
<p>反正我从小就有这种体验，非常不爽。我特别想能通过画画来表达东西，然而作为一名灵魂画手，一次次拿起画笔就是一次次的挑战不可能，直到最后让我意识到，确实不可能……</p>
<p>那些图画仿佛有魔力，让我完全没办法画出来。我想有些事情还真是有天赋这种东西存在的。</p>
<p>这个想法并没有让我更舒服，表面上让我对天赋这个词更加敬畏，但内心深处其实对它的厌恶也是与日俱增。然而不管我多么厌恶，我还是一名灵魂画手，一个手残党。我也只能继续认为有些事情还真的是有天赋这种东西存在的。</p>
<p>我一直这么认为着，直到几年前我知道了一本书：《像艺术家一样思考》。我曾经的同事熊节学过那本书之后，经过一个多月的修炼，从手残党变成了可以画素描的人，写了一篇博客发出来：<a href="http://gigix.thoughtworkers.org/2013/6/7/how-i-learned-sketching/" target="_blank" rel="noopener">http://gigix.thoughtworkers.org/2013/6/7/how-i-learned-sketching/</a> ，看了之后令我羡慕万分，于是我也买来了那本书，照着练习。</p>
<p>里面的教学法非常奇特，他让你把图画倒过来，照着画，号称五分钟的奇迹。也就是说，五分钟前你是手残党，五分钟后，你就能画画了。我在照着步骤练习了之后发现，奇迹真的发生了。</p>
<p>一旦倒过来，我变的不再关注于整体造型，而是关注于线条，眼中那些有透视感的线条重新变成了平面上的线条，那些图画不再有魔力，变成了我这样的手残党也可以画出来的东西。那种体验，硬要打一个比方，可以说是麻瓜突然学会了魔法的感觉。</p>
<p>而不同于熊节，我没有开始练习画画，反而开始思考思维方式这个东西。我意识到我可能找到了一种把天赋这种东西从神坛上拉到地上的可能性，所谓的天赋，也不过是自然规律被发现之前人类神化自然现象的迷信叙事罢了。只要找对了方法，人与人可能没有那么大的差别。</p>
<p>“人跟人的差别”，我们这个行业里这种话题聊的格外多，往往是以挖苦工作中的某些“傻X”来开始的。在我们工作中，我们很容易上升到人的问题来进行讨论甚至处理。仔细打开我们的思维看一下，我们的潜意识里是认为应该存在某种天堑，决定了人和人的不同。我们认为工作和人之间存在某种匹配关系，某些人就应该做某种工作，某些人就不应该做，如果匹配错了，后天再怎么努力都是徒劳的。</p>
<p>看过这本书后，我仿佛收到了某种感召，我开始以怀疑的眼光来看待这种归因于天赋的逃避主义论调，并且作为一个自认为资质普通的人，内心深处总有某种冲动，想要一个个的破掉这些说不清道不明的天堑。</p>
<p>我开始假设，只要人们想且得法，经过刻意的练习，都可以学会那些看似不可思议的技能。我开始假设，有些技能，人们会觉得那是某种才能、是天赋，实际上只是技能，是可以通过练习获得的。</p>
<p>这些假设开始去驱动我去学习一些东西，试验一些东西，慢慢我就走上了钻研培训教育的道路。这条路一走就是四年。（这一路走来比较出乎我意外的是，路上比我想象的要热闹一些，一路认识了很多有同样想法的人，有些人还是被同样一本书感召了，大家互相交流，一路上并不寂寞。）</p>
<p>走到今天，已经有了不少的方法心得。我现在还在这条路上，一直走下去可能还能发现更多，为了防止狗熊掰棒子，把前面的忘掉，我还是要抓紧写下来，所以要开始这个系列了。</p>
<h2 id="为什么给意加个引号？"><a href="#为什么给意加个引号？" class="headerlink" title="为什么给意加个引号？"></a>为什么给意加个引号？</h2><p>不是为了说反话，而是为了强调。刻意练习这个词给人看到的时候，人们经常是关注在”练习”两个字上的，仿佛只要只要逼着自己练就好了。自己不需要做出什么认知上的变化，只需要练习，量变自然会产生质变，练习者自己只需要坚持，其他什么都不需要操心。</p>
<p>经过我的一些摸索，我发现重点在“意”。也就是注意力。所以我觉得刻意两个字特别好，里面体现出了注意力的重要性。我一路走来，发现每一种方法，都是一门注意力放置的艺术，就像画画你学会了把注意力放置在线条上，你突然就会了，而如果你没法把注意力放在线条上，你画细节的时候总是在想全局，总也画不出来。而这其实也只是又一遍证明了100年前美国心理学之父威廉詹姆士就提出的观点：”努力和注意力是一个心理事实的两个名字“。换句话说，所谓的不努力，只是不知道如何放置注意力，放置的不对就会很痛苦，也就看起来不努力。</p>
<p>一个好的方法就是，定义出有哪些放置注意力的点，总结出来之后告诉人们，剩下的人们自己能搞定。虽然要想做好还需要做很多的训练，但只有知道了要把注意力放在哪之后，我们的练习才算得上刻意，否则只能算作随意练习。这个是被很多人所忽视的，也是我后面的文章会关注的，所以加个引号强调一下。</p>
<p>就这样吧，虽然是开篇也不要一点干货都没有。总结一下，希望大家能学到：刻意练习的关键在于注意力的放置，否则就不是刻意练习，而是随意练习，下篇见。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/growth-method-of-team/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/growth-method-of-team/" class="post-title-link" itemprop="url">团队的精进之道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】</p>
<p>之前写过一篇文章《编程的精进之法》，总结了ThoughtWorks中一点工作方法。现在看来，那篇文章其实应该叫个人精进之法。然而现在不是个人英雄的年代了，我们需要再深想一步，一个团队应该怎么办？</p>
<p>当我们在带领一个团队的时候，我们想的总是，如何做好任务分配，平衡团队战斗能力，交付最好的结果。于是做的时候就会下意识的去简单、被动的因材分工，那么随着项目的进展，人员的流动，各种意外的发生使得我们在项目后期感到处处掣肘，于是只能加班以示诚意。</p>
<p>我刚入行的时候，经历的各个项目都是如此，一直觉得这种事情就是天经地义的，直到认识了一个项目经理。该项目经理是个高人，他在项目开始的时候，问清楚每个人擅长的部分，然后让每个人去做自己不擅长的部分，不会？去找擅长的人帮忙。比如，张三说我以前做过用户权限管理，李四说我以前做过单据管理，王五说我以前做过工作流。（交代一下例子的上下文，那家公司主要就做一个大的领域，那个时候也不像现在前后端分这么清楚，项目经理有时候还要身兼Tech Lead）他就会说，好，张三去做工作流，王五去做单据管理，李四去做用户权限管理，遇到不会的，谁擅长什么你们都知道了啊，去问。</p>
<p>虽然看起来有点乱来，但是他负责的项目从来没出过问题。后来我加入了ThoughtWorks才知道，听到一个口号：“把项目成功交付看作能力建设的副产品”，才知道这是这口号的一种朴素实现。<br>很多团队能力不强，团队的领导者就总是在向外寻找方法的帮助。寻找方法帮助其实没有错，但是寻找方法帮助的人，心态往往都是错的。当我们在向外诉求方法的时候，很多人的潜意识，是假设我们团队成员能力不变的情况下，通过一种魔法般的方法，就可以改变团队的绩效，这种思路在真实世界里是走不远的。</p>
<p>在ThoughtWorks，我们认为，软件开发中的一切问题，根本上都是人的能力问题。如何发展每个成员才是问题的关键，因为成员如果没有进步，始终是治标不治本的。所以我们采用的一切实践，不管是以前曾采用的还是以后会采用的，核心目的都只有一个：发展人的能力。因此才有了那个听起来很耸动的口号：“把项目成功交付当成能力建设副产品”。</p>
<p>如何发展人的能力？讲东西吗？不太靠谱，信息仅靠分享是没用的，我经常把刚讲过一遍的知识，让人复述；把结对时刚写完的代码全删掉让同伴重写一遍，能做到的人不多。记也记不住，做也做不到。</p>
<p>就像我之前《然而培训并没有什么用》里说的，做练习？没时间，项目太忙了。而且，就算你有时间，我们拿出时间来做练习，你能保证到了跟练习不一样的场景下，团队成员们都能用好吗？把学会的知识在新场景下用好这件事，还是挺看天赋的。</p>
<p>讲东西不靠谱，做练习没时间，那难怪大家不考虑能力建设了。不过，如果我们反过来想，这个问题就变得没那么难办了，既然没有时间做能力建设，那么也许一切活动都可以看作是能力建设。所以那个项目经理的招数虽然看起来比较乱来，但却是这个思路，我在项目开始的时候，不是着急去以最快的速度交付结果，而是通过任务分配，发展团队成员的能力。在一个较长的时期里平均来看，我们就是在以最快的速度交付结果。</p>
<p>所以，回到我们的主题，就是团队的精进之道就是把交付过程中的一切活动都看作能力建设，把整个团队构造成促进每个成员成长的生态系统。</p>
<p>说起来好像挺简单，我只要换个角度看就好了，然而如果想要做到并没有那么简单。这里面差异微妙而关键。</p>
<p>比如以上一篇文章《软件开发的精进之法》讲到的方法为例。一个人要划任务，然后估时间，然后做的时候计时，根据实际结果进行反思。我们可以把这个方法做成非常邪恶的，仿佛流水线上工人的强制要求。我不关心你为什么超时，就通过这种方法来控制程序员，要求每个人都严格按照一个死板而僵化的步骤做一些简单重复的机械动作。也可以用这个方法来锻炼一个人的自我认知和发现知识漏洞等能力，促使他以最快的速度成长，等他成长起来马上给他更重要的任务，比如评估技术、评估项目、带新人、做架构等等。这两种结果的差异，背后就是领导者认识的差异，团队成员认识的差异。从这个认识的不同我们早在很多年前，就被一些大牛们观察到，作为敏捷宣言里的一句话表达了出来：“个体与交互 胜过 流程和工具”。</p>
<p>团队里的流程和工具，是为了成就个体，促进交互，还是为了抹杀个体，消除交互，这个微小而关键的差异，是一切的本质。有多少团队学了ThoughtWorks的一些实践，搞了看板、开放工作空间、TDD、CI，团队氛围依然压抑，成员之间交流不畅，个体成长不受尊重，领导与员工玩“猫和老鼠”。这样只学了形没有学到神的做法，最后的结果不会太好。</p>
<p>与之相反的做法呢？在上一篇文章《软件开发的精进之法》的开篇曾经简单的提到，新时代的管理者比起老板，更像老师。师者，传道，授业，解惑。各位老师，你们准备好了么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/working-as-a-human-being/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/working-as-a-human-being/" class="post-title-link" itemprop="url">像人一样工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标题耸动吗？可能你会奇怪，我们不都是人吗？什么叫像人一样工作？</p>
<p>这个问题啊，你还别不认，我们不像人一样工作已经有个把世纪了。这一切都是从工业时代开始的。</p>
<p>工业时代带来的一个问题就是劳动异化，劳动异化说的是，资本家从劳动者手里买走了劳动力，从而使得劳动者的劳动性质产生了某种变化，这种变化叫做被异化。异化会产生什么问题呢？问题在于劳动力被买走了，劳动的意义也被买走了，所以劳动者在劳动中除了定时领工资没有任何意义，在生活中才有意义。没有意义感之后，人就不是人了，所以劳动者在劳动的时候不是人，是个机器，参考摩登时代：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-01-moden-times.gif" alt="image.gif"></p>
<p>资本家非常清楚这个道理，比如福特就曾经有句名言：我就想雇两只手，怎么来了个人呢？</p>
<p>这个问题一直延续到了现在，对程序员也是一样的。不然也不会有前一阵的996.ICU运动，这就是数字时代的工人运动。马云说，他自己超时工作如何如何，这个话说的就没文化，您是资本家，您劳动充满了意义感，而其他人是被异化的劳动者，劳动过程中没有意义感，它能一样吗？</p>
<p>我之前有几篇文章，讲了像机器一样思考的方式来思考软件和任务。而我们毕竟不是机器，理解机器并不是为了变成机器，何况我们也变不成机器。所以我们可以像机器一样思考，最终还是要像人一样工作。机器和人的差别在哪呢？回想一下当柯洁和李世石代表人类坐在机器面前，看着绝对不会犯错的机器，说出绝望的言论时，有没有让你觉察到我们跟机器的本质区别是我们会犯错这个关键约束条件？有些人可能不喜欢这个本质区别，但我觉得这没什么不好，这就好像苹果和梨，没有好坏之分，只是不同，工业时代把人变成机器，数字时代让人重新做人这是个好事。（尽管转变的过程中会有阵痛，但最终的结果也只能是这样，我坚信着。）</p>
<p>既然我们是人，我们接受这个前提，我们就要采用人工作的方式，而不是机器的工作方式。</p>
<p>机器工作的方式是什么样的呢？我们来看个动画：</p>
<p><a href="https://www.bilibili.com/video/av51228411" target="_blank" rel="noopener">https://www.bilibili.com/video/av51228411</a></p>
<p>这个问题在哪呢？在敏捷社区里有一副很有名的画，可以很好的说明人和机器的区别：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-02.png" alt="image.png"></p>
<p>看这个过程像不像前面机器公敌里的机器人作画的场面？</p>
<p>如果我们按照像机器一样思考教的里面画好了任务后，按照上图的方式去实现，就叫像机器一样工作，实际上这个行业里大量的项目都是这么干的，真是悲哀。每个人领一个模块，最后拼成一个功能，绝大多数人都不知道端到端什么样给客户提供了价值没有。这种工业时代的做事方法最大的问题就是把人当成了机器，像上面那组图一样工作，然而人做事是从粗略到丰富的画面一点点变过来的，就像下面这张图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5773421-0f8e6199b863aec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>图片来源： <a href="https://acejoy.com/2018/04/20/438/" target="_blank" rel="noopener">https://acejoy.com/2018/04/20/438/</a></p>
<p>可以看到第一张图里，每一步都做得很完美，但是不到最后一步，它不是一个完成的成品。观察一下打印机，就是这么工作的，哪怕过程中出了状况，中断了工作，已经完成的部分每一个细节都是完美的。</p>
<p>而我们人是会犯错的，并不能做到像第一张图那样工作，反而是会采用第二张图那种方式。除了避免犯错，还有一个核心差异促使我们这么这么干，那就是机器是不知道疲劳和厌倦的，而人会，所以人在一个漫长的造物过程中，需要一种东西帮助自己持续获得前进的动力，那就是文章开头所说的意义感。</p>
<p>意义感是个很个人的事情，每个人对意义的定义不同。但工作中的意义感又确实有一种模式化的方式获得，那就是创造闭环。尽管人和人有很多的差异，但是只要完成一个闭环，大多数人都会产生或多或少的意义感。第二张图里，每一步都是一个完成了闭环的输出物，第一张是草图，第二张是简单涂色的图，第三张是完成稿。每一步我们都觉得完成了些什么，每一步我们都会有一点意义感。</p>
<p>作为一个人，我们需要这种东西，所以我们创造出了很多按照这种方式工作的方法，所谓的敏捷、所谓的迭代、所谓的冲刺、所谓的PDCA、所谓的TDD等等等等。一切的一切都在创造这种闭环，然后缩小闭环周期。而与之相反的各种工作方法却是在割裂闭环或拉长闭环周期，让大多数人都活在一段缺乏意义感的流程中或像鸵鸟把头埋到地里一样获得一种虚幻的安全感。天下方法千千万，这两种区别是本质区别，我们推广敏捷本质上是在追求前者的普及，与后者对抗，这是两种价值观、两种立场、两种社会算法的的对抗。</p>
<p>当我们用TDD的方式写代码的时候，当我们用PDCA一点点的精进我们的匠艺的时候，当我们每次冲刺的交付物都得到用户反馈的时候，当我们努力缩小反馈环追求更小闭环的时候，不管外面是不是有一个邪恶的资本主义体系在控制着我们娱乐至死，我们真实的感受到了自己像人一样工作着，感受到了劳动的意义，那这就是值得去做的。</p>
<p>那么这个值得去做的事情由谁来让它成为现实呢？我想来想去，只有团队的Leader，作为团队的领导者，你要去思考到底要求大家采用什么实践去做事的时候，除了想一想效率之外，也要想一想怎样的做法会让大家感受到意义，感受到像人一样在工作。在效率与意义之间的平衡，这是每个领导者的社会责任。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/growth-method-of-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/growth-method-of-programming/" class="post-title-link" itemprop="url">编程的精进之法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>（作者注：阅读本文需要一定的编程经验和对一些敏捷实践，如TDD，有一定的了解）</p>
<p>编程，众所周知被定义为知识工作，所有的知识工作，从业者和门外汉都喜欢把它神秘化，将整个过程以不可知论的风格来解释。理由往往只是简单粗暴的讲诉一些体力工作时代形成的方法照搬到知识工作中来失败的故事，也毫无理论依据。偶有几个人写理论理由，写出来的理由跟癔症者的呓语也无甚差别。我个人是反对将知识工作神秘化的，我是科学管理原理的忠实粉丝，我觉得尽管科学管理原理的具体案例都过时了，但泰勒的研究方法依然是工作的，只是研究者和被研究者发生了一些微妙的变化。</p>
<p>彼得德鲁克在《21世纪的管理挑战》中提到，知识工作者需要自我管理，那么很明显不是体力工作时代形成的方法不能用在知识工作中，而是不能指望个体之外的人对个体进行简单的粗暴的分析和命令就可以形成很高的生产效率了。这个分析和下命令的人必须是知识工作者自己，我们需要自己纪录自己的行为，然后分析、优化，才能得到生产力的提升，任何向外诉求都会很快的撞上一个“天花板”而无法提升。如果非要寻求外部控制，那么我们只能说，对于新时代的管理者的定位，比起老板，更像老师，以引导和帮助训练为主，每个人真正的效率提升主要还是要靠自己。</p>
<p>那么如文章标题所述，追求知识工作的一种——编程的效率，是本文关注的重点。但我们首先要声明，本文不是给一个可以直接产生高生产效率的方法，而是给一个可以可视化自己生产效率以找到瓶颈的方法。至少在不改变质量的前提下，可以极大的提升你的效率，如果使用得当，可能会质量和效率双提升。</p>
<p>本文引入的方法也并不新鲜，简单说来，就是任务列表法＋PDCA的一套组合使用而已。大道至简，坚持者寡，而坚持下来的人往往都可以获得数倍的效率提升。</p>
<h2 id="任务列表法"><a href="#任务列表法" class="headerlink" title="任务列表法"></a>任务列表法</h2><p>我们做任何事情都应该划出任务列表，按照任务列表一项项去完成，这不是什么特别少见的工作方式。然而，很多人的问题在于，列出的问题列表不能达到完全穷尽，各自独立。</p>
<p>完全穷尽是什么意思呢？<br>当我开始做事情的时候，我不能把所有的事情穷尽，我列出的列表跟我做的事情是不完全等价的，这说明我们的工作行为是非常混沌不可视的，哪怕是对自己。<br>有时事情看起来在大面上是穷尽了，但是做的时候，发现又出现了新的任务。那说明每一项任务的输入和输出没有想清楚，所以当发现输入输出有欠缺的时候（主要是输入，输出欠缺的结果也是要补输入），就需要新的任务来准备输入，于是任务列表就增加了，这也是一种没有穷尽。</p>
<p>各自独立是什么意思呢？</p>
<p>意味着，每一项任务都可以单独做完，而不需要先做完其中一项任务，才能做完另一项。<br>假如我有三项任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 任务1</span><br><span class="line"># 任务2</span><br><span class="line"># 任务3</span><br></pre></td></tr></table></figure>

<p>我做的时候，必须把任务2做完，任务1才能做完。任务3做完，任务2才能做完。结果我就从任务1开始一路做到任务3，最后再逐步回到任务1，整个过程非常混乱，那就不是各自独立的。</p>
<p>在现实生活中想做到各项任务都独立挑战还是比较大，但是在编程的世界里，挑战没有那么大，程序世界做到这一点真的太轻松了。优秀的设计都是要求解耦的，如果做不到，基本等于活儿比较烂。</p>
<p>当我们做到任务的完全穷尽与各自独立之后，我们任务列表法才算达标，这之后才能高效的工作，然而达到这一点并不是一蹴而就的，没有谁可以一上来就做到任务划分可以完全穷尽、各自独立，需要不停的刻意练习。所以我们称之为编程的精进之法。</p>
<h2 id="PDCA"><a href="#PDCA" class="headerlink" title="PDCA"></a>PDCA</h2><p>PDCA是Plan-Do-Check-Action四个词的组合。这是著名的戴明环。讲究从计划开始，经过实践，再反思，产生的改进行动再纳入下一轮计划的持续改进过程。</p>
<p>当我们把这一套从工业领域搬过来的时候，我们对计划的理解还是工业领域那一套。如果用在个人提升方面，我们应该把PDCA微观化，这之后就有两个问题需要被解答，一个是Plan是什么？一个是Check什么？</p>
<p>第一个问题的答案是很显然的，我们前面讲的任务列表法就是在形成这个Plan。</p>
<p>第二个问题本身是一个母问题，每当我们对这个问题的回答，都要回答一个衍生出来的子问题：我们要做点什么才能在需要Check的时候能够Check。常用的套路有两个：</p>
<ol>
<li>Plan的时候估计一个时间，然后开始做，做的时候计时，做完就要Check这个时间是否达标，无论快了还是慢了（通常是比较明显的差距才反思，比如20%以上的差距），Check都要反思并产生Action，纳入到未来的Plan中去。</li>
<li>估计的任务列表和实际做的任务列表是否是一样多的？往往是会多出来，这时就要反思，自己在哪里有不足导致了这个差别。</li>
</ol>
<p>这些反思往往是发现自己的问题，比如自己不熟悉的知识点，不熟悉的方法，甚至不熟悉的业务知识，最后的Action也往往都是进行刻意练习来提升生产效率，比如反复练类似题目。有时也会是通过一些效率工具的使用来提升效率，比如抽取live template，使用快捷键，只是效率工具的使用往往也需要刻意练习就是了。有时也可以通过复用技术（其实live template已经是复用技术了）来提升生产效率，然而可复用模式的识别与抽取本身也是需要练习的，否则在那里纠结浪费的时间更长。</p>
<p>有些同学会感觉到，记录了时间却不知道哪里有问题，这个时候可以跟TDD相结合，把时间划分为写测试的时间，写实现的时间和测试通过的时间。其实除去这几种时间，还有其他时间消耗，比如调研的时间。不管怎么划分，将时间消耗结构化掉，一部分一部分的追求最高效率是一种可行的办法。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>我们做一个简单的修改用户信息功能的API。那么我们在某一个Java技术栈上可能的任务列表是长这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 写UserController （10分钟）</span><br><span class="line">2. 写UserDAO （15分钟）</span><br></pre></td></tr></table></figure>

<p>当你真正开始做的时候，会碰到两种主要的意外：</p>
<ol>
<li>任务列表扩张</li>
<li>时间估计不准</li>
</ol>
<p>我们下面就这个例子，讲一讲遇到这两种意外，我们应该怎么反思和处理。</p>
<h3 id="任务列表扩张"><a href="#任务列表扩张" class="headerlink" title="任务列表扩张"></a>任务列表扩张</h3><p>任务列表扩张，顾名思义，就是指我们一开始估计的任务的数量随着我们开始工作变的比预想的多，可能有两种主要原因：</p>
<ol>
<li>技术原因</li>
<li>业务原因</li>
</ol>
<p>技术原因，比如在这个案例里面，第二项任务：写UserDAO，就是一个没想清楚的事情。我们还需要建数据库表，我们在一个有migration脚本支持的技术栈设计上工作，我们还需要写初始化脚本和回滚脚本，也许这是我的第一个表，所以我还得配置数据库，搞不好还要把ORM的基础代码都写完，所以这些导致了我可能任务估少了。再比如，我们的项目规范要求我们Controller不能直接调DAO，要在中间加一个Service，尽管我个人觉得这是一件很二的规范，然而规范就是规范，我对项目技术规范不熟悉结果导致我画出来的任务缺少了一些必要的任务。再比如，我们的项目采用的是Jersey，根本没有Controller这么一个东西，那么不了解技术框架导致我的任务根本就划错了。</p>
<p>这种情况属于我对技术了解不足，通过对任务列表扩张原因的Check，我会得出一些Action：去了解技术规范，去深入了解项目的技术架构，现有的代码，以防止以后的任务画错。</p>
<p>业务原因，也比如在这个例子里，我们的系统需要在更新用户信息的API里不能更新密码，所以我们还需要一个专门的修改密码的API。再比如，这是一个遗留系统，用户信息的修改会触发数据库里的一系列触发器，从而修改系统的其他数据，然而有些修改是有前提的，那么我就需要更多的任务去处理这些前提条件；或者当数据变化时，要求我去修改系统里的其他数据，那么我就需要更多的任务去完成这些工作。</p>
<p>这种情况属于我对整个系统的业务了解不足，通过对任务列表扩张原因的Check，我会得出一些Action：通读数据库表，通读代码，更全面的阅读需求，或者跟需求方更多的沟通，以了解业务。</p>
<h3 id="时间估计不准"><a href="#时间估计不准" class="headerlink" title="时间估计不准"></a>时间估计不准</h3><p>时间估计不准就简单了很多，在这个例子里，就是这两个任务我估计的时间与我做的时间不相匹配。可能的主要原因也有三个：</p>
<ol>
<li>任务列表扩张了，但是我没意识到，比如UserDAO写起来没有我想的那么简单，所以多花了时间；</li>
<li>单纯的技术不熟练；</li>
<li>花了太多时间在纠结上；</li>
</ol>
<p>对于隐藏的任务列表扩张，时间估计不准给了我们一个很好的线索去发现。一旦发现了，可以前文所述去处理，也就不再赘述</p>
<p>对于单纯的技术不熟练，就如前文所述，要去设计刻意练习。比如我就曾设计过对数据库的增删改查的一组训练以提升自己的速度，使得我即便使用TDD依然保持一个极高的速度。我们自己没有意识到，基础能力的不熟练对于我们的高级能力的限制有多严重，这种体验也只有基础能力已经熟练的人去教基础能力不熟练的人一些高级技能的时候才会发现。这种视而不见的收益，使得大多数人都会轻视基本功的练习。哪怕已经获得收益的人，也容易鼓吹要更多的启发而忽略了基本功的价值。</p>
<p>对于花了太多时间在纠结上，这其实也是一种不熟练，是对设计知识和能力的不熟练。之前看的设计知识只能有一个大概的感觉，对于每个知识的边界、使用之后的发展、如何从一种设计过渡为另一种设计了解不清，从而害怕在那一刻犯错。实际上真正值得纠结的部分没有那么多，大多是自己吓自己，或者引入了过度设计。当然也有一种情况是暴露出了架构级的问题，比如我们对于应该提出的原则性规范没有提出，所以导致我们每个地方都要现想，大家可以想象没有RESTful之前设计Web API，我们可能真的是每一个API都现想的，有了它之后，我们的纠结时间就变少了。这种情况下，通过本方法，架构师也算是有了相应的数据支持，那么架构师也就有了发现问题的一种工具。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总的来说，任务列表法＋PDCA式工作法形成的组合方法，是一个通过逐渐提升个人能力以达到高效工作的方法。这两种方法单独拿出来用，都会由于各自的局限而有各自的天花板，只有有机的结合才能真正突破这个天花板。刚开始使用起来，对于很多人来说会有一些痛苦，这一点上我只能说，提升就是痛苦的，而新的习惯一旦养成，痛苦也就不翼而飞，所以美国心理学之父威廉詹姆士说，“我们需要在尽可能早的时候，让尽可能多的有用的动作变成自动的和习惯的……一段痛苦的艰难时期之后就是自由的时光”。当我们基础能力达到一个极高的效率之后，我们会发现我们争取自由的筹码会变得更多。</p>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>有人可能会觉得列出符合上文所述标准的任务列表比较难，欢迎阅读拙作《像机器一样思考》系列文章：</p>
<p><a href="https://www.zybuluo.com/jtong/note/403738" target="_blank" rel="noopener">像机器一样思考（一）—— 宏观的基础</a><br><a href="https://www.zybuluo.com/jtong/note/471501" target="_blank" rel="noopener">像机器一样思考（二）—— 数据的细节</a><br><a href="https://www.zybuluo.com/jtong/note/473123" target="_blank" rel="noopener">像机器一样思考（三）—— 穷尽就是力量</a><br><a href="https://www.zybuluo.com/jtong/note/774931" target="_blank" rel="noopener">像机器一样思考（四）—— 一图抵千言</a><br><a href="https://www.zybuluo.com/jtong/note/640178" target="_blank" rel="noopener">像机器一样思考（五）—— 第一个应用</a><br><a href="https://www.zybuluo.com/jtong/note/641148" target="_blank" rel="noopener">像机器一样思考（六） —— 脑中的重构</a><br><a href="https://www.zybuluo.com/jtong/note/480426" target="_blank" rel="noopener">像机器一样思考（七） —— 跨应用思考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/two-behavior-pattern-and-three-axis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/two-behavior-pattern-and-three-axis/" class="post-title-link" itemprop="url">两种行为模式与三根轴</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="絮絮叨叨的开场"><a href="#絮絮叨叨的开场" class="headerlink" title="絮絮叨叨的开场"></a>絮絮叨叨的开场</h2><p>上一篇<a href="https://www.jianshu.com/p/ad6959838724" target="_blank" rel="noopener">需求的视角</a>，我们介绍了一种可以让人回归场景的的小工具，避免在实现功能时的需求理解问题。但是在我们很好地理解了需求之后，在实现过程中，就会一帆风顺么？也不是的。</p>
<p>我们工作久了，就会发现有些人资质很好，有些人资质就很差。你会发现，有些人会考虑的比较有深度，有些人就不行。到底什么是深度呢？我不太能理解这个词，于是我继续观察。从外在看呢，我们会发现他们的行为表现有差别。我称之为工人的行为模式和工程师的行为模式。这两种行为模式在面对问题的时候差别尤为明显。</p>
<p>一个工人行为模式的人，遇到问题的时候，采取的方式就是直接把做过的行为再做一遍，期望能有所不同。比如装个环境，遇到问题了，就把执行的命令再执行一遍。</p>
<p>而工程师行为模式的人，遇到问题的时候，却什么都不着急做，往往是盯着出错的屏幕若有所思，片刻之后，突然说“哦，我知道了”，然后一下就把问题解决了，仿佛是在脑子里Debug。</p>
<p>我们打开看呢，你会发现他们的思考问题的维度是有差别的。我一直找不到一个好的模型来解释这种思维模式的差别，直到我在一本叫《创新算法》的书里面看到有个三轴分析的模型，可以较好的描述这个维度差别：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/two-behavior-pattern-and-three-axis/pic-01.png" alt="三轴分析"></p>
<p>按照三轴分析的模型，我们思考一个机器，要从三个维度去思考，一是操作，就是人是怎么操作这个机器的；一是系统，就是这个系统都有哪些组件，这些组件都有什么关系；三就是因果，就是当人进行某种操作，到看到结果之间，一步步是怎么发生的，哪些组件起了作用，出了问题又是哪些组件没搭配对或者那个组件出故障了，或者操作本身是不是做错了。简单讲因果轴就是前两轴的动态关系。</p>
<p>计算机虽然精密，它也是一台机器，这上面跑的软件也没有任何的魔法，一样是适用于三轴分析的。</p>
<p>所谓像工人行为模式的人，其实就是指关注操作轴的知识，而对下面的系统轴和因果轴关心较少造成的。我曾经在面试的时候，让一个人讲他用到的一个框架的原理，结果他在白板上一顿乱画，我始终没看到组件有哪些，互相又是怎么配合的，最后发现，他是按照界面在描述那个框架的（很多框架都提供跟eclipse集成的GUI操作界面），他说的全都是在哪界面上填什么信息，然后就会有什么效果。只能用操作轴的信息来描述一款框架，这种行为也就是我们所谓的没有深度。</p>
<p>这样的例子在行业里比比皆是，我们在培训中就曾经碰到过一件哭笑不得的事情，比如在进行一些代码操练的工作坊的时候，让学员使用intellij来进行编程，一些有多年工作经验的学员写的代码出了编译错误，说这一定是你这个IDE的问题，我用eclipse这么写就没问题。当面用eclipse打开，依然是编译错误，就没话说了。还有远程就不会断点调试、配了log4j就抱怨e.printStackTrace()不打印了等等奇葩的例子就不展开聊了（但不写出来吐槽一下是真难受，我的一个朋友经常吐槽，为什么这个行业里这么多“业余”的人。说实话，我也是有点绝望的……），其实这些都是一个问题，就是只关注操作轴，关注的久了，所有的技能都只用操作轴的信息来编码，换个界面就武功全废，也是很多人觉得编程只能是青春饭的原因。</p>
<p>而工程师行为模式的人，一定不会只关注操作轴维度的信息，他们会打开系统，看到系统内部构造和系统到底是怎么运转的。由于对这些东西非常了解了，才能盯着屏幕上的日志，在脑子里模拟代码的运行，推理自己可能哪里出错了。</p>
<p>要想做到这一点，其实并没有什么魔法。我们用到的绝大多数框架、库、工具都是开源软件。开源软件都是很慷慨的把自己的机制、代码都放在了网上，完全没有信息壁垒。如果我们在读完入门案例后，还去读读Manual或Reference（有余力也可以读读源代码）我们不但会对系统的组件和系统的运转机制有更深入的了解，而且会在操作层面多一些新技能，当我们施展出来，还会有人惊呼“还有这种操作”。唯一需要做的就是认认真真读文档，照着文档写几个demo，编程初学者的话，把API doc都读读是最好的。然而这一件简单的事，竟然都成了少有人走的路。</p>
<p>所以对于开发人员来说，想要成为一名合格的工程师，只关注操作轴肯定是不行的，在学习的过程中要刻意的逼迫自己去关注系统轴和因果轴。不过这确实不是一件容易的事，不同于普通机器，软件的复杂度要高得多。咱们软件业有一句话说，没有什么问题是不能通过添加一个中间层来解决的（如果有就再添加一层），所以学习过程中会不断的发现，自己被一个抽象层挡住了。需要重新用三轴分析工具分析一下，抽象层的下面又是什么。学无止境，无尽的三轴。</p>
<p>本次讲的刻意练习其实是最简单的：阅读，写demo，这些都是优秀程序员的基本功。也是最难的一个，因为实在是太枯燥了，以刻苦的学习击穿认知的次元壁从来也是少数人才能达成的成就，但其实你仔细去观察那些少数人的时候，你会发现他们有些小技巧，能把苦变得有趣，这里就介绍几个小技巧。</p>
<h2 id="Demo法"><a href="#Demo法" class="headerlink" title="Demo法"></a>Demo法</h2><p>写一些小demo其实非常有助于建立起从操作到系统的映射，并可以通过下载开源代码及单步调试来理清中间到底发生了什么。由于demo都很小，很容易快速的建立收获感，你不会觉得做了很久没有任何收获，从而放弃。也不需要很大块的时间来做，导致每次学习都死于起手式。</p>
<p>我的前同事李鹏是此中高手，他有一篇文章《<a href="https://www.jianshu.com/p/e4a8a48ee69c" target="_blank" rel="noopener">当我拿到一个前后端实现todolist的学习任务时，我应该怎么做？</a>》中，把任务分解（我们下一篇就讲这个）和demo法结合在一起，大家感兴趣可以看看。受他影响，我也做了一个小github组织，来放自己的demo：<a href="https://github.com/jtong-demos" target="_blank" rel="noopener">https://github.com/jtong-demos</a> 可惜最近几个月太忙就没时间更新了，不过也看出了另外一个优点，等我忙过这阵，想要捡起来的时候，这些demo会比网上的什么资料都快。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>为了深入到另外两个轴去，阅读当然很重要，但是对于大多数人来说枯燥是最大的退却原因。所以我在之前带学生的时候，都要求他们输出，写博客。有输出，枯燥感就会下降一些。但是写文章本身也很累，而且很容易变成抄书，所以我们后来又找到了另外一个工具：概念图。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/two-behavior-pattern-and-three-axis/pic-02.png" alt="概念图工具的概念图"></p>
<p>可以用节点来表达组件，用线上的关系来表达组件之间的关系，非常适合表达系统和因果轴，可以更轻量的进行输出（具体怎么用，简书上一搜一大堆，我就不写了）。其实我之前介绍的<a href="https://www.jianshu.com/p/1e496225b6b6" target="_blank" rel="noopener">C4</a>，就可以看作是一种特殊的概念图。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>如前所述，我们学习软件相关的知识，可以借用三轴分析法，从操作、系统和因果三个角度扩展自己的认知。只有这样才能成为专业人士，刻意的阅读、输出、写demo，这简单的几件事，能做到的人却很稀有，这也是为什么优秀的工程师非常稀有的缘故，我们公司的数据，一个业务分析师或者QA，只要聪明，进入公司，差不多1年就可以比较独当一面，而开发人员，大都需要三年。大多数人都喜欢走易走的路，而难走的路反而是人少的捷径，坚持做好这几个动作，就是提升自己的捷径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-01/" class="post-title-link" itemprop="url">像机器一样思考（一）—— 宏观的基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>本文的起源是因为思考一个问题，什么样的人适合做程序员。<br>我曾经苦恼得思考着这个问题，直到我在SICP上看到了答案。说的白话一点就是，能像机器一样思考的人就适合做程序员。<br>那么计算机这台机器是怎么思考的呢？这里是我的答案：</p>
<p>我们所有的计算机，都是下面这个模型，江湖人称“冯・诺伊曼体系”<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-01/pic-01.png" alt="冯・诺伊曼体系"></p>
<p>从这个模型上我们看到了什么吗？嗯，可能太多噪音了，看的不够清楚，我给你们再抽象一层：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-01/pic-02.png" alt="输入、处理、输出"></p>
<p>现在清楚了吧，计算机在中间，两边是输出输出。所有的问题都从输入和输出的角度去思考，这就是计算机这台机器的思考方式。也就是说你能做到这样思考，你就会像机器一样思考了。</p>
<p>很简单吧，但是新的问题又产生了，处理自然要处理输入产生输出了。输入，输出是些什么呢？这就要在微观层面理解机器是怎么思考的，这一部分叫，机器在加工什么？</p>
<p>SICP中又说了，非形式的讲，我们只在处理两种东西，数据和过程，他们还不是严格区分的。<br>先不管不严格区分那半句，我们回看我们的模型，中间处理的部分其实就是过程，输入和输出其实就是数据。（在冯诺伊曼体系里，数据和过程被称之为数据和指令）那说到数据，我们有一门学科叫做数据结构，它很好的表达了什么是数据。我们还有面向对象，类型系统之类的知识，他们都会帮助我们很好的定义数据。</p>
<p>各位看官估计心里犯嘀咕了，扯了这么多，还是无法想象怎么就算像机器一样思考了啊？不急，下面我们拿几个例子来学习一下。</p>
<p>我们来写一个加法函数，接受两个参数作为加数和被加数，返回一个和，这个太简单了，几乎任何一个程序员都可以在几秒钟内写完。拆成机器的思维是什么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加法函数</span><br><span class="line">输入： </span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">输出:</span><br><span class="line">  result</span><br></pre></td></tr></table></figure>
<p>大概就长这样，输入是a和b，输出是一个结果，我们起名叫result。它到底表达了个啥样的代码呢？大概长这样：（本文所有的代码都会采用javascript描述，但是不代表本文内容只适合描述前端开发）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咦？result哪去了？在你调用的地方可能会有一行代码 <code>var result = add(1,2);</code><br>这个表达方式不仅仅可以用来描述函数定义，用来描述表达式也是可以的。比如，如果我们把前面的输入输出思维描述改为<code>加法表达式</code>。你会发现其实这段描述“编译”成代码大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; a + b;</span><br></pre></td></tr></table></figure>
<p>所以不仅仅可以用来描述函数定义，还可以描述代码块。</p>
<p>但是到这里就结束了吗？感觉好像对数据的表述不够细致啊。确实，我们忘了加类型了。不加类型这描述简直万灵丹么，反正俩参数一个返回值的都能用，这不行，我们还得把类型加上看着才清楚点。加上类型就变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加法函数</span><br><span class="line">输入： </span><br><span class="line">  a: Number</span><br><span class="line">  b: Number</span><br><span class="line">输出:</span><br><span class="line">  result: Number</span><br></pre></td></tr></table></figure>

<p>这看着就好多了，是不是比刚才理解上文所讲的像机器一样思考了呢？好吧，你可能会说，这玩意有啥用啊，我有分析的这个空，我代码都写完了啊。不急，我们接着往后看。</p>
<p>刚才那个题目有点太简单了，我们做一个稍微复杂的。比如下面这个：写一个函数，可以选出一个由数字组成的集合当中所有的偶数的最大值。</p>
<p>这回一步做出来可能就有点难了，没关系，我们可以成两步：</p>
<ol>
<li>选出集合中的偶数</li>
<li>选出偶数中的最大值<br>这两步呢，按照我们之前的格式写一下，大概是下面这个样子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#1 选出集合中的偶数</span><br><span class="line">输入： </span><br><span class="line">  inputArray </span><br><span class="line">输出：</span><br><span class="line">  evenArray</span><br><span class="line"> </span><br><span class="line">#2 选出偶数中的最大值</span><br><span class="line">输入：</span><br><span class="line">  evenArray</span><br><span class="line">输出:</span><br><span class="line">  max:Number</span><br></pre></td></tr></table></figure>
<p>哎呀，突然发觉不知道该怎么描述集合呢。Javascript里就用数组就好了，但是还是不知道怎么描述数组啊。这个其实很简单，这不是一个由数字组成的数组吗？我们只要写成<code>[Number]</code>就可以了。因为我们的一个好习惯是一个集合里不要放两种类型的元素，所以就这么写就好了。那么加上去的话，大概就长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#1 选出集合中的偶数</span><br><span class="line">输入： </span><br><span class="line">  inputArray: [Number] </span><br><span class="line">输出：</span><br><span class="line">  evenArray: [Number]</span><br><span class="line"> </span><br><span class="line">#2 选出偶数中的最大值</span><br><span class="line">输入：</span><br><span class="line">  evenArray</span><br><span class="line">输出:</span><br><span class="line">  max: Number</span><br></pre></td></tr></table></figure>

<p>咦，第二步的evenArray没有写类型。嗯，因为evenArray是第一步的输出，我就把它省了，相信大家也能看明白。<br>耐着性子看到这里，你估计已经发现了，我还是没有回答你这个思维方式有什么用这个问题。我很想忽悠着你再做一道题，不过估计你坚持不完就会转身离开了。那我们就这两道题试着讲一讲。</p>
<p>第一道题，我们只是展示了这个思维，第二道题，我们才开始使用到它的威力。尽管这道题也不复杂，但是思考过程还是展示了：</p>
<ol>
<li>分解问题</li>
<li>找到子问题之间的关联（通过输入输出关联起来）</li>
<li>找到问题的边界，明确假设与结果</li>
</ol>
<p>上述三点看着简单，却是思维清楚与否的关键。我们管这个能力叫Analytical Thinking。</p>
<p>思维清楚带来的收益是什么？这些步骤可以直接转化为工作的任务列表，而且可测试。这样分解出来的任务列表，完成效率是极高的。我们曾经做过实验，按这个思路分解过的人，比没有分解过的人，完成效率可以高3倍以上，而且前者只学了一周的编程。<br>一个完全不会写程序的人，只要学会了这个思维，就可以开始编程之旅了，而且威力非常巨大。</p>
<p>听起来好简单啊，有那么神吗？不是编程的人都应该会吗？然而并不是的，很多人思考编程这件事情是靠感觉的。<br>我前几天面了40多个外包公司外派来的人，只有5个人，可以按照输入输出来对问题进行分解。所以我觉得我还是有必要写点东西来讲讲这个。</p>
<p>除了对初学者有益之外，对Team  Lead也是有益的。当你觉得你遇到的人没sense的时候，你可以试着让他们这么表达一下程序。一般就会发现一些问题。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>题外话－1：<br>    我们像机器一样思考，不就都变成机器了吗？嗯，其实不是的。所谓我们像机器一样思考，那机器这种思考方式又是从哪里来的呢？机器的思考模型是一个叫“图灵机”的计算模型，而图灵机则是图灵祖师爷模拟人思考而发明出来的。所以，其实不存在什么像机器一样思考，只不过是学会一种人类的思考方式而已。<br>    考虑到图灵只能以自己和自己周围的天才科学家的作为人类的具体实例来抽象图灵机，所以我们学习的其实不是什么机器的思考方式，而是天才的思考方式，这篇文章其实应该叫《像天才一样思考》。</p>
<p>题外话－2:<br>    这个不就是面向过程编程吗？如果的思考仅仅停在这里，那就是面向过程编程了。如果我们接着想下去，当数据复杂到一定程度的时候，我们会自然的引入封装，于是面向对象诞生了。回到数据与过程不严格区分那半句，当我们试图模糊数据和过程的界限，将过程像数据一样纳入输入输出的范畴，我们就走上了函数式编程之路。</p>
<p>题外话－3:<br>    有人觉得练习不够吗？请留言，如果感兴趣的人多，我就加紧写更多练习的解析。</p>
<h2 id="相关文章："><a href="#相关文章：" class="headerlink" title="相关文章："></a>相关文章：</h2><p><a href="https://www.jianshu.com/p/15ccf03ef37c" target="_blank" rel="noopener">像机器一样思考（二）—— 数据的细节</a><br><a href="https://www.jianshu.com/p/1cca5bf85f29" target="_blank" rel="noopener">像机器一样思考（三）—— 穷尽就是力量</a><br><a href="https://www.jianshu.com/p/37a862c43481" target="_blank" rel="noopener">像机器一样思考（四）—— 一图抵千言</a><br><a href="https://www.jianshu.com/p/1dd0190b8aac" target="_blank" rel="noopener">像机器一样思考（五）—— 第一个应用</a><br><a href="https://www.jianshu.com/p/f7a4f0f851c6" target="_blank" rel="noopener">像机器一样思考（六） —— 脑中的重构</a><br><a href="https://www.jianshu.com/p/12738a1b0365" target="_blank" rel="noopener">像机器一样思考（七） —— 跨应用思考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-02/" class="post-title-link" itemprop="url">像机器一样思考（二）—— 数据的细节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 07:56:49" itemprop="dateCreated datePublished" datetime="2020-01-30T07:56:49+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与很多人想的不同，同理心是一件强大的控制工具，你有多理解你要控制的对象，你就多容易控制它。所以我们学习像机器一样思考并不是为了变成机器，而是为了更好的控制机器为我们服务。从这一篇开始，我们进一步讲解这种思考模型的细节。</p>
<p>随着对细节的深入，我们会发现，我们会越来越看不清楚机器的思维和人的思维的疆界。仿佛这之间的区别是很小的，有时候你不知道是因为人这么思考所以这么设计的机器，还是机器这么思考所以我们需要迁就它。</p>
<p>同时，可能你会感到一些些麻烦和思维上的束缚，但总之请记住，一切不得不接受的束缚，都是为了更大的自由。Rails之父DHH曾经说过：</p>
<blockquote>
<p>约束是你的朋友。</p>
</blockquote>
<p>这很反直觉，然而随着你编程的经验增多，你会体会到这句话是多么的正确。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>编程语言分为静态类型（比如Java，C#，Scala）和动态类型（比如JavaScript，Ruby，Python）两种。但不管是静态类型还是动态类型，你不可否认类型总是在那里的，哪怕你不显式的表达出来，也绕不开它的存在，你思考的时候必须思考它。</p>
<p>在<a href="https://www.jianshu.com/p/c86329151cba" target="_blank" rel="noopener">上一篇</a>里，我们有一个例子用到了类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加法函数</span><br><span class="line">输入： </span><br><span class="line">  a: Number</span><br><span class="line">  b: Number</span><br><span class="line">输出:</span><br><span class="line">  result: Number</span><br></pre></td></tr></table></figure>
<p>在这一个例子里，我们用到了一种类型：Number。表明我们的参数只能是数字。假如在强类型的语言里，如果我们传进去的参数类型不是数字，就会报错。假如在弱类型的语言里，我们传进去的参数类型不是数字倒是不会报错，但是如果我们使用<code>&gt;</code>或<code>-</code>之类的运算符对其进行运算的时候，可能就会报错。所以强弱类型的语言无非是出错的时机不同，为了保证我们程序的正确性，不管你用哪种，都摆脱不了要思考数据的类型问题。</p>
<p>仅仅是一个个体数据的时候，考虑类型还是容易考虑的。当我们有一组数据的时候呢？比如上一篇里我们还有这样一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1 选出集合中的偶数</span><br><span class="line">输入： </span><br><span class="line">  inputArray: [Number] </span><br><span class="line">输出：</span><br><span class="line">  evenArray: [Number]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个例子里，inputArray的类型到底是什么呢？是<code>数字</code>呢？还是<code>数组</code>呢？还是<code>只有数字的数组</code>呢？泛泛的说，inputArray的类型是<code>数组</code>，而精确地讲，inputArray的类型是<code>只有数字的数组</code>。为什么需要精确的指定，只有数字呢？这其实是从实用角度出发，如果我们一个数组里面放各式各样类型的数据，我们就会越来越想不清楚而头脑陷入混乱，在写代码的时候也是每当用到一种类型的数据就要加一个if，就容易漏掉一些情况而引入bug。所以为了我们自己好，还是一个数组里只放一种数据类型吧。</p>
<p>在一些强类型语言（比如Java）里，为了保证这一点，他们还使用了所谓的泛型。有一种常用的情况就是跟我们这个情况类似，大概长成这样：<code>List&lt;Integer&gt;</code>。我们就会了解，当涉及到集合的时候，为了防止滥用，人们不惜动用语法。</p>
<p>以上就是我们上一篇用到的类型相关的知识，在这一篇里，我们会走的更深入。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在上一篇里，我们的类型还是一个黑盒，在这一篇里，我们要引入结构。每一种语言都有一些基本类型，但是用来描述这个世界的数据，基本结构是不够的。所以每个语言又都提供了一种方法，让我们可以以基本数据类型为“积木”，通过结构化的方式来自定义类型。在大多数语言里，我们使用类来做这件事，但是不管你用什么，最后表达的信息都是类似的。</p>
<p>举例来说，当我们想要表达一个数字的类型时，我们用Number，我们想表达一个字符串的类型时，我们用String。那当我们想表达一个人，这个人有一个姓名属性是String类型的，有一个年龄属性是Number类型的时候。我们需要创造出一个这样的类型，我们就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: String,</span><br><span class="line">  age: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我就用到了一种结构来表达了人的类型，大家可以看到我用的方式是借鉴了<a href="http://www.json.org/" target="_blank" rel="noopener">JSON</a>的表达方式，只是把本应该写值的部分换成了类型。这是一种便于在纸上书写的表达方式，我们在日常工作中进行沟通的时候，随手拿过一张纸，很容易写清楚我想表达的结构。</p>
<p>而最重要的是，它可以简单的表达出很深层的结构，比如我们想要定义一个人这个人有一个孩子，孩子当然也是一个人，也有相同的属性，那我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: String,</span><br><span class="line">  age: Number,</span><br><span class="line">  child: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们可能会说了，万一不止一个孩子呢？好，这就引入了自定义类型中的数组怎么表达的问题。其实可能大家已经发现了，自定义类型它也是一种类型，它存在的位置就是原来写String，Number的地方，那么问题的答案就很符合直觉了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: String,</span><br><span class="line">  age: Number,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来跟<code>[Number]</code>很像吧？那么对应一个具体的Javascript对象，代码是怎么写的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let zhangsan &#x3D; &#123;</span><br><span class="line">  name: &quot;张三&quot;,</span><br><span class="line">  age: 38,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    name: &quot;李四&quot;,</span><br><span class="line">    age: 10</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    name: &quot;王五&quot;,</span><br><span class="line">    age: 5</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文的结构，描述的就是这个代码里的对象的结构。前文的结构是为了限制我们的数据定义，然而有了这个限制，我们就可以思考更复杂的问题。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>废话不多说，我们还是老规矩，做个练习看看怎么用。</p>
<p>打印某人的成绩单。已知输入的格式是</p>
<blockquote>
<p>[“姓名”, “语文成绩”, “英语成绩”, “数学成绩”, “编程成绩”]<br>比如： [“张三”,  “95”, “80”, “75”, “80”]</p>
</blockquote>
<p>要求打印出成绩单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名：张三</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">数学：75</span><br><span class="line">语文：95</span><br><span class="line">英语：80</span><br><span class="line">编程：80</span><br><span class="line">***************</span><br><span class="line">平均分：82.5</span><br><span class="line">总分：330</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>如果对这个题目进行任务划分，我会分成两步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#1 转换为ViewModel</span><br><span class="line">输入： </span><br><span class="line">  scoresArray: [String] </span><br><span class="line">输出：</span><br><span class="line">  scoreSheet: &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    chinese: String,</span><br><span class="line">    english: String,</span><br><span class="line">    math: String,</span><br><span class="line">    programming: String,</span><br><span class="line">    average: String,</span><br><span class="line">    summary: String</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">#2 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">    scoreSheet</span><br><span class="line">输出：    </span><br><span class="line">    result: String</span><br></pre></td></tr></table></figure>

<p>这两步我干了什么呢：</p>
<p>第一步，我把字符串数组转换为了一个具体的对象类型，它有六个属性，分别对应着我们要打印的成绩单上的六个数据：语文，英语，数学，编程，平均分和总分。<br>第二步，我把对象转成了一个字符串，打印了出来。</p>
<p>你可能会很奇怪了，打印没有返回值啊？为什么写在输出里？好问题，且听我下回分解～</p>
<h2 id="照例，题外话环节。"><a href="#照例，题外话环节。" class="headerlink" title="照例，题外话环节。"></a>照例，题外话环节。</h2><p>题外话1: 为什么我们不直接用数组就拼这个字符串呢？一方面，我是在演示结构的使用，另一方面，这是一个小技巧，我们最后打印的这一部分字符串的部分，被称之为表现层（就是表现在人眼前的那一部分），在表现层你最后使用的数据的结构，尽量跟你的表现层的结构一致，这样出bug的几率最低。</p>
<p>题外话2: 这是在js里，如果我们采用强类型语言，这些结构该怎么定义呢？其实很简单嘛，比如那个人的类型结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person &#123;</span><br><span class="line">  name: String,</span><br><span class="line">  age: Number,</span><br><span class="line">  children: [Person]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>done。</p>
<p>题外话3： 那我们用<a href="http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/" target="_blank" rel="noopener">类图</a>可不可以呢？当然也可以，只是要画框子很容易在写属性的时候发现画小了，而且当你画更深层关系的时候就比较麻烦。</p>
<p>//TODO: 这里需要写几个对照例子</p>
<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p>打印所有人的成绩单。已知输入的格式是</p>
<blockquote>
<p>[<br>[“姓名”, “语文成绩”, “英语成绩”, “数学成绩”, “编程成绩”],<br>…<br>]</p>
</blockquote>
<p>比如： </p>
<blockquote>
<p>［<br>[“张三”,  “95”, “80”, “75”, “80”],<br>[“李四”,  “80”, “70”, “85”, “90”]<br>]</p>
</blockquote>
<p>要求打印出成绩单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名|数学|语文|英语|编程|平均分|总分 </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">张三|75|95|80|80|82.5|330</span><br><span class="line">李四|85|80|70|90|81.25|325</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">全班总平均分：xxx</span><br><span class="line">全班总分中位数：xxx</span><br></pre></td></tr></table></figure>

<p>请列出本题的任务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
