<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/12/deliberate-practice-for-digital-talent/presepective-of-requirement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/12/deliberate-practice-for-digital-talent/presepective-of-requirement/" class="post-title-link" itemprop="url">需求的视角</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-12 22:51:00" itemprop="dateCreated datePublished" datetime="2018-12-12T22:51:00+00:00">2018-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>在我培养学生的时候，我发现一个很有趣的现象，有些人可以非常好的理解需求，并且能发现需求当中的逻辑矛盾，给出非常好的反馈。更多的人，只是听了需求，然后没有任何反应，去做的时候呢，才发现有问题。最可怕的是，明明需求有问题，做的时候他也没发现问题，最后做出来的功能是有bug的。</p>
<p>想起我吐槽一个学生，让你扫马路，你就把土扫到路两边，只管中间干净。跟你说两边也要干净你就把两边的扫到中间，说两边和中间都得干净就在两边和中间的间隔处推上细细的一条垃圾线。</p>
<p>吐槽虽然可以让人很爽，但不能解决问题，只是享受了优越感。作为以能力建设为己任的培养者，这种优越感反而是一种打脸，毕竟学员能做到才是我的成功，他做不到我能做到有啥好优越的呢，让他做到才是我应该追求的优越感。所以我就陷入了深深的思索，到底怎么能让学员把需求理解清楚呢？看着他们，我开始反观内视我自己，我是如何做到的呢？</p>
<p>首先我想到，这个是个场景思考的问题，虽说思考用户场景，很多公司是PO、BA或产品经理的工作，但所谓好的程序员要能顶上半个产品经理，既然我们说是数字人才，每个人都要能理解软件的使用场景才行。我自己就是会拿到需求后，在脑子里重新构建场景。然而道理说起来简单，做起来并不简单，不管我强调多少次，要关注场景，结果也不会好，会的立刻恍然大悟（那种恍然大悟是一种原来我这种做法还有名字的感觉……），大部分不会的人还是那样……</p>
<h2 id="跳出盒子外"><a href="#跳出盒子外" class="headerlink" title="跳出盒子外"></a>跳出盒子外</h2><p>进过长期的观察，我发现他们是在盒子内思考，而跳不出盒子外。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-01.png" alt="跳到盒子的外面，才能发现场景"></p>
<p>什么是盒子内思考呢？比如一支白板笔。</p>
<p>如果我在白板笔的盒子内看的话。我就会看到笔帽，笔芯和笔管。我可能会关注，笔芯是海绵的，笔帽和笔管是塑料的，不是金属的。这样思考就有一个问题等我考虑到颜料的时候，我就不知道应该采用什么样的原料。就必须要问一个问题，这个白板笔是用来干嘛用？因为如果我在盒子里看白板这个东西，对我是没有任何含义的。</p>
<p>那盒子外就很好理解了，同样是描述一支白板笔，我要考虑他，写出来的东西好不好擦。写出来的字迹是否清晰可见？粗细是否适中？能用多长时间？成本是多少是，买一个新的还是加墨水儿更合适？一旦跳到盒子外，我还要考虑多角色比如制造商，分销商，销售终端，买家不同角色看他的视角。小小一支笔，也不是那么简单的。</p>
<p>回归软件开发的上下文，盒子内就是功能视角，比如：学习平台要有写成长日志的功能。盒子外则是业务视角，比如：学员参加了学习后，每天要写成长日志，总结当日所学，练习总结能力，助教要给他们进行检查和反馈。比起前者，后者很容易想到，既然是练习总结能力，是不是应该有模板和范文？</p>
<p>我常试好多的方法，试图让初学者可以跳出盒子外，大部分都没啥效果，不要说初学者不会，很多工作过多年的人也有这类问题，也学不会。也曾一度让我怀疑，这是一种天赋，好在不想对天赋低头的心，最终还是找到了一种实操性很好的方法。</p>
<h2 id="故事线"><a href="#故事线" class="headerlink" title="故事线"></a>故事线</h2><p>我会要求学生画一种图。我们管它叫故事线，是一种场景思维的辅助工具。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-02.png" alt="故事线"></p>
<p>这个工具是这样的用的，每当你要做一个功能，就画一条故事线，在故事线里面，首先你要定义故事起点。这个故事的起点是一个业务动机。比如说一个系统可以创建用户，那么这个创建用户的业务动机是什么呢？我问出去的时候，学生们就会开始思考，想到了说创建用户的业务动机是有一个新人入职了。</p>
<p>有了业务动机，别人才会使用你的系统，否则你的系统只是你的自嗨而已。不要说学生了，很多工作多年的人在设计系统的时候，依然不思考这个问题。有了动机，你也可以去对比各种不同的解决方案，去想有没有更好的解决方案？比如在我们这个例子里，动机就是有人入职了要创建用户，但那么有人入职了之后，谁会来这个系统里面创建用户呢？这就涉及到方案的不同。可能我们定义的角色是hr。也可能我们这是一家小公司，反正就是那么几个人，最后就跟一个系统管理员说一声，他登上来录进去就好了，对于一家小公司来说，这也可以接受，所以你就会发现，这两个都是可行的方案。</p>
<p>我们在实践中发现，有了业务动机这个概念之后，大家就会对场景有更多的思考，也能协作着来对比方案而不是瞎吵架了。</p>
<p>故事线的后面就比较好画了。我们就画他在这个系统里面为了满足他的业务动机，他需要一步一步怎么做的。注意只画成功路径，过程中遇到的异常，先不要考虑。这对很多人来说，也是一个很难做到的事情。</p>
<p>在故事线的最后，需要画出来说，这个故事结束了之后，那么最终，业务的下一个起点是什么？</p>
<p>还是以创建用户为例，当我们为用户创建完了之后，我们的下一步是什么呢？下一步可以试试，发个邮件给用户，也可以是，把用户名密码拷给，我们的新员工本人或者他的经理。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-03.png" alt="学生做的一个案例"></p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>如前所述，很多人是没有场景思维的，他想问题只能想到这个盒子内，而跳不到盒子外去关注使用它的场景。对于这种情况，我们就算明确的指出，他没有场景化思维，大部分情况下是不会有任何的作用的，大部分人依然没有场景化思维。他就像我《数字人才的刻“意”练习——开篇》里讲到的画画需要关注线条一样，我们需要告诉大家，应该关注在什么地方才会具有场景化思维。那么在这种情况下，我们只需要给他一个非常好的辅助工具，他就真的可以做到跳到盒子外。故事线就是这样一个工具。实践中发现，哪怕是毕业生，几次练习之后也可以快速掌握这种思维方式，更不要说有多年工作经验的程序员。</p>
<p>虽然在我们项目中是有所谓的业务分析师的，但是优秀的程序员一定会在脑子里重建这些场景。如果程序员不能以这样的方式画出来的话，那么程序员做开发的时候也会出现一些问题，比如没有想全，做出来的程序有问题的情况。所以教给程序员自己这么思考问题是非常重要的，在理解完业务分析师传达的需求之后，可以在脑子里把这条线画出来，非常有价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/30/deliberate-practice-for-digital-talent/talk-about-digital-talent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/30/deliberate-practice-for-digital-talent/talk-about-digital-talent/" class="post-title-link" itemprop="url">聊聊数字人才</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-30 23:09:00" itemprop="dateCreated datePublished" datetime="2018-10-30T23:09:00+00:00">2018-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>本来是开篇的一部分，结果越写越长，索性就单发了一篇</em></p>
<h2 id="什么是数字人才"><a href="#什么是数字人才" class="headerlink" title="什么是数字人才"></a>什么是数字人才</h2><p>这些年，很多企业都在搞数字化转型，也都非常缺这方面的人才，所以纷纷提出了数字人才的说法。最近似乎都上升到了国家战略的样子：</p>
<blockquote>
<p>（七）强化数字人才教育。深化教育改革，建立健全高等院校、中等职业学校学科专业动态调整机制，加快推进面向数字经济的新工科建设，积极发展数字领域新兴专业，促进计算机科学、数据分析与其他专业学科间的交叉融合，扩大互联网、物联网、大数据、云计算、人工智能等数字人才培养规模。进一步扩大和落实高校专业设置自主权，鼓励高校根据经济社会发展需要和自身办学能力，加大数字领域相关专业人才培养。加强数字人才教育师资力量培养培训，推动实现基础教育、职业教育、高等教育普遍开展数字知识和技能教育，逐步建立健全多层次、多类型数字人才培养体系。加大职业教育数字化资源共建共享力度，加快建设适应数字经济发展的职业教育相关专业教学标准体系，进一步优化中等职业学校信息化相关专业设置。（教育部牵头，发展改革委、人力资源社会保障部按职责分工负责）</p>
</blockquote>
<p>摘自： <a href="http://www.gov.cn/xinwen/2018-09/26/content_5325444.htm" target="_blank" rel="noopener">http://www.gov.cn/xinwen/2018-09/26/content_5325444.htm</a></p>
<p>那到底什么是数字人才呢？其实全世界也没有一个明确的定义，但简单粗暴的说，围绕软件开发的各种角色就算是数字人才。这个定义可以算是满足充分条件的，是否必要就见仁见智了。那我这里就是借用了数字人才这个词来表达，软件的构造者这么一个角色。</p>
<p>废了那么大劲就是说软件开发，那为啥我不说程序员呢？因为角色会限制我们的视野，一旦我说了程序员这个角色，我们就会把自己定义在编码这个视角上，什么需求啊、软件设计啊、组织流程啊，跟我没啥关系，这也恰恰是很多人在职业发展后期遇到瓶颈的原因，怪不得别人，全是自己画地为牢。</p>
<h2 id="数字人才的特点"><a href="#数字人才的特点" class="headerlink" title="数字人才的特点"></a>数字人才的特点</h2><p>软件开发是一个复杂工作，而且是一个复杂的知识工作。复杂就复杂了，这好理解，为啥强调知识工作呢？知识工作有两个特点：</p>
<ol>
<li><p>所有的工作不是正交的，分工不能切的很完美。</p>
</li>
<li><p>效率提升的关键点不是在于对how的回答，而是在于对what的回答。</p>
</li>
</ol>
<p>第一点说的是什么呢？在体力工作者的上下文里，我们是拆成流程来工作的，每个环节的人不需要懂上个环节的知识，做好自己这个环节就好了，你想象一下流水线上的工人，彼此其实只要做好自己的事情就好了，不懂上下游的知识和技能也无所谓。这就是所谓的正交，彼此不需要了解，不了解也互不干扰工作。但知识工作不一样，知识工作固然也是拆成流程来做的，但是知识工作里有个极为重要的动作叫反馈，就是下游接收到上游信息的时候，要告诉上游自己理解了没有、上游的信息哪里是落不了地的等等，尤其在复杂知识工作上下文里，反馈可以说是最重要的事情，没有之一。你想要反馈，你就必须至少需要懂得上游的一个环节的人的部分心智模型，否则反馈也反馈不到点子上。注意，是至少，通常你需要懂得要超过一个环节，因为反馈往往不只跨一个环节，如下图所示：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/talk-about-digital-talent/pic-01.png" alt="知识工作者协作信息流"></p>
<p>如果仅仅是第一点，还不是什么大不了的事情，毕竟大家一起工作，时间久了总能了解自己的上游环节的心智模型，互联网行业里都有好的程序员相当于半个产品经理的说法，问题在于第二点。我们做工作如果只追求按部就班，那就慢慢被竞争对手干掉了，每个企业都是要追求效率提升的。要提升效率就得回答一个问题，到底知识工作者的效率是怎么提升的，所以才有这个第二点，也是彼得德鲁克的观点：知识工作者的效率提升在于对what回答，而不是对how的回答。</p>
<p>什么是对how的回答呢？也就是说在每个环节提问怎么做才能提升效率，每个环节的输入和输出都是固定的，也就是待完成的事情的定义是确定的，只要在这个限制下改变做事的方法，而不用改变事情本身的定义。</p>
<p>而知识工作者的效率提升是一个纵观全局后的颠覆性优化，也就是所谓的颠覆性创新。这个颠覆性往是通过跨环节跨角色来产生的，比如最早敏捷里的技术实践，把测试引入了开发环节，把构建也引入了开发环节，而管理实践也是把验收提前，改变了对交付的定义，后来的DevOps则强调打破Dev和Ops的壁垒，都带来了极大的效率提升。一旦跨了环节跨了角色，那么输入输出都会变，事情本身的定义也就变了，我们需要经常拷问自己到底解决的问题是什么，改变了要解决的问题的定义，所以称之为对what的回答。</p>
<p>一旦问题的定义发生了变化，进而我们甚至要反复拷问自己到底什么是效率，比如，我们的效率到底指的是有100个需求，我们以最短的时间做完了，还是说用户或客户当有一个需求出现，我们可以用最短的时间满足它呢？一旦效率的定义发生变化，整个生产体系都会产生颠覆性变化，也就是我前面提到的颠覆性优化，而且因为这些颠覆性优化往往是局部劣化却达到了整体优化，有时连旧的评价体系都给颠覆掉了，导致按照旧的评价体系来看，新的方法可能还是很糟糕的，在看不到全局的人眼中看来，只会看到颠覆性看不到优化从而产生抵触，这都是正常的。可以说，如果没有抵触发生，都算不上颠覆性优化。</p>
<p>由于知识工作自身的这些特点，软件开发又比一般的知识工作还要复杂，我们觉得数字人才必须是一种多视角人才，这其中至少有三大类视角：商业视角、技术视角和用户视角：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/talk-about-digital-talent/pic-02.jpg" alt="描绘软件的三个视角"></p>
<p>所以这个系列文章不会只讲某一种角色的视角，我希望通过这系列文章培养出多视角的人才，所以在标题中淡化了某一种角色的强调，尽管出于我的技术出身，难免技术部分会重一些，最后写出来的数字人才的技术部分的刻意练习会多一些，不过我想也是对读者有价值的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/deliberate-practice-for-digital-talent/deliberate-practice-for-digital-talent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/17/deliberate-practice-for-digital-talent/deliberate-practice-for-digital-talent/" class="post-title-link" itemprop="url">数字人才的刻“意”练习——开篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-17 18:45:00" itemprop="dateCreated datePublished" datetime="2018-10-17T18:45:00+00:00">2018-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="系列背后的故事"><a href="#系列背后的故事" class="headerlink" title="系列背后的故事"></a>系列背后的故事</h2><p>不知道你有没有灵魂画手的体验。所谓灵魂画手，又叫手残党，当它们想画一个东西的时候，画出来的图大都是这样的：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/deliberate-practice-for-digital-talent/pic-01.png" alt="灵魂画作"></p>
<p>反正我从小就有这种体验，非常不爽。我特别想能通过画画来表达东西，然而作为一名灵魂画手，一次次拿起画笔就是一次次的挑战不可能，直到最后让我意识到，确实不可能……</p>
<p>那些图画仿佛有魔力，让我完全没办法画出来。我想有些事情还真是有天赋这种东西存在的。</p>
<p>这个想法并没有让我更舒服，表面上让我对天赋这个词更加敬畏，但内心深处其实对它的厌恶也是与日俱增。然而不管我多么厌恶，我还是一名灵魂画手，一个手残党。我也只能继续认为有些事情还真的是有天赋这种东西存在的。</p>
<p>我一直这么认为着，直到几年前我知道了一本书：《像艺术家一样思考》。我曾经的同事熊节学过那本书之后，经过一个多月的修炼，从手残党变成了可以画素描的人，写了一篇博客发出来：<a href="http://gigix.thoughtworkers.org/2013/6/7/how-i-learned-sketching/" target="_blank" rel="noopener">http://gigix.thoughtworkers.org/2013/6/7/how-i-learned-sketching/</a> ，看了之后令我羡慕万分，于是我也买来了那本书，照着练习。</p>
<p>里面的教学法非常奇特，他让你把图画倒过来，照着画，号称五分钟的奇迹。也就是说，五分钟前你是手残党，五分钟后，你就能画画了。我在照着步骤练习了之后发现，奇迹真的发生了。</p>
<p>一旦倒过来，我变的不再关注于整体造型，而是关注于线条，眼中那些有透视感的线条重新变成了平面上的线条，那些图画不再有魔力，变成了我这样的手残党也可以画出来的东西。那种体验，硬要打一个比方，可以说是麻瓜突然学会了魔法的感觉。</p>
<p>而不同于熊节，我没有开始练习画画，反而开始思考思维方式这个东西。我意识到我可能找到了一种把天赋这种东西从神坛上拉到地上的可能性，所谓的天赋，也不过是自然规律被发现之前人类神化自然现象的迷信叙事罢了。只要找对了方法，人与人可能没有那么大的差别。</p>
<p>“人跟人的差别”，我们这个行业里这种话题聊的格外多，往往是以挖苦工作中的某些“傻X”来开始的。在我们工作中，我们很容易上升到人的问题来进行讨论甚至处理。仔细打开我们的思维看一下，我们的潜意识里是认为应该存在某种天堑，决定了人和人的不同。我们认为工作和人之间存在某种匹配关系，某些人就应该做某种工作，某些人就不应该做，如果匹配错了，后天再怎么努力都是徒劳的。</p>
<p>看过这本书后，我仿佛收到了某种感召，我开始以怀疑的眼光来看待这种归因于天赋的逃避主义论调，并且作为一个自认为资质普通的人，内心深处总有某种冲动，想要一个个的破掉这些说不清道不明的天堑。</p>
<p>我开始假设，只要人们想且得法，经过刻意的练习，都可以学会那些看似不可思议的技能。我开始假设，有些技能，人们会觉得那是某种才能、是天赋，实际上只是技能，是可以通过练习获得的。</p>
<p>这些假设开始去驱动我去学习一些东西，试验一些东西，慢慢我就走上了钻研培训教育的道路。这条路一走就是四年。（这一路走来比较出乎我意外的是，路上比我想象的要热闹一些，一路认识了很多有同样想法的人，有些人还是被同样一本书感召了，大家互相交流，一路上并不寂寞。）</p>
<p>走到今天，已经有了不少的方法心得。我现在还在这条路上，一直走下去可能还能发现更多，为了防止狗熊掰棒子，把前面的忘掉，我还是要抓紧写下来，所以要开始这个系列了。</p>
<h2 id="为什么给意加个引号？"><a href="#为什么给意加个引号？" class="headerlink" title="为什么给意加个引号？"></a>为什么给意加个引号？</h2><p>不是为了说反话，而是为了强调。刻意练习这个词给人看到的时候，人们经常是关注在”练习”两个字上的，仿佛只要只要逼着自己练就好了。自己不需要做出什么认知上的变化，只需要练习，量变自然会产生质变，练习者自己只需要坚持，其他什么都不需要操心。</p>
<p>经过我的一些摸索，我发现重点在“意”。也就是注意力。所以我觉得刻意两个字特别好，里面体现出了注意力的重要性。我一路走来，发现每一种方法，都是一门注意力放置的艺术，就像画画你学会了把注意力放置在线条上，你突然就会了，而如果你没法把注意力放在线条上，你画细节的时候总是在想全局，总也画不出来。而这其实也只是又一遍证明了100年前美国心理学之父威廉詹姆士就提出的观点：”努力和注意力是一个心理事实的两个名字“。换句话说，所谓的不努力，只是不知道如何放置注意力，放置的不对就会很痛苦，也就看起来不努力。</p>
<p>一个好的方法就是，定义出有哪些放置注意力的点，总结出来之后告诉人们，剩下的人们自己能搞定。虽然要想做好还需要做很多的训练，但只有知道了要把注意力放在哪之后，我们的练习才算得上刻意，否则只能算作随意练习。这个是被很多人所忽视的，也是我后面的文章会关注的，所以加个引号强调一下。</p>
<p>就这样吧，虽然是开篇也不要一点干货都没有。总结一下，希望大家能学到：刻意练习的关键在于注意力的放置，否则就不是刻意练习，而是随意练习，下篇见。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/something-about-software-development/user-centered-software-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/15/something-about-software-development/user-centered-software-development/" class="post-title-link" itemprop="url">以用户为中心的软件开发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-15 18:45:00" itemprop="dateCreated datePublished" datetime="2018-07-15T18:45:00+00:00">2018-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天这个时代迭代开发已经成为常识，甚至政治正确，随便谁就能给你扯两句mvp。敏捷也从一个开发的名词变成了管理名词，迭代、测试、反馈这类名词满天飞。</p>
<p>人人都在说这些术语，仿佛他们真的就懂怎么做软件了。起码，觉得自己真的懂怎么创新了。然而经不起细聊，一旦深入下去聊一个mvp，聊聊他的迭代计划。就会发现露馅了，张嘴闭嘴谈的都是功能。这个迭代要交付几个功能，这个mvp多了什么功能？他的竞争对手都有哪些功能？却很少听到用户。人人都在喊，以用户为中心。口号喊得震天响，但你看他们的行为模式，他们的语言中，并没有用户的身影，更像只是在否定别人、固执己见的时候拿这个来当借口。</p>
<p>我时常觉得这个事情不太对劲。但是也没有想到更好的方法。敏捷中使用的故事卡比功能的视角要好一点。因为在故事卡里，你要写下用户的价值。但是，我一直也不知道这个价值是从哪儿来的。是先开枪后画靶子我们想做某个功能了，所以硬安的一些价值，还是真的存在的？价值的单位应该是什么呢？没有单位的东西就无法管理。无法管理，也就无法优化。我们交付的价值是越来越多吗？还是交付的不如以前了？用什么来判断？</p>
<p>回答不了这些问题，不管输赢都是有点不明不白的。这些问题的核心问题就是价值的单位应该是什么？怎么算一个价值？一直没想清楚这些问题，直到我看了我们公司设计团队的一个框架MERLIN，又在《创新的窘境》作者的新书《与运气竞争》里看到了理论依据，这个问题在我这里才算是告一段落。我明白了，以用户为中心的软件开发大概应该怎么做。</p>
<h2 id="方法核心"><a href="#方法核心" class="headerlink" title="方法核心"></a>方法核心</h2><p>如果我们想以用户为中心进行软件开发。那么我们的分析方法应该是围绕着用户展开的。</p>
<p>这个方向倒是不新鲜，一直以来我们在inception的时候做用需求分析时我们的方法就是围绕着用户展开的，一个典型的分析过程，如下图所示。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-01.jpg" alt="用户旅途"></p>
<p>我们会在上面画一条轴，标示出用户旅途。这是用户在使用软件的时候的，他的一个全过程。然后在对应的时间点上，标记出我们的功能。这样我们的功能就不是平白出来的。每一个都联系了用户价值。相对于一般人会更容易理解功能，在ThoughtWorks，我们更多标记的是用户故事。比起功能，用户故事增加了有关价值的线索，因为用户故事首先就是要写出价值。</p>
<p>一直以来我觉得这个图还是不够给力。首先，从用户旅途上的点，到功能的映射这一步，简直是个magic move。对未来的读者来说，并不能很好的传递为什么是这样的一个功能，而不是别的功能？毕竟实现一个用户的价值方法有很多。于是后续在执行的过程当中，难免会僵化行事。</p>
<p>其次，上面的旅途，还可以再抽象和封装。简言之，旅途本身也应该是有抽象层次的。一个旅途上的一个点，可能也是一段新的旅途。</p>
<p>所以现在我觉得，一个更系统的做法应该是这样的，首先做服务设计：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-02.jpg" alt="更宏观的用户旅途"></p>
<p>系统化的分析用户的行为，过程中与企业有哪些触点，在这些触点上，借用《与运气竞争》里的思维框架来讲，用户“雇佣”企业的产品到底是来做什么的，也就是动机有哪些。</p>
<p>然后将这些点再进一步细化，采用故事的模式：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-03.jpg" alt="故事板"></p>
<p>图上的一行会讲一个故事，就像电影分镜或者漫画一样，来表达用户使用的故事，真正的故事，而不是用户故事那种东西，我们叫这个东西故事板。<br>在故事板上，我们描绘了一个故事，这个故事里，用户获得了一种体验。一个故事对应一个体验。在基本需求都已经得到满足的今天，体验是新的最有价值的事情，以体验为中心才是以用户为中心。故事板恰好给了我们一个非常符合人类认知习惯的方式来描述什么是一个体验。也就回答了开头的问题，什么是价值的单位。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-04.jpg" alt="故事板与用户故事的关系"></p>
<p>当我们定义出了价值的单位，就可以从这一单位的价值里面映射出故事卡，来进行开发过程的管理：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-05.jpg" alt="故事板是MVP的细分"></p>
<p>这里就是我们的重点，我们将来交付的软件、交付的服务、我们交付的一个MVP本质上是交付给了用户一组体验。MVP的迭代则应该是更多的体验或某些旧体验的升级（也就是同一个动机，换了一个不同的故事来满足）。</p>
<p>最终我们把用户的价值很好的表达了出来，并且找到了用户体验的基本单位——故事板，由于故事板也可以转化为用户故事，结合早已经存在的各种敏捷开发方法，也就可以对体验的交付进行度量和管理，达到以用户为中心进行软件开发。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>很早之前我就觉得MVP是TDD思想在产品策略上的延伸，TDD一个很重要的价值就是避免自嗨从而消除浪费。程序员有时候会因为自嗨写出来好多用不到的功能和设计，这些都是浪费。但是程序员能减少的浪费很有限，最终的最终还是要从需求的源头——用户层面来减少浪费才能真的做好。所谓顾客就是上帝，软件开发中用户就是上帝，这句话的意思不是说用户说什么你就做什么，而是说你只有贴近用户，才能得到上帝的启示，现场有神明，就是这么个道理。</p>
<p>有了MVP之后，就像开发有了测试驱动。我们就可以避免很多过度设计。但是MVP作为测试，粒度太大了，不好分析，不好写断言，不能得到精细的反馈。这里我们把它分解到故事板层面，就可以得到精确的测试目标，也就可以做真正精细的测试，真正做到以用户为中心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/07/something-about-software-development/bad-smell-of-visualize-arch-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/07/something-about-software-development/bad-smell-of-visualize-arch-design/" class="post-title-link" itemprop="url">架构可视化的坏味道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-07 15:51:00" itemprop="dateCreated datePublished" datetime="2018-07-07T15:51:00+00:00">2018-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="抽象的坏味道"><a href="#抽象的坏味道" class="headerlink" title="抽象的坏味道"></a>抽象的坏味道</h2><p><a href="https://jtong.github.io/2020/01/30/something-about-software-development/visualize-arch-design-introduce-c4/" target="_blank" rel="noopener">上文</a>说过，C4说穿了就是几个东西：关系-线、元素-方块和角色（角色不过是图形不同的方块）、关系表述-线上的文字、元素的描述-方块里的文字，虚线框（如前文所说，在C4里面虚线框的表达力被极大的限制了。）</p>
<p>这些东西一点都不新，我们自己随便找个白板，无非也是用这几个东西来表达架构，它的优点在于引进了一些分层，使得我们思路不是特别混乱，容易给别人看懂我们的思路，也容易帮助自己整理思路。</p>
<p>所以C4不能帮你做好架构设计，但是它能让你的设计中的问题暴露出来。被自己或其他人纠正。</p>
<p>可视化的威力就在这里，但根据我的经验，即便你用上了C4也不见得就能表达清楚，不过好消息是，终于我们可以聊一些高级的表达问题了。</p>
<p>可视化之后，我们能看到自己的表达问题，大概的问题有两个：抽象层次和抽象粒度。这个是表达方面永恒的问题，也就是软件设计永恒的问题，没有万灵丹，但是用上了可视化手段之后还是有机会让生活更美好一点的。</p>
<p>这两个问题可能太抽象了，不容易意识到，那我们可以看图，从图上的具体表现来发现坏味道。一般会有几个迹象表明我们有可视化的坏味道：</p>
<ol>
<li>一张图上过分密密麻麻的线</li>
<li>一张图上太过多元素（也就是方块）也是坏味道</li>
<li>一张图上太少的元素，比如角色特别少</li>
<li>每个图上文字表达不契合，有的太泛泛，有的太细节也是问题。</li>
<li>无限制的画更多张图，基本上也就失去了使用图形化表达的意义。</li>
</ol>
<p>那么对应的手段就有：</p>
<h2 id="合成更大的元素"><a href="#合成更大的元素" class="headerlink" title="合成更大的元素"></a>合成更大的元素</h2><p>当我们发现密密麻麻的线、太多的元素，闻到这个味道的时候。我们可以考虑是不是该把里面的一些元素合成更大的元素了。Component可以合成Container，Container可以合成System，这样就会分成更多的图，每张图就变得没那么多线和元素了。</p>
<p>紧接着会面临下一个问题：怎么合成一个更大的系统，Container是明确的，所以Component合成Container不是问题，问题是Container怎么合成一个系统，为什么是这些Container合成这个系统，而不是另外几个？或者多加几个、减几个？</p>
<p>这个问题没有标准答案，但是有一些其他的框架可以提供一些思考的维度。</p>
<p>比如可以结合akf扩展立方来思考</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-01.png" alt="akf扩展立方"></p>
<p>X轴就比较容易，一方面看你的容器本身的描述来发现设计上是不是支持横向复制的，另一方面则是看你的部署图。<br>Z轴相对难一些，只是比较偏技术。比如当技术上有性能瓶颈，则需要注意这一个维度，有时不得不搞出一些特殊的容器出来，有时已经存在这些容器了，他们可能单独属于一个系统（类似于大数据分析的系统），或者一个系统的某一个局部（这就是我说的虚线框的表达力被限制的地方）。</p>
<p>Y轴给人的感觉是最容易操作的，但实际上却是最难的做好的，Y轴的背后是业务，往往我们觉得就按业务切成多张图就好了么。这种想法就表现出我们其实很看轻理解业务的难度，于是也总是出问题的地方。如果你能跨过这个心理障碍，决定去认真做一下，那么也有一些工具可以帮助我们做好。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-02.jpg" alt="领域模型与架构设计"></p>
<p>最经典的工具组合就是求助于DDD，结合康威定律和步速，考虑维护的团队、使用的角色、变化的节奏，这块展开就复杂了，有机会再聊。</p>
<p>这里说一个最简单的做法。按照用户角色分。同一种角色，由于它的，公司里的职能，他的职责都是已经被定好的。天然在系统上就有一种隔离性。比如招聘专员、会计、出纳。他们使用的系统肯定是不一样。</p>
<p>但说简单，其实也不简单。我见过一些图，上面的角色只有两个，内部用户和外部用户。而另一些图，细化到了persona的级别，或者把职级都放上去了。所以无论再简单的原则，最后都会掉进抽象的坑。</p>
<h2 id="画一些共识图来忽略掉一些通用的元素"><a href="#画一些共识图来忽略掉一些通用的元素" class="headerlink" title="画一些共识图来忽略掉一些通用的元素"></a>画一些共识图来忽略掉一些通用的元素</h2><p>有时候合成了更大的元素，元素依然很多，线条依然很密。画多张图也不够切分的。这个时候我们可以求助于共识。</p>
<p>人与人交流，彼此之间如果已经有一些共识存在就可以少废很多话，共识多到一定程度只需要确认一个眼神就完成交流了。所以毫无疑问做好共识管理，就可以大幅简化我们的架构图。</p>
<p>所以在我们做架构可视化的时候，经常会先画一个技术共识图，比如以一个我们的能力建设的数字平台为例，我们就画了一个下面这样的技术共识图。：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-03.png" alt="技术共识图"></p>
<p>然后在后面画具体的图的时候，我就可以省略掉一些共识的元素，像nginx和数据库就没有了，可以更关注在业务上，而不是技术上来画图。</p>
<h2 id="通过制定主题，限制文字的抽象层次"><a href="#通过制定主题，限制文字的抽象层次" class="headerlink" title="通过制定主题，限制文字的抽象层次"></a>通过制定主题，限制文字的抽象层次</h2><p>其实上面的技术共识图就是类似的做法，只是用于技术方面，如果用于业务方面，我们可以用一些抽象的名词或动词来代替一类业务，比如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-04.jpg" alt="数字平台系统景观图"></p>
<p>上图是一个系统景观图。当前这个主题是希望，人们一眼看清楚这个系统里面的相关角色都在使用什么系统，并且他们关注什么，职责是什么。所以具体学什么，怎么学的，都不是那么重要。所以我们就用学习一词代表了一系列的业务。</p>
<p>当主题确定的时候，很多纷杂的信息就没有了。一定要克制住自己，试图在一张图上，表达足够多信息的冲动。</p>
<h2 id="只画重要的图，剩下的交流的时候再画。"><a href="#只画重要的图，剩下的交流的时候再画。" class="headerlink" title="只画重要的图，剩下的交流的时候再画。"></a>只画重要的图，剩下的交流的时候再画。</h2><p>除了像上面说的，不要试图在一张图上给他足够的信息。同时也，不要试图把所有的信息都表达出来。</p>
<p>绝大多数的图可能只在交流具体业务的时候才画，推荐使用动态图。<br>这个手边没有例子，找到再说吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>即便有了C4这么，好用的可视化工具。我们依然会看到，自己会掉进抽象的坑。所以在使用的时候一定要注意坏味道，经常检察是不是犯了抽象层次和抽象力度的错，才能做好可视化。这件事上，没有谁能幸免，所以要时常自省，与诸君共勉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/something-about-software-development/reuse-obsession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/17/something-about-software-development/reuse-obsession/" class="post-title-link" itemprop="url">复用的着相</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-17 20:48:00" itemprop="dateCreated datePublished" datetime="2018-06-17T20:48:00+00:00">2018-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>着相是佛家用语，指的是执着于外相偏离了本质。<br>仙剑奇侠传中有一个故事。讲的是一个成精了的佛珠。想要让更多的人向佛，于是施法，让这些人失去了记忆，只想一心礼佛。使人向佛，本来是好事，但强人所难，脱离了本质，便是着了相，也可以说反而是入了魔。<br>这个小故事告诉我们，在认知的世界里，我们很容易被表象所欺骗，忽略了本质。为此，佛家发明了这么一个名词来专门指出这种现象。</p>
<p>复用也是一样。复用本来是通过消除重复的方式。得到一系列可以复用的组件。从而在未来的开发工作中，更快速的响应需求变化，也就是所谓的提升响应力。<br>然而很多复用的结果，会造成代码是变少了，改起来却更难了。复用是增加了，可读性却下降了。考虑到软件开发是一个团队协作的工作，而我们这个行业的离职率又能到百分之二十之多。难以学习的代码确实是难以维护的，尽管你可以抱怨接手的人无能，但总之是降低了响应力，也就违背了复用的本质。<br>什么情况下会出现这样的场景呢？主要是因为视角的单一，只从自己单一的视角看到了重复而不是在做全局优化。这个说法可能稍微有些抽象，那我说几个相对具体的情况。</p>
<h2 id="当我们只关注功能视角的时候"><a href="#当我们只关注功能视角的时候" class="headerlink" title="当我们只关注功能视角的时候"></a>当我们只关注功能视角的时候</h2><p>需求有很多的描述视角，可以只在功能角度描述，比如“网站要有任务卡，任务卡上有文字版学习内容，视频讲解、也有作业题。”也可以加入业务视角，比如“学生要报名特训营，才能参加特训营。学生进入特训营后，就看到了任务卡列表。学生在任务卡上阅读学习资料，阅读完学习资料后做题来验证他是否学到，做完后提交交由助教审阅。”当我们只看功能视角的时候，可能会忽视业务上的不同，变的在功能角度过分抽象，最后当业务变化的时候，反而响应速度比较弱。<br>一个简单的后台，我们看起来所有东西长得都一样，不过是列表页面，添加页面修改页面，再加点儿删除什么的功能。说穿了都是crud，干脆我把这事弄成一一个组件好了，每个页面只需要简单配置一下，就可以出来自己的一套，增删改查页面。<br>这种视角完全没有考虑到，不同的实体，它们其实所在的业务是不一样的，关心它们的人也是不一样的。最后，彼此的演化方向也总会出现一些不同，你把它定义成一种东西，对于我每做一个修改，都要背负着其他所有实体的特异性。于是就逐渐拖慢了我改变的速度，降低了响应能力。</p>
<h2 id="无谓的自动化"><a href="#无谓的自动化" class="headerlink" title="无谓的自动化"></a>无谓的自动化</h2><p>有追求的程序员一定会考虑提升工作效率，通过一些自动化的手段来缩短流程，提高效率。不过有时候，这种追求也会有害。<br>在我们的系统里有一个面包屑功能，就是典型的“页面A / 页面B / 页面C”那种面包屑。团队成员提出，一个个页面写面包屑好烦啊，干脆做一个根据URL生成面包屑的功能吧。乍一看好像提高了效率，但实际上URL上的名词和你想显示在面包屑上的名字是可能出现不同的。<br>比如在我们的场景里，我们提供一个任务卡的预览功能，你的面包屑可能是“xx后台 / xx 训练营管理界面 / xx卡预览”，而学生正式使用任务卡的时候，他可能是 “ 学习中心 / xx 训练营 / xx卡 ”。而他们的url里可能都会出现’/programs/$pid/tasks/$tid’。同样的program、task翻译出来的文字完全不同。你为了支持这点不同，又要扩展一些额外功能来做这种区分，做来做去，可能还不如直接写来的方便，至多抽几个常量来简单的消除一下重复。</p>
<h2 id="当我们只从代码上看重复性的时候"><a href="#当我们只从代码上看重复性的时候" class="headerlink" title="当我们只从代码上看重复性的时候"></a>当我们只从代码上看重复性的时候</h2><p>这个我就不举例子了，其实很多犯这个错误的人都是重构的支持者，不过学艺不太精。因为如果你仔细看的话，重构里好多怀味道都有一个跟他对立的怀味道，比如发散式变化和霰弹式修改。如果我们只看代码就会违背复用的本质——更好的响应变化。<br>这个跟我说的第一个场景，只关注功能视角是类似的问题，这个可能更具象一点，只关注代码。</p>
<h2 id="无视上下文的时候"><a href="#无视上下文的时候" class="headerlink" title="无视上下文的时候"></a>无视上下文的时候</h2><p>这个可以看作是只有功能视角的一种情况，很多功能我们觉得有重复性，提升成一个概念，然而其实根本是两个东西，他们只是刚好叫一个名字。<br>比如过去很多软件里，是有一个统一的用户组概念，不管你在哪个业务上下文里，你都需要扩展这个用户组的概念来管理用户的权限。这个带来的结果就是用户组变得越来越臃肿，每次修改都要改一下别的组的功能。在我们的网校数字平台里，学生学习有学习小组，老师出题有出题小组，这两个小组业务完全不一样，这个时候如果都用统一的用户组来管理的话，那就势必会造成无谓的耦合，损害响应力。</p>
<p>这些故事告诉我们，我们不是在真空里去做复用。我们做的软件都是有它的商业目的。我们的工程实践也都是为商业目的服务的。当我们说tech@core的时候，让我们说技术就是业务的时候。诚然，他给技术人员带来了更多的权利，然而权利越大，责任也越大。技术人员也需要跳出技术，具备更多的业务视角和体验视角。而不仅仅是沉浸在技术得自high当中。才能真正的发挥出各种实践的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/programmer-dojo/thinking-as-a-machine-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/06/programmer-dojo/thinking-as-a-machine-07/" class="post-title-link" itemprop="url">像机器一样思考（七） —— 跨应用思考</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-06 17:18:00" itemprop="dateCreated datePublished" datetime="2017-02-06T17:18:00+00:00">2017-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>（本文不适合初学者阅读，目前只是为了方便培训的时候预习而写，也不适合无后续服务的人阅读）<br>现在，我们把上一篇的应用变成网络版。这个时候，你至少有了两个应用，一个客户端应用，一个服务端应用。到这一刻，我们就算具有了一个系统。</p>
<p>当我们有一个系统的时候，我们需要一种框架来简化思考我们的应用。这里又需要我们再次展示我们的概念性思考能力，这时我会采用Linux的模型来思考这个问题，所以应用程序一般我会分为三层：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-07/pic-01.png" alt="layer-of-application"></p>
<p>core层是我的核心逻辑，核心的计算部分放在这里。（Linux里是Kernel，不过Kernel这词比较偏门，咱们这教程的目标是为了尽量降低门槛，还是用core吧）<br>shell层是我链接核心层和用户的地方，你可以简单理解为解析用户输入，包装核心层的计算结果，变成用户看到的输出。Shell层还有一个作用，当我们有多个应用的时候，彼此之间的shell层是互相交互的，Core层是互相不知道彼此的存在的。<br>config层比较难理解，从工程的角度，我们的Core层和Shell层，都不应该控制彼此的生命周期，它们所有的依赖都应该是外部配置的，它们只依赖抽象的接口而不是具体实现。config层就是这一层配置，在Linux的Shell里对应的就是环境变量这个概念。</p>
<p>引入这些概念有什么好处呢？如果用这些概念来解释我们的应用，可以支撑非常大的架构的思考。</p>
<p>我们想象一下，系统随着演进而变大，出现原本的小东西也会变的非常庞大。比如上一篇main函数里的几行代码，随着系统变大，相应的Router也不可能自己写了，Router和Command的关系自然也是在文件里配置的，慢慢的我们就开始需要一个IOC容器。Service本身会变得很复杂，彼此之间可能会有关系，而且甚至可能是别的应用提供的Service。如果我们再使用应用框架里的概念，那么思考也好，交流也好，都会变得很低效。所以我们才引出了config，shell，core这三个概念来简化应用的内部，这样就可以思考大量的应用之间的关系是应该是一个什么样的架构了，不过这个方向是一个更复杂的问题，这里就不展开了。</p>
<p>回到我们的系统上，在一个刚刚出现了前后端概念的系统里，我们的新概念们能帮助我们理解架构的演进，下面就基于这些概念带着大家推演一遍现代常用的一些软件框架是因为哪些力量驱动出来的。</p>
<h2 id="Core的重新定义"><a href="#Core的重新定义" class="headerlink" title="Core的重新定义"></a>Core的重新定义</h2><p>当我们把系统分为客户端和服务端的时候，那么客户端要做什么呢？服务端要做什么呢？</p>
<p>往往客户端是需要更多的照顾用户体验，填平服务端的接口和用户体验之间的沟壑。</p>
<p>服务端则要保证数据读写的性能，安全性和易于被客户端使用。</p>
<p>从这两点来看，客户端应该考虑的是用户体验，而不是让用户体验为服务端扭曲。所以客户端的core层更多的是那层填平服务端接口和用户体验之间沟壑的那堆代码，而它给shell的接口应该是以shell好调用为导向的。</p>
<p>那么怎么算是好用呢？</p>
<h2 id="边界与无限"><a href="#边界与无限" class="headerlink" title="边界与无限"></a>边界与无限</h2><p>刚才谈到，在我们的边界处，好用是一个非常重要的需求。怎么算好用呢？最重要的是边界要找对，如果你过界了，做了事情也会被埋怨。当我们思考系统的时候，边界往往是不好找的。这就需要引入一个新的架构模式： MVC。</p>
<p>所谓的MVC就是Model-View-Controller。一个常见系统，往往Model层负责核心基本元素和基本算法，View层负责展示和表达数据，Controller层负责调度和组合，把Model层和View层连接在一起。</p>
<p>一般来讲，Model层通常是我们的Core，Controller层往往就是我们的shell，View层就是shell返回的数据。这个时候边界的思考就清楚了，谁是我们的model和model相关的核心计算，谁就是我们的core。谁是我们的Controller负责调度组合和内外相连，谁就是我们的shell。而我们的计算结果，也就是我们的View层，是会离开我们的应用供别人使用的，那它是我们的最外面的边界。我们思考边界只需要关注在View层，思考清楚我们的View是否在一个抽象层次上就可以了。</p>
<p>但是，世界不是这么简单的分三层就可以结束了，世界是往复循环以致无穷的。所以我们的MVC也是循环迭代的，也就是说MVC中的某一层还可能再分MVC。那么是哪一层呢？View层。还记得我们第一篇讲得，数据和过程是不严格区分的，所以我们返回的数据，可以被解析为新的过程，新的过程再产生新的数据，从而往复循环以致无穷。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-07/pic-02.png" alt="MVC"></p>
<p>所以可以认为服务端是原应用的Core层进化出来的。</p>
<p>如果我们把View层进化下去，我们前面提到的客户端的Shell返回的数据，还会再划分，就会有新的组件层(Component)，模版层(Layout)，页面层(Page，也有人爱用Container)等等。</p>
<p>随着出现了MVC，再进一步思考就会逐渐发现，其实core层不应该关心后端代码，它应该关心前端的领域对象，以用户眼中的模型为基础计算，而不是后端业务人员眼中的模型为基础来计算。所以他会把弥合后端和前端的工作交给shell层，而shell层会夹在三方面很难受，他一方面要对接后端，一方面要对接core，还有一方面要适配真正的前端模型。前端和后端的拉锯战就会出现，在这股力量的挤压之下，我们的BFF就会自然而然的出现，所谓的前后端分离也就是自然而然的事情了。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="题外话1"><a href="#题外话1" class="headerlink" title="题外话1"></a>题外话1</h3><p>对于有经验的同学要说一句：数据库不是核心，你的代码才是核心。数据库就是系统的另外一个应用而已，虽然数据库厂商希望你把核心放在它里面，但你不要被厂商的策略绑架了你的自由。</p>
<h2 id="题外话2"><a href="#题外话2" class="headerlink" title="题外话2"></a>题外话2</h2><p>面向对象，有一位同学总是在给我纠结这个面向对象怎么画。其实之所以有此问并不是不知道怎么用强类型语言来画图，如我们第二篇所述，你换成类图也是一样的。主要的纠结点在于，那个函数放在哪个类里这个问题。</p>
<p>之所以一直没讲，是因为面向对象是纯粹的人类思考问题的方式，它是非常不精确的，把哪个函数放在哪个类里这个事情是一门艺术而不是一门科学。当我们有一个Dog类的时候，有一个bark方法是非常明显的。当我们有一个货物类（Goods)的时候，算税应该是它的方法吗？当我们有一个数据库实体的时候，比如User，Item等等，那么存储算他的方法吗？如果我们做一个CRM系统，Client明显跟所有的业务都有关系，总不能Client这个类上有所有业务的方法吧？所以我们无论怎么放，都可能是有问题的，而且在变化来临前，我们没有什么客观的标准来判断当前的做法是否合理。</p>
<p>如果只是画图来表达的话，其实我们的方块上，也表达出了哪个函数属于哪个类，这样已经便于有经验的人发现问题并解决问题了。只是没有任何客观的公式可以帮助大家轻松的解决问题。我们只能帮你这么多了，毕竟方法，从来也不是为弱者服务的。</p>
<h2 id="题外话3"><a href="#题外话3" class="headerlink" title="题外话3"></a>题外话3</h2><p>你这个是不是六边形架构？<br>其实可以看作是六边形架构的一种变种，我只是比较讨厌六边形这个词，它太容易让人纠结为啥是六个边，不是八个？比如我叫八卦可不可以？所以我们也不要太纠结他叫什么，领会精神就好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/programmer-dojo/thinking-as-a-machine-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/06/programmer-dojo/thinking-as-a-machine-06/" class="post-title-link" itemprop="url">像机器一样思考（六）—— 脑中的重构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-06 11:35:00" itemprop="dateCreated datePublished" datetime="2017-02-06T11:35:00+00:00">2017-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇里，我们实现了一个小应用，而且用两种设计。本文将给出更多的设计实现以继续探讨设计问题。</p>
<p>我们会看到，即便是纸上的图，也可以进行重构。由于纸是我们大脑的延伸，也可以称之为脑中的重构。而这种重构的结果由于并不是真正的代码，所以即便重构错了方向，设计不合理，抛弃也非常简单，相对于改代码而言，几乎没有成本。</p>
<h2 id="简单的改进"><a href="#简单的改进" class="headerlink" title="简单的改进"></a>简单的改进</h2><p>第一步我们先做得简单一点，上一节我们停在这张图上：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-01.png" alt="image1"></p>
<p>我们可能会觉得上一节的图有点啰嗦，比如buildStudentInfoPromptString和buildStudentSeqencePromptString两个函数，甚至generateReport都啰嗦了。那我就可以重构一下，去掉这些啰嗦的内容，变成下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-02.png" alt="image2"></p>
<p>上面的改进可能我们不太满意，我们试着走另一个方向，从整个程序的角度来减少输入输出。我们前面说了，每个函数的输入输出种类越少越好，那么在我们这个题目里，推到极致就是每个函数不自己处理打印和读取，所有的打印和读取都放到一处。不但不打印和读取，还不调用其他函数，那么就会变得像下面这张图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-03.png" alt="image3"></p>
<h2 id="概念性思考"><a href="#概念性思考" class="headerlink" title="概念性思考"></a>概念性思考</h2><p>上面这个实现在过程层面已经实现了只在一个函数中打印和读取用户输入。然而这个最大的函数却很臃肿，除了不干具体的活，这个系统中所有的逻辑它都知道。这种全知全能的函数，如果有更多层级，更多菜单的应用，这个函数很容易就臃肿到不能维护的地步。</p>
<p>那么我们就来想一下，有没有一种设计，在层级更多的时候表现的更好。这个时候我们需要一种思考能力，我们称之为概念性思考。<br>概念性思考一般分为四步：</p>
<ol>
<li>看到复杂场景背后的核心本质</li>
<li>识别到两个不相关的情景的相似之处</li>
<li>用比喻或类比来解释场景</li>
<li>用一个框架去解决问题</li>
</ol>
<p>那么我们按照这四步走，当前的复杂场景就是这个应用，看起来每次输出之后，还会有下一次输出之前的提示，好像每次的提示，输入，输入后的打印三个是一组的，其实完全可以把输入后的打印和下一步的提示看作一次处理，也就变成了根据用户一次输入进行一种计算，将计算的结果转化为一次输出。这也就是它背后的核心本质。</p>
<p>简化成这种核心本质后，有没有一种已经存在的类似情景呢？我们通过观察很容易可以看出，一个简单的Web应用和一个命令行应用没什么区别，当然是没有ajax的传统web应用。用户每做一次请求，然后得到一个响应，这个响应会渲染成一个页面。</p>
<p>如果这两个东西有些相似性的话，那么什么是一次请求到一次响应的结束呢？在这个应用里，输入完字符串之后，敲击回车就是一次请求。当敲击回车后到下一次看到要求输入时为止就是一次响应。</p>
<p>在我们这个应用里举一个具体的例子来类比一下，在主界面输入1，并敲击回车，为一次请求；从敲击回车后，经历诸如下列的文字被打印出来的阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入学生信息（格式：姓名, 学号, 民族, 班级, 学科: 成绩, ...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>一直到变成可以进行下一次输入的状态为止，为一次响应。其余的情况以此类推都可以类似的理解为请求和响应。</p>
<p>那么有没有现成的一个web开发的框架可以照搬来处理这个命令行应用呢？那可以选择的就多了，各种经典的WebMVC框架都可以。当然照搬任何一个WebMVC框架的话的话可能会比较啰嗦，反而降低效率，我们可以在理解它们的概念的前提之下仿造一个，这就是下一节的内容了。</p>
<p>至此，我把我在这件事情上进行概念性思考的过程展示给了大家。做一个优秀的程序员，分析性思考和概念性思考是两大关键思考能力，希望每个读者都可以通过这一系列教程理解这两种能力，从而在工作中进行刻意练习直到掌握这两种能力。</p>
<h2 id="我们的框架"><a href="#我们的框架" class="headerlink" title="我们的框架"></a>我们的框架</h2><p>有些话要说在前面，这个题目比较简单，但我给出的解决方案是可以处理更多层级，更多菜单的，只是如果我给出的题目太过复杂的话，大家可能连读完需求的耐心都没有，更不要提理解解决方案了。所以我们算是用了一个复杂的方案来解决一个简单的题目，中间的差距请大家自行想象，这个方案在更多层级和更多菜单时，才会真正显现威力。</p>
<p>言归正传，在我们的这个框架里，我们的过程方面有三个概念：Router，Command和Service。<br>Router负责当每一个用户输入进来的时候，它知道去找哪一个具体的响应者，这个响应者就是我们的Command。<br>Router通过简单的输入解析，找到具体的Command，Command负责处理各种具体的用户输入解析，但是有一些核心的计算，比如说添加学生信息，我们定义为Service。Command会调用Service函数和将Service计算结果翻译为用户友好的输出。当Command处理完一切，就会返回结果，结果就会统一的输出。Command一般不直接输出到用户接口，这样就会便于测试，就像我们所有的WebMVC框架一样。管理这些输入输出的是我们的main函数，它还会负责把我们的Router，Command配置在一起，像极了WebMVC里的配置文件。</p>
<p>过程方面分析完了，在数据方面，我们只需要把Service和Command之间的通讯，Command和最外层之间的通讯抽象出一些概念就可以了，比如Service和Command之间的数据可以叫Response，Command和最外层之间的数据可以叫View。</p>
<p>所以综上，我们可以开始画图了，但是这个画图呢比较难画在一张图上，所以我们就把一次“请求”和一次“响应”画成一张图，这也是一种可视化的技巧，当我们把一件事画成多张图的时候，我们的大脑会自己把这些图联系到一起，并不需要我们在图上表示出，他们是有关系的。</p>
<p>总之，这个应用可以画成的图如下所示：</p>
<p>应用启动：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-04.png" alt="application-example-home"></p>
<p>去界面1：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-05.png" alt="application-example-goto-add"></p>
<p>添加学生成绩：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-06.png" alt="application-example-add"></p>
<p>去界面2：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-07.png" alt="application-example-goto-print"></p>
<p>打印学生成绩：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-08.png" alt="application-example-print"></p>
<p>退出：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-06/pic-09.png" alt="application-example"></p>
<p>将上述图片翻译成Task的时候，就会用到Response和View。</p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol>
<li>列出所有的任务</li>
<li>改进需求1: 请引入加分策略，参照第二篇</li>
<li>改进需求2: 请把每次添加学生信息输出到文件，每次打印成绩单时，从文件读取。画出图和任务列表。</li>
</ol>
<h2 id="题外话－1"><a href="#题外话－1" class="headerlink" title="题外话－1"></a>题外话－1</h2><p>问：一个用户输入到一个用户输出算一张图的话，这个命令行程序还好说，正常应用里的拖拽怎么办呢？<br>答： 首先，拖拽的时间是可以切分成时间片的。对于每一类时间片，其实我们可以画一张图。（当然，你会嫌烦，有这功夫不如做出来了）其次，如果我们拖拽的话，整个过程其实只在前面出现效果而已，没有任何数据往后发送，只有拖拽结束那一刻，才会有严肃的数据产生。所以我们一般不关注效果部分，因为他不触达核心，所以即便想的不全，改起来也不困难。所以完全可以先做再改。</p>
<h2 id="题外话－2"><a href="#题外话－2" class="headerlink" title="题外话－2"></a>题外话－2</h2><p>为什么这么划分图？<br>除了像request和response之外，之所以这么划分，还因为这是一个个的业务场景。我们在前面的几节里，使用的思维主要是结构化思维，就是把一个整体的分解为多个模块的思路。而在这里面，我们使用的是场景化思维，每一张图实际上都是一个业务场景。需求的场景化是非常重要的一种思维，这会有助于我们把业务、组织和软件进行有机的设计。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/18/tech-leadership/growth-method-of-team/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/18/tech-leadership/growth-method-of-team/" class="post-title-link" itemprop="url">团队的精进之道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-18 18:45:00" itemprop="dateCreated datePublished" datetime="2016-12-18T18:45:00+00:00">2016-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】</p>
<p>之前写过一篇文章《编程的精进之法》，总结了ThoughtWorks中一点工作方法。现在看来，那篇文章其实应该叫个人精进之法。然而现在不是个人英雄的年代了，我们需要再深想一步，一个团队应该怎么办？</p>
<p>当我们在带领一个团队的时候，我们想的总是，如何做好任务分配，平衡团队战斗能力，交付最好的结果。于是做的时候就会下意识的去简单、被动的因材分工，那么随着项目的进展，人员的流动，各种意外的发生使得我们在项目后期感到处处掣肘，于是只能加班以示诚意。</p>
<p>我刚入行的时候，经历的各个项目都是如此，一直觉得这种事情就是天经地义的，直到认识了一个项目经理。该项目经理是个高人，他在项目开始的时候，问清楚每个人擅长的部分，然后让每个人去做自己不擅长的部分，不会？去找擅长的人帮忙。比如，张三说我以前做过用户权限管理，李四说我以前做过单据管理，王五说我以前做过工作流。（交代一下例子的上下文，那家公司主要就做一个大的领域，那个时候也不像现在前后端分这么清楚，项目经理有时候还要身兼Tech Lead）他就会说，好，张三去做工作流，王五去做单据管理，李四去做用户权限管理，遇到不会的，谁擅长什么你们都知道了啊，去问。</p>
<p>虽然看起来有点乱来，但是他负责的项目从来没出过问题。后来我加入了ThoughtWorks才知道，听到一个口号：“把项目成功交付看作能力建设的副产品”，才知道这是这口号的一种朴素实现。<br>很多团队能力不强，团队的领导者就总是在向外寻找方法的帮助。寻找方法帮助其实没有错，但是寻找方法帮助的人，心态往往都是错的。当我们在向外诉求方法的时候，很多人的潜意识，是假设我们团队成员能力不变的情况下，通过一种魔法般的方法，就可以改变团队的绩效，这种思路在真实世界里是走不远的。</p>
<p>在ThoughtWorks，我们认为，软件开发中的一切问题，根本上都是人的能力问题。如何发展每个成员才是问题的关键，因为成员如果没有进步，始终是治标不治本的。所以我们采用的一切实践，不管是以前曾采用的还是以后会采用的，核心目的都只有一个：发展人的能力。因此才有了那个听起来很耸动的口号：“把项目成功交付当成能力建设副产品”。</p>
<p>如何发展人的能力？讲东西吗？不太靠谱，信息仅靠分享是没用的，我经常把刚讲过一遍的知识，让人复述；把结对时刚写完的代码全删掉让同伴重写一遍，能做到的人不多。记也记不住，做也做不到。</p>
<p>就像我之前《然而培训并没有什么用》里说的，做练习？没时间，项目太忙了。而且，就算你有时间，我们拿出时间来做练习，你能保证到了跟练习不一样的场景下，团队成员们都能用好吗？把学会的知识在新场景下用好这件事，还是挺看天赋的。</p>
<p>讲东西不靠谱，做练习没时间，那难怪大家不考虑能力建设了。不过，如果我们反过来想，这个问题就变得没那么难办了，既然没有时间做能力建设，那么也许一切活动都可以看作是能力建设。所以那个项目经理的招数虽然看起来比较乱来，但却是这个思路，我在项目开始的时候，不是着急去以最快的速度交付结果，而是通过任务分配，发展团队成员的能力。在一个较长的时期里平均来看，我们就是在以最快的速度交付结果。</p>
<p>所以，回到我们的主题，就是团队的精进之道就是把交付过程中的一切活动都看作能力建设，把整个团队构造成促进每个成员成长的生态系统。</p>
<p>说起来好像挺简单，我只要换个角度看就好了，然而如果想要做到并没有那么简单。这里面差异微妙而关键。</p>
<p>比如以上一篇文章《软件开发的精进之法》讲到的方法为例。一个人要划任务，然后估时间，然后做的时候计时，根据实际结果进行反思。我们可以把这个方法做成非常邪恶的，仿佛流水线上工人的强制要求。我不关心你为什么超时，就通过这种方法来控制程序员，要求每个人都严格按照一个死板而僵化的步骤做一些简单重复的机械动作。也可以用这个方法来锻炼一个人的自我认知和发现知识漏洞等能力，促使他以最快的速度成长，等他成长起来马上给他更重要的任务，比如评估技术、评估项目、带新人、做架构等等。这两种结果的差异，背后就是领导者认识的差异，团队成员认识的差异。从这个认识的不同我们早在很多年前，就被一些大牛们观察到，作为敏捷宣言里的一句话表达了出来：“个体与交互 胜过 流程和工具”。</p>
<p>团队里的流程和工具，是为了成就个体，促进交互，还是为了抹杀个体，消除交互，这个微小而关键的差异，是一切的本质。有多少团队学了ThoughtWorks的一些实践，搞了看板、开放工作空间、TDD、CI，团队氛围依然压抑，成员之间交流不畅，个体成长不受尊重，领导与员工玩“猫和老鼠”。这样只学了形没有学到神的做法，最后的结果不会太好。</p>
<p>与之相反的做法呢？在上一篇文章《软件开发的精进之法》的开篇曾经简单的提到，新时代的管理者比起老板，更像老师。师者，传道，授业，解惑。各位老师，你们准备好了么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/18/deliberate-practice-for-digital-talent/growth-method-of-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/18/deliberate-practice-for-digital-talent/growth-method-of-programming/" class="post-title-link" itemprop="url">编程的精进之法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-18 02:34:00" itemprop="dateCreated datePublished" datetime="2016-09-18T02:34:00+00:00">2016-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 14:13:52" itemprop="dateModified" datetime="2020-02-01T14:13:52+00:00">2020-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>（作者注：阅读本文需要一定的编程经验和对一些敏捷实践，如TDD，有一定的了解）</p>
<p>编程，众所周知被定义为知识工作，所有的知识工作，从业者和门外汉都喜欢把它神秘化，将整个过程以不可知论的风格来解释。理由往往只是简单粗暴的讲诉一些体力工作时代形成的方法照搬到知识工作中来失败的故事，也毫无理论依据。偶有几个人写理论理由，写出来的理由跟癔症者的呓语也无甚差别。我个人是反对将知识工作神秘化的，我是科学管理原理的忠实粉丝，我觉得尽管科学管理原理的具体案例都过时了，但泰勒的研究方法依然是工作的，只是研究者和被研究者发生了一些微妙的变化。</p>
<p>彼得德鲁克在《21世纪的管理挑战》中提到，知识工作者需要自我管理，那么很明显不是体力工作时代形成的方法不能用在知识工作中，而是不能指望个体之外的人对个体进行简单的粗暴的分析和命令就可以形成很高的生产效率了。这个分析和下命令的人必须是知识工作者自己，我们需要自己纪录自己的行为，然后分析、优化，才能得到生产力的提升，任何向外诉求都会很快的撞上一个“天花板”而无法提升。如果非要寻求外部控制，那么我们只能说，对于新时代的管理者的定位，比起老板，更像老师，以引导和帮助训练为主，每个人真正的效率提升主要还是要靠自己。</p>
<p>那么如文章标题所述，追求知识工作的一种——编程的效率，是本文关注的重点。但我们首先要声明，本文不是给一个可以直接产生高生产效率的方法，而是给一个可以可视化自己生产效率以找到瓶颈的方法。至少在不改变质量的前提下，可以极大的提升你的效率，如果使用得当，可能会质量和效率双提升。</p>
<p>本文引入的方法也并不新鲜，简单说来，就是任务列表法＋PDCA的一套组合使用而已。大道至简，坚持者寡，而坚持下来的人往往都可以获得数倍的效率提升。</p>
<h2 id="任务列表法"><a href="#任务列表法" class="headerlink" title="任务列表法"></a>任务列表法</h2><p>我们做任何事情都应该划出任务列表，按照任务列表一项项去完成，这不是什么特别少见的工作方式。然而，很多人的问题在于，列出的问题列表不能达到完全穷尽，各自独立。</p>
<p>完全穷尽是什么意思呢？<br>当我开始做事情的时候，我不能把所有的事情穷尽，我列出的列表跟我做的事情是不完全等价的，这说明我们的工作行为是非常混沌不可视的，哪怕是对自己。<br>有时事情看起来在大面上是穷尽了，但是做的时候，发现又出现了新的任务。那说明每一项任务的输入和输出没有想清楚，所以当发现输入输出有欠缺的时候（主要是输入，输出欠缺的结果也是要补输入），就需要新的任务来准备输入，于是任务列表就增加了，这也是一种没有穷尽。</p>
<p>各自独立是什么意思呢？</p>
<p>意味着，每一项任务都可以单独做完，而不需要先做完其中一项任务，才能做完另一项。<br>假如我有三项任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 任务1</span><br><span class="line"># 任务2</span><br><span class="line"># 任务3</span><br></pre></td></tr></table></figure>

<p>我做的时候，必须把任务2做完，任务1才能做完。任务3做完，任务2才能做完。结果我就从任务1开始一路做到任务3，最后再逐步回到任务1，整个过程非常混乱，那就不是各自独立的。</p>
<p>在现实生活中想做到各项任务都独立挑战还是比较大，但是在编程的世界里，挑战没有那么大，程序世界做到这一点真的太轻松了。优秀的设计都是要求解耦的，如果做不到，基本等于活儿比较烂。</p>
<p>当我们做到任务的完全穷尽与各自独立之后，我们任务列表法才算达标，这之后才能高效的工作，然而达到这一点并不是一蹴而就的，没有谁可以一上来就做到任务划分可以完全穷尽、各自独立，需要不停的刻意练习。所以我们称之为编程的精进之法。</p>
<h2 id="PDCA"><a href="#PDCA" class="headerlink" title="PDCA"></a>PDCA</h2><p>PDCA是Plan-Do-Check-Action四个词的组合。这是著名的戴明环。讲究从计划开始，经过实践，再反思，产生的改进行动再纳入下一轮计划的持续改进过程。</p>
<p>当我们把这一套从工业领域搬过来的时候，我们对计划的理解还是工业领域那一套。如果用在个人提升方面，我们应该把PDCA微观化，这之后就有两个问题需要被解答，一个是Plan是什么？一个是Check什么？</p>
<p>第一个问题的答案是很显然的，我们前面讲的任务列表法就是在形成这个Plan。</p>
<p>第二个问题本身是一个母问题，每当我们对这个问题的回答，都要回答一个衍生出来的子问题：我们要做点什么才能在需要Check的时候能够Check。常用的套路有两个：</p>
<ol>
<li>Plan的时候估计一个时间，然后开始做，做的时候计时，做完就要Check这个时间是否达标，无论快了还是慢了（通常是比较明显的差距才反思，比如20%以上的差距），Check都要反思并产生Action，纳入到未来的Plan中去。</li>
<li>估计的任务列表和实际做的任务列表是否是一样多的？往往是会多出来，这时就要反思，自己在哪里有不足导致了这个差别。</li>
</ol>
<p>这些反思往往是发现自己的问题，比如自己不熟悉的知识点，不熟悉的方法，甚至不熟悉的业务知识，最后的Action也往往都是进行刻意练习来提升生产效率，比如反复练类似题目。有时也会是通过一些效率工具的使用来提升效率，比如抽取live template，使用快捷键，只是效率工具的使用往往也需要刻意练习就是了。有时也可以通过复用技术（其实live template已经是复用技术了）来提升生产效率，然而可复用模式的识别与抽取本身也是需要练习的，否则在那里纠结浪费的时间更长。</p>
<p>有些同学会感觉到，记录了时间却不知道哪里有问题，这个时候可以跟TDD相结合，把时间划分为写测试的时间，写实现的时间和测试通过的时间。其实除去这几种时间，还有其他时间消耗，比如调研的时间。不管怎么划分，将时间消耗结构化掉，一部分一部分的追求最高效率是一种可行的办法。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>我们做一个简单的修改用户信息功能的API。那么我们在某一个Java技术栈上可能的任务列表是长这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 写UserController （10分钟）</span><br><span class="line">2. 写UserDAO （15分钟）</span><br></pre></td></tr></table></figure>

<p>当你真正开始做的时候，会碰到两种主要的意外：</p>
<ol>
<li>任务列表扩张</li>
<li>时间估计不准</li>
</ol>
<p>我们下面就这个例子，讲一讲遇到这两种意外，我们应该怎么反思和处理。</p>
<h3 id="任务列表扩张"><a href="#任务列表扩张" class="headerlink" title="任务列表扩张"></a>任务列表扩张</h3><p>任务列表扩张，顾名思义，就是指我们一开始估计的任务的数量随着我们开始工作变的比预想的多，可能有两种主要原因：</p>
<ol>
<li>技术原因</li>
<li>业务原因</li>
</ol>
<p>技术原因，比如在这个案例里面，第二项任务：写UserDAO，就是一个没想清楚的事情。我们还需要建数据库表，我们在一个有migration脚本支持的技术栈设计上工作，我们还需要写初始化脚本和回滚脚本，也许这是我的第一个表，所以我还得配置数据库，搞不好还要把ORM的基础代码都写完，所以这些导致了我可能任务估少了。再比如，我们的项目规范要求我们Controller不能直接调DAO，要在中间加一个Service，尽管我个人觉得这是一件很二的规范，然而规范就是规范，我对项目技术规范不熟悉结果导致我画出来的任务缺少了一些必要的任务。再比如，我们的项目采用的是Jersey，根本没有Controller这么一个东西，那么不了解技术框架导致我的任务根本就划错了。</p>
<p>这种情况属于我对技术了解不足，通过对任务列表扩张原因的Check，我会得出一些Action：去了解技术规范，去深入了解项目的技术架构，现有的代码，以防止以后的任务画错。</p>
<p>业务原因，也比如在这个例子里，我们的系统需要在更新用户信息的API里不能更新密码，所以我们还需要一个专门的修改密码的API。再比如，这是一个遗留系统，用户信息的修改会触发数据库里的一系列触发器，从而修改系统的其他数据，然而有些修改是有前提的，那么我就需要更多的任务去处理这些前提条件；或者当数据变化时，要求我去修改系统里的其他数据，那么我就需要更多的任务去完成这些工作。</p>
<p>这种情况属于我对整个系统的业务了解不足，通过对任务列表扩张原因的Check，我会得出一些Action：通读数据库表，通读代码，更全面的阅读需求，或者跟需求方更多的沟通，以了解业务。</p>
<h3 id="时间估计不准"><a href="#时间估计不准" class="headerlink" title="时间估计不准"></a>时间估计不准</h3><p>时间估计不准就简单了很多，在这个例子里，就是这两个任务我估计的时间与我做的时间不相匹配。可能的主要原因也有三个：</p>
<ol>
<li>任务列表扩张了，但是我没意识到，比如UserDAO写起来没有我想的那么简单，所以多花了时间；</li>
<li>单纯的技术不熟练；</li>
<li>花了太多时间在纠结上；</li>
</ol>
<p>对于隐藏的任务列表扩张，时间估计不准给了我们一个很好的线索去发现。一旦发现了，可以前文所述去处理，也就不再赘述</p>
<p>对于单纯的技术不熟练，就如前文所述，要去设计刻意练习。比如我就曾设计过对数据库的增删改查的一组训练以提升自己的速度，使得我即便使用TDD依然保持一个极高的速度。我们自己没有意识到，基础能力的不熟练对于我们的高级能力的限制有多严重，这种体验也只有基础能力已经熟练的人去教基础能力不熟练的人一些高级技能的时候才会发现。这种视而不见的收益，使得大多数人都会轻视基本功的练习。哪怕已经获得收益的人，也容易鼓吹要更多的启发而忽略了基本功的价值。</p>
<p>对于花了太多时间在纠结上，这其实也是一种不熟练，是对设计知识和能力的不熟练。之前看的设计知识只能有一个大概的感觉，对于每个知识的边界、使用之后的发展、如何从一种设计过渡为另一种设计了解不清，从而害怕在那一刻犯错。实际上真正值得纠结的部分没有那么多，大多是自己吓自己，或者引入了过度设计。当然也有一种情况是暴露出了架构级的问题，比如我们对于应该提出的原则性规范没有提出，所以导致我们每个地方都要现想，大家可以想象没有RESTful之前设计Web API，我们可能真的是每一个API都现想的，有了它之后，我们的纠结时间就变少了。这种情况下，通过本方法，架构师也算是有了相应的数据支持，那么架构师也就有了发现问题的一种工具。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总的来说，任务列表法＋PDCA式工作法形成的组合方法，是一个通过逐渐提升个人能力以达到高效工作的方法。这两种方法单独拿出来用，都会由于各自的局限而有各自的天花板，只有有机的结合才能真正突破这个天花板。刚开始使用起来，对于很多人来说会有一些痛苦，这一点上我只能说，提升就是痛苦的，而新的习惯一旦养成，痛苦也就不翼而飞，所以美国心理学之父威廉詹姆士说，“我们需要在尽可能早的时候，让尽可能多的有用的动作变成自动的和习惯的……一段痛苦的艰难时期之后就是自由的时光”。当我们基础能力达到一个极高的效率之后，我们会发现我们争取自由的筹码会变得更多。</p>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>有人可能会觉得列出符合上文所述标准的任务列表比较难，欢迎阅读拙作《像机器一样思考》系列文章：</p>
<p><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-01/" target="_blank" rel="noopener">像机器一样思考（一）—— 宏观的基础</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-02/" target="_blank" rel="noopener">像机器一样思考（二）—— 数据的细节</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-03/" target="_blank" rel="noopener">像机器一样思考（三）—— 穷尽就是力量</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-04/" target="_blank" rel="noopener">像机器一样思考（四）—— 一图抵千言</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-05/" target="_blank" rel="noopener">像机器一样思考（五）—— 第一个应用</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-06/" target="_blank" rel="noopener">像机器一样思考（六） —— 脑中的重构</a><br><a href="https://jtong.github.io/2020/01/30/programmer-dojo/thinking-as-a-machine-07/" target="_blank" rel="noopener">像机器一样思考（七） —— 跨应用思考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
