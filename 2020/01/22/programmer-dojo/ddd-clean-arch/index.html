<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jtong.dev","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="传统的三层架构传统的web开发都有典型的三层结构，从上到下依次是controller，service，dao。controller负责http的请求和响应，以前还负责调用jsp等模板渲染引擎来渲染页面返回html，现在基本上都前后端分离了，不再干渲染页面的活，而是返回json来扮演web api了（还有用rpc的，也是一样的承担api的职责）。 service负责业务逻辑，dao则是最下层负责与数">
<meta property="og:type" content="article">
<meta property="og:title" content="在DDD中采用Clean Arch的经验分享">
<meta property="og:url" content="https://jtong.dev/2020/01/22/programmer-dojo/ddd-clean-arch/index.html">
<meta property="og:site_name" content="铜剑技校">
<meta property="og:description" content="传统的三层架构传统的web开发都有典型的三层结构，从上到下依次是controller，service，dao。controller负责http的请求和响应，以前还负责调用jsp等模板渲染引擎来渲染页面返回html，现在基本上都前后端分离了，不再干渲染页面的活，而是返回json来扮演web api了（还有用rpc的，也是一样的承担api的职责）。 service负责业务逻辑，dao则是最下层负责与数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/ddd-clean-arch/pic-01.png">
<meta property="article:published_time" content="2020-01-22T16:49:00.000Z">
<meta property="article:modified_time" content="2022-09-05T10:13:30.479Z">
<meta property="article:author" content="仝键">
<meta property="article:tag" content="programming">
<meta property="article:tag" content=" training">
<meta property="article:tag" content=" coding">
<meta property="article:tag" content=" java">
<meta property="article:tag" content=" agile">
<meta property="article:tag" content=" ddd">
<meta property="article:tag" content=" clean arch">
<meta property="article:tag" content=" extreme programming">
<meta property="article:tag" content=" xp">
<meta property="article:tag" content=" tdd">
<meta property="article:tag" content=" test">
<meta property="article:tag" content=" arch">
<meta property="article:tag" content=" design">
<meta property="article:tag" content=" learning">
<meta property="article:tag" content=" oo">
<meta property="article:tag" content=" visualization">
<meta property="article:tag" content=" refactoring">
<meta property="article:tag" content=" lean">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/ddd-clean-arch/pic-01.png">

<link rel="canonical" href="https://jtong.dev/2020/01/22/programmer-dojo/ddd-clean-arch/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>在DDD中采用Clean Arch的经验分享 | 铜剑技校</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">铜剑技校</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">仝键的个人技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jtong.dev/2020/01/22/programmer-dojo/ddd-clean-arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="仝键">
      <meta itemprop="description" content="写写心得，写写教程，希望能帮助更多人成为优秀的软件开发人员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="铜剑技校">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          在DDD中采用Clean Arch的经验分享
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-23 00:49:00" itemprop="dateCreated datePublished" datetime="2020-01-23T00:49:00+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-05 18:13:30" itemprop="dateModified" datetime="2022-09-05T18:13:30+08:00">2022-09-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="传统的三层架构"><a href="#传统的三层架构" class="headerlink" title="传统的三层架构"></a>传统的三层架构</h2><p>传统的web开发都有典型的三层结构，从上到下依次是controller，service，dao。controller负责http的请求和响应，以前还负责调用jsp等模板渲染引擎来渲染页面返回html，现在基本上都前后端分离了，不再干渲染页面的活，而是返回json来扮演web api了（还有用rpc的，也是一样的承担api的职责）。</p>
<p>service负责业务逻辑，dao则是最下层负责与数据库交互。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这三层看着很美，本来是想要解耦的但实际上确是耦合在一起的，主要是他们用的模型类，也叫实体类往往都是一套，这就是他们的耦合点。这么搞就很坑了，现代spring开发框架下，带来的就是各种annotation的滥用，json的annotation和持久化的annotation都标记在一个类上，将来想拆都不好拆，平时想改都不敢改，实现一个新的需求变化，因为背着各种关系和不同层的限制和约束，基本上就是带着镣铐跳舞。同样由于边界的划分不清，数据模型之间的循环引用和因此还要采用的trick手法来切断都是开发的负担。</p>
<p>抛开模型造成的耦合，三层自己也经常搞错。service层和dao层经常逻辑混在一块。业务逻辑跟sql混在一起，想换个nosql之类的实现都不好换。想做数据库迁移也不好迁移。通常项目刚开始的时候会觉得技术迁移是未来的事，等过两年就是每天都要考虑的事。controller里写业务逻辑也是很常见的，本来该在service的写在了controller，最后大量的重复代码还看不清操作的核心逻辑。同样也是迁移时的困难。</p>
<h2 id="新的架构"><a href="#新的架构" class="headerlink" title="新的架构"></a>新的架构</h2><p>在上面的问题章节里，我们聊到的问题基本都可以用边界不清来表述，如果用更精炼的词就是耦合。耦合大家都知道是不好的，然而却还是写出很多耦合的代码，到底是为什么呢？主要还是因为没有相应的概念帮我们区分代码都分为哪些类别，都有哪些更具体的概念来识别职责，这种概念越少，越模糊，越容易写出耦合的代码。</p>
<p>新的架构就要提供一些更细节的概念来帮助我们解耦。所以这里我们介绍一个基于clean arch的改版架构，它的主要思想都是源自于Clean Arch，但是有些地方也使用了六边形架构和洋葱头架构的名词，毕竟很多人都说，这三个架构本质上是一回事。</p>
<p>首先了解一下adapter、usecase和domain这三个大层，如下图（domain指的是最内核写着entities的部分，往外依次是use case，adapter，蓝色的部分就是实际的外部世界了）</p>
<p><img src="https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/ddd-clean-arch/pic-01.png" alt="image.png"></p>
<p>在最外面的controller那些属于adapter，它们主要负责表现层的渲染，跟外部程序的交互，比如响应HTTP请求。adapter自己也是分组的，有时候不同的协议接口都会算作不同的adapter，比如HTTP的API和RPC的API，通常用于一个服务以不同的方式对外提供服务；有时候场景不一样也算不同的，比如web api和web page会被我归成两个adapter，通常用于遗留系统里部分页面还是后端渲染的时候；有时候不同的技术也是不同的adapter，比如spring mvc和Jersey，通常用于技术迁移过程中；</p>
<p>有一种建议是adapter也要与具体的框架分离，这个我觉得大部分情况下adapter这层不是很复杂，全部重写可能更合适点，这么做最大的好处就是迁移adapter技术实现时更方便。这么做我觉得会适得其反，毕竟这种做法需要的设计要求太精细了，对于绝大多数团队来说做框架分离这种事把自己埋了的可能性远大于在将来技术迁移时成本降低的可能性。对于绝大多数团队，只要能做一个api一个api的替换，已经是不错了。要想做到这个，使用一般的开源框架，比如spring mvc或jersey并不难，但是要是使用公司内自己做的就不一定了，很可能它不支持运行时两种adapter同时对外提供服务，直接从根本上把你用其他框架对外提供服务的可能性就给掐死了，这样的内部框架使用前请三思。</p>
<p>不同于ddd里的分层架构，clean arch里面，负责做数据库存储的持久层也是一种adapter。 当我们做了这样的设计后，就可以把框架相关的annotation彻底清除出domain层，于是整个domain就真的变得干净了，配合上ddd里的一些概念解耦后，技术迁移也会变得容易。具体的内容我们后面聊。</p>
<p>usecase则是以前的service，通常是我们应用逻辑的编写处。service这个词不是用以表达一个分层的好词，因为我们做的都是商用软件，一切都是service。在ddd中分为了application service和domain service，通常是说领域相关的属于领域服务，应用场景相关的属于application service。这些描述太抽象了，还都叫service实在是容易混淆，所以我们现在习惯把application service这层都叫成了usecase，usecase比application service好的地方在于，service你会不自觉的用业务实体的名字做前缀，比如UserApplicationService（甚至有的人因为包名上已经有application了为由，干脆就叫UserService），而use case你会不自觉的用业务场景来做前缀，比如RegisterUseCase。这样的话我们就会容易关注到application service的本质：应用层业务场景。当然即便如此，当我们加入新的逻辑的时候依然不能很好的区分放在哪一层比较合适，这点我们稍后再深入聊。</p>
<p>接下来就是domain层了，这个概念最早见于ddd中介绍的分层架构，里面定义domain层是用来表达业务概念，业务状态信息和业务规则的。用极限编程派敏捷中的一个实践：代码即文档 来说，这一层的代码所作为文档指的是业务文档，表达的是业务逻辑而非技术细节。这点对于遗留系统尤为重要，我曾经在几个10年以上的遗留系统上工作过，那陈旧的技术和业务逻辑混在一块的味道可是不好受，那个时候是多么希望业务逻辑和技术细节是解耦的。技术的进步是一个永不停息的过程，据说受摩尔定律影响，每18个月就有一代，所以架构师必须在一开始就谋划技术细节与业务逻辑的解耦。那么作为业务文档，由于业务本身的复杂性，势必要面对上下文的切割，所以这里面使用ddd的战术概念来管理业务模型是最好的。</p>
<p>这就是这三层，这三层的要求是，外层依赖内层，内层不可以依赖外层。所谓依赖，在java中指的是import，如果A类import了B类，那就叫A类依赖了B类，外层依赖内层的意思就是外层的类可以import内层的类，反过来不行。这个本来我是觉得很基础的概念，不过由于工作中看到有人认为哪个包在哪个包下面是依赖，我觉得还是有必要澄清一下。</p>
<h2 id="深入聊聊细节"><a href="#深入聊聊细节" class="headerlink" title="深入聊聊细节"></a>深入聊聊细节</h2><h3 id="PO、聚合与其他domain层概念"><a href="#PO、聚合与其他domain层概念" class="headerlink" title="PO、聚合与其他domain层概念"></a>PO、聚合与其他domain层概念</h3><p>首先说一下实体耦合的问题，当各种标记都标注在实体类上的时候，势必不同上下文是会互相侵入的，也就变成了耦合的状态。虽然有人说可以通过xml的方式避免annotation的侵入，但实际上关键的耦合没有摆脱，你新建实体的时候还要考虑怎么更好的存取，这种耦合其实才是耦合的本质，上下文的耦合使得思考的时候不能专注的在一个上下文中思考，从而使得问题复杂化。类似的例子可以参考marsrover文中没有解耦的direction，虽然没有直接依赖，但是还是要跟command耦合了，跟此处虽然没有annotation但依然跟orm框架耦合是类似情况。</p>
<p>那我们的做法是什么呢，我们抽取出一套专门用于存储的对象我们称之为PO(Persistent Object的缩写)，比如UserPO，这个对象只为存储使用，它的构造器负责把所有领域的实体对象转化为对应的PO，比如把domain的User对象转化为UserPO。</p>
<p>这样domain层的模型，像User这种，就不需要关心持久化的问题，不需要为了数据库表的结构扭曲自己本来应该表达的抽象含义。持久层也不需要各种高难度技术来弥合这其中的各种坑，大家都轻松了。</p>
<p>当持久层和领域层解耦了，我们就可以方便的使用ddd里的种种概念，最核心的便是聚合。</p>
<p>所谓聚合就是一组相关领域模型的集合。这一组领域模型的关系是非常紧密，他们聚合在一起统一响应外部操作。通常会有一个类来对外，这个类叫做聚合根。这一个聚合通常要遵守下面的规则：</p>
<ul>
<li><p>聚合根负责执行业务规则。</p>
</li>
<li><p>聚合根有全局标识。这个标示说的是业务标识。</p>
</li>
<li><p>边界内的类只有局部标识，在聚合内唯一，这个标识也是业务标识。从业务上讲，一个聚合内的类确实对外理由拥有全局标识的必要，至于数据库id，那是为了存储方便，对于业务上没有意义。</p>
</li>
<li><p>聚合边界外的对象只能引用聚合根，不能持有聚合内对象的引用。这点通常比较麻烦，计算过程中用一下的，只要对象本身是immutable的，我觉得还好。但是作为属性确实是绝对不能允许的。</p>
</li>
<li><p>边界内的对象可以持有对其他聚合根的引用。</p>
</li>
<li><p>删除操作必须全部删除边界内的对象。</p>
</li>
<li><p>聚合边界内任一个对象发生改变，整个聚合的所有业务规则都不能违反。</p>
</li>
<li><p>只有聚合根能直接从持久化系统查询得到，边界内对象只能从聚合根导航。</p>
</li>
</ul>
<p>具体长什么样，要看我们的样例代码里的样例。这里只说一件事，从第一条可以看出，ddd当中是比较推崇充血对象而不是贫血对象的，我也推荐我们采用充血对象，但是不推荐把数据访问操作也放到充血对象上，那就不是充血而是涨血了，毕竟ddd里还有个repository（这个我们在下面讲）专门干这个，聚合跟什么的就不要越俎代庖了。</p>
<p>前面用到所有原本习惯叫实体的地方，我们都用了类或对象来代替，为什么这样用呢？主要是因为在DDD里，实体的概念比其他设计方法里的实体概念要小一点，他把传统的实体分为了两类：实体和值对象。（当然我们日常交流时候，建议除非进入模型的细节讨论时，实体和值对象应该做一个区分）</p>
<p>那么实体和值对象分别是什么概念呢？</p>
<p>实体是符合下列条件的类：</p>
<ul>
<li><p>有生命周期</p>
</li>
<li><p>有唯一标识</p>
</li>
<li><p>通过id判断相等性</p>
</li>
<li><p>可变</p>
</li>
</ul>
<p>值对象则符合下列条件的类：</p>
<ul>
<li><p>无唯一标识</p>
</li>
<li><p>通过属性判断是否相等</p>
</li>
<li><p>即时创建，用完就扔</p>
</li>
<li><p>不可变</p>
</li>
</ul>
<p>我们这里说的可变是业务意义上的可变，比如一个用户，你可以修改他的email、username、password，你可以改变他的一切值，但只要id是他，那就还是同一个用户，那这个用户类就是一个实体。再比如一个订单的地址，尽管我们常上网购物，都知道有常用地址，但是用户的地址修改了，订单的地址是不可以跟着变的，那么订单上的地址就是一个值对象。而用户的常用地址则是一个实体，因为它可以改。</p>
<p>当然如果一个实体，你设计上就是让它不可变，例如他有历史，每次修改都是生成了一份新的历史，对于旧的实体来说，貌似没有变化，但是你仔细想想，你总要有一个根实体来连接所有的历史，并指明哪个是最新的，这个连接关系的改变，它也是改变。所以依然属于可变范畴。</p>
<p>围绕着这些核心概念，还有几个概念，分别是repository，factory和domain service。factory就是用来构造各种实体和值对象的类，一旦有了聚合之后，可能构造过程略复杂，就会引入factory，不复杂的通常就用不着。repository负责对聚合进行存储通常都是接口，而实现在持久化层，这便是依赖倒置，倒置之后，实际运行时，实现是由接近main的层次的类在构造依赖repository的类（比如某些service）的时候注入进去的。domain service通常就是调用repository的那个类，负责领域业务逻辑，这块有个小难点，就是怎么识别领域业务逻辑和应用业务逻辑呢？我们后面再聊。</p>
<p>聚合的划分，上下文有些时候容易识别，有些时候难以识别。就说博客的修改和发布与用户评论吧。最简单的做法可能是博客下面有评论，评论里有一个属性是用户。这个时候就有几个业务场景要考虑了。一个用户能看自己发过哪些评论，这个时候和给一个博客发表评论，到底是不是一套模型？另外编辑一个博客和展示一个博客及其评论又是不是一套模型？比起问题的答案，意识到这些问题可能更重要。而问题答案，在不同的时期，答案是不太一样的。固然存在客观的上下文，但是在发展的初期，我们通常会刻意的采用一些失真的方案来便于理解。kent beck提出了一个3X模型，按照一个软件的发展分成了3个阶段：Explorer、Expend、Extract，不同的阶段要采取不同的架构设计和开发方法。</p>
<p>一旦一开始比如在explorer阶段就采用不同上下文不同模型的做法，很容易让初学者疑惑，再加上大多数团队的沟通和能力建设都跟不上，反而写出一大堆奇怪的代码。但是如果团队能力比较强，或者我们的沟通和能力建设跟得上，从一开始就采用不同上下文不同模型的做法，其实对于我们平滑过渡到expend阶段是非常有帮助的，尤其是在稍微上点规模的公司，这种过度的速度可能非常快。</p>
<p>一旦两层解耦，那编写聚合的时候就可以不受数据库的限制。从domain层角度讲，一旦做到了这一步，持久层用关系型数据库还是nosql对domain层其实无感知了。可以很容易的做到聚合内数据必须通过聚合根操作，而不用额外操心乱七八糟其他上下文的约束。首先一个就是可以干掉setter，既然PO有专门的模型了，你就不需要为了update之类操作的建立起setter，一切修改权限都只暴露给聚合根，聚合根就可以接管一切业务操作。然后所有的getter都可以是返回一个immutable的对象，因为无法被修改，自然就保持了很好的封装性。最后是引入了上下文和聚合的概念后，可以很容易的消除掉循环依赖（所谓循环依赖就是A类依赖B类，B类又依赖A类，不管是直接的循环依赖，还是间接的循环依赖，比如A依赖B，B依赖C，C依赖A，都属于循环依赖）。</p>
<p>而从技术的角度，技术迁移的时候也可以一个聚合一个聚合的迁移。这里面后者尤为重要，我的经验就是，如果不能把一个大的变化分解为小步，一点点变，这个变化通常不会发生，或者积累到很晚的时候以很大的成本来换取这个变化。不仅仅是变化需要，优化也需要，既然聚合已经自然隔离了业务的边界，那么优化时确定影响的边界就变得容易了，同时优化本身也是一种变化，可以看作从一种技术方案迁移到另一种方案，这种迁移过程中边界的清晰也对于我们验证迁移前后是否逻辑等价有很大帮助。哪怕是日常开发，聚合的存在使得技术的实现也简化了，由于聚合之间通常是业务隔离的，不用存储时还要操心业务上的影响。只要做好技术角度的事务性自然可以保障业务上的事务性。</p>
<h3 id="聊聊service"><a href="#聊聊service" class="headerlink" title="聊聊service"></a>聊聊service</h3><p>ddd中把服务分了三层，应用层的，领域层的和基础设施层的。</p>
<p>从这点来看，由于把基础设施层的服务通常是比较清晰的，而且访问数据库的通常不以服务为名，访问其他服务的桩倒是经常以服务为名，不过依然是容易区分的，所以这点上讲问题不大。最麻烦的就是前面讲过的，领域服务和application service的差别不好区分，当然首先是都叫service不是个好事，我们在整洁架构里都叫usecase了，这个问题算是解了。然而那些逻辑应该在usecase里，哪些应该在domain service这个缺乏一个足够清晰的指导原则。而且这里面还有一个聚合根，不是说聚合根也应该有一些业务逻辑嘛，这就更乱了。</p>
<p>目前来讲，我们从实践角度得出了一个被我们称之为两个凡是的指导原则：</p>
<ul>
<li><p>凡是能移到聚合根的代码都不应该出现在domain service上</p>
</li>
<li><p>凡是能够移动到domain service的代码都不应该use case中出现</p>
</li>
</ul>
<p>这几个凡是要成立是建立在一些约束之上的，这些约束是：</p>
<ul>
<li><p>绝不能把跨上下文的逻辑放到domain service里</p>
</li>
<li><p>绝不能把表现层逻辑放到use case里</p>
</li>
<li><p>绝不能把repository放到聚合里</p>
</li>
</ul>
<p>这里面约束都是比较极端的，你看我们用了绝不这样的词汇，这是因为我们在实践中发现，模棱两可的说法、模糊的边界只会造成工作中的混乱，绝大多数人不具备判断的能力，所以我们采用了极端的描述方式，这样当普通开发觉得无法实现的时候，就会自然的上升到技术负责人或架构师来决断，绝 大部分情况下，只是想错了，所以觉得无法实现，这个就是能力建设的契机。不需要专门的设立什么定期分享，只要靠这些东西就可以很自然的做到能力建设。</p>
<p>前面提到过访问外部服务的桩服务，我在实践过程中也发现这个接口应该放在哪里是个问题。经过我们内部的一些交流，我觉得放在use case层是比较合理的。首先讲，桩服务也是一种adapter，是被use case调用的，那么adapter不应该依赖use case，所以接口应该放在use case。不过我们中也有人认为，随着业务的复杂化，你有可能有些访问来的数据是要被映射为本领域上下文里的一组值对象，然后再参与计算的，这个时候放在use case就不合适了，有一部分接口就要下移到domain层。这点我个人觉得也可以按照我之前的策略处理，先放在use case层，然后用两个凡是的原则考问一下自己，是否要下移到domain去，然后再走use case层和domain层服务切分的那个逻辑就好了，所以并不矛盾。</p>
<h3 id="接口处"><a href="#接口处" class="headerlink" title="接口处"></a>接口处</h3><p>接下来我们聊聊隔层之间的接口处，通常接口处都是问题的高发区。</p>
<p>首先说说adapter层和外面这层接口，我看过一些人，在adapter层使用map，只是为了不多写一个类。这种行为是有些糟糕的，我们今天所知道的整洁架构就是最完美的形态吗？不一定，我们过去采用的三层架构本身已经被证明有些问题了，未来也会有新的架构，所以内部结构的调整（也就是所谓的重构）是一个永恒的课题，不得不面对。当你用Map来进行adapter层的数据组合的时候，当时写的是方便了，但是事后重构可费了劲了。因为Map可以随便传来传去，你不知道中间哪里就改了，识别最终的API的长相比较困难，文档本身经常又与实际不符，你实在是不敢做完之后就相信没有问题。</p>
<p>而我们推荐做法是在Adapter层为输入和输出专门建模。输入搞一个类，输出搞一个类，从这两个类里就可以看出你API的数据的结构，那么就可以直接从模型类中搞明白API中数据的结构。这件事很多人嫌麻烦，然而既然代码即文档，文档你都不嫌麻烦，为什么代码嫌麻烦呢？就像前面所说，写的时候觉得技术迁移是未来的事一样，觉得架构调整也是未来的事情，几年之后就是天天都要干的事情，在早期稍微加入一些限制，就能为未来赢得一点转机，望三思。</p>
<p>然后我们看看Domain层与外围，通常来讲use case层直接使用domain层的模型对象，这样use case层会比较轻量。然后Adapter层的模型对象，自然可以依赖Domain 层的模型对象，然后通过构造函数来进行初始化。这样可能会带来一些坏味道，比如长参数列表。但是我们觉得这个坏味道是可以接受的，因为它提供了一个很好的检验机制，当你有一个参数没有传进去的时候，会报错，避免了产生构造时遗漏输入问题。但是有时候数据结构复杂了这种做法也会造成很多人会为了一点方便写出破坏封装的情况，我们前面说了当复杂的时候会引入Factory，但有时候引入Factory问题的本质没有解决，这种情况下为了隔离 可能还会引入专门的TO（transfer object ），放在domain层，外层和内层都依赖内层TO，这样就会更好的保护内层的封装性，同时还有些额外的收获，比如说隔离之后，内层结构就敢更灵活的调整，不会不敢随便调整结构只是因为外层依赖着自己。相应的缺点则是成本升高了，这里面的平衡就要大家自己把握了。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>仝键
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jtong.dev/2020/01/22/programmer-dojo/ddd-clean-arch/" title="在DDD中采用Clean Arch的经验分享">https://jtong.dev/2020/01/22/programmer-dojo/ddd-clean-arch/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/13/programmer-dojo/marsrover-tdd/" rel="prev" title="练功房MarsRover讲解（初稿）">
      <i class="fa fa-chevron-left"></i> 练功房MarsRover讲解（初稿）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/29/deliberate-practice-for-digital-talent/what-worth-to-be-learn/" rel="next" title="什么值得学">
      什么值得学 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#传统的三层架构"><span class="nav-number">1.</span> <span class="nav-text">传统的三层架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">1.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新的架构"><span class="nav-number">2.</span> <span class="nav-text">新的架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入聊聊细节"><span class="nav-number">3.</span> <span class="nav-text">深入聊聊细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PO、聚合与其他domain层概念"><span class="nav-number">3.1.</span> <span class="nav-text">PO、聚合与其他domain层概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聊聊service"><span class="nav-number">3.2.</span> <span class="nav-text">聊聊service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口处"><span class="nav-number">3.3.</span> <span class="nav-text">接口处</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">仝键</p>
  <div class="site-description" itemprop="description">写写心得，写写教程，希望能帮助更多人成为优秀的软件开发人员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">仝键</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
