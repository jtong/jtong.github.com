
这次我们来看看设计方面，大语言模型能帮我们做什么。

我以前带团队的时候，最怕的不是重复代码，而是代码出现结构上的设计问题。结构上的设计问题一旦出现，如同跗骨之蛆，难以去除并滋生严重的腐化，甚至扭曲很多人的思维模型。让很多人以为这样的结构才是合理的或者有什么我们不知道的理由这么设计的。而一代代开发者维护下去，偶尔有些人意识到了这种东西的不合理性，但是看看那庞大的代码库，考虑到自己只是个打工人，投入产出比并不合理，也只能听之任之了。

有次咨询的时候，有个团队的技术负责人跟我说起自己以前的经历，说打开一个页面，里面竟然有28个if-else。他说，我也有技术追求，我也想把代码写好，但是看了看手上的工作量，再估计了一下修改这套结构的时间成本，他只好昧着良心写下了第29个if-else。而他离职一段时间之后，他跟前同事聊天，那个已经变成35个if-else了。if-else都这么难改，更复杂的结构性设计问题，就更没人敢动了。

那么什么是结构性的设计问题呢？

所谓结构性的设计问题，其实通常并不复杂，并不是出现了一些诡异的，不能理解的结构。往往都是错误使用了一些数据结构或设计模式。把不该应用到当前结构的结构应用到了当前结构，哪些结构或模式本来在他们的场景下是很好的东西，但是放错地方就变成了癌。

接下来我们通过两个例子来说明。


## 错误的数据结构
举个简单的例子，我原来带过一个新人，我让他写一个简单的题目：
```markdown
## 需求

商店里进行购物结算时会使用收银机（POS）系统，这台收银机会在结算时根据客户的购物车（Cart）中的商品（Item）进行结算和打印收据（Receipt）。

输入（样例）：

[
'ITEM000001',
'ITEM000001',
'ITEM000001',
'ITEM000001',
'ITEM000001',
'ITEM000003-2',
'ITEM000005',
'ITEM000005',
'ITEM000005'
]

其中对'ITEM000003-2'来说，"-"之前的是标准的条形码，"-"之后的是数量，数量会有为小数的可能性。 当我们购买需要称量的物品的时候，会由称量的机器生成此类标签（Tag），收银机负责识别生成收据。

为了打印清单，我们需要提供数据给打印系统,让打印系统可以打印出如下消息：

***<没钱赚商店>收据***

名称：可口可乐，数量：3瓶，单价：3.00(元)，小计：9.00(元)
名称：羽毛球，数量：5瓶，单价：1.00(元)，小计：5.00(元)
名称：苹果 0.5kg，数量：2斤，单价：5.50(元)，小计：11.00(元)
----------------------
总计：25.00(元)
**********************

该商店正在对部分商品进行“买二赠一”的优惠活动。店员可以设置哪些条码对应的商品可以享受此优惠活动。

当购买的商品中，有符合“买二赠一”优惠条件的商品时，会把小计中减去赠品的价格：

***<没钱赚商店>购物清单***

名称：可口可乐，数量：3瓶，单价：3.00(元)，小计：6.00(元)
名称：羽毛球，数量：5个，单价：1.00(元)，小计：4.00(元)
名称：苹果 0.5kg，数量：2斤，单价：5.50(元)，小计：11.00(元)
----------------------
买二赠一免费商品：

名称：可口可乐，数量：1瓶，价值：3.00(元)
名称：羽毛球，数量：1个，价值：1.00(元)
----------------------
总计：21.00(元)
节省：4.00(元)
**********************
```

我期望他给我设计的用于输出的数据结构是这样的：

```json
{
    orderItems:[
        {
            name: "apple",
            price: 2.00,
            count: 2,
            subTotal: 4.00
        },
        {
            name: "banana",
            price: 3.00,
            count: 4,
            subTotal: 12.00
        }
    ],
    salesPromotions: [
        {
            name:"3_for_1_gift",
            count: 1,
            saved: 3.00
        }
    ],
    total:{
        saved: 3.00,
        finalDealTotal: 13.00,
    }
}
```
结果他给我的设计的是这样的：

```json

[
    [
        [{
            name: "apple",
            price: 2.00,
            count: 2,
            subTotal: 4.00
        },
        {
            name: "banana",
            price: 3.00,
            count: 4,
            subTotal: 12.00
        }
        ],
        [
            [
                {
                    name: "3_for_1_gift",
                    count: 1,
                    saved: 3.00
                }
            ],
            [[{
                    saved: 3.00,
                },
                {
                    finalDealTotal: 13.00,
                }]
            ]
        ]
    ]
]
```

看不太明白是吧，我给你可视化一下：
![receipt-data-structure](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-01-receipt-data-structure.png)
是不是明白点了，像不像套接字报文？是的，就是这么生搬硬套，就连我让他们当场写个Java的类也是一样的结构：

![receipt-data-structure-uml](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-02-receipt-data-structure-uml.png)


如果只是一个人这样，我也就不在这拿出来说了了，问题是不止一个人会出现这种问题。通讯专业毕业的毕业生多见这种错误，可能是没搞明白建模不止一种模式，就硬套了自己习惯的模式。这种是比较明显的错误数据结构套用，而这种错误套用其实在错误的结构性设计里很常见，有时候是过度设计造成的，有时候是设计过时了造成的。

## 糟糕的结构性概念命名

有时候，这些错误的发生仅仅是我们混淆了一些概念，我们说过，写代码最重要的是命名，但其实命名这个事产生的后果可大可小，如果一个糟糕的命名出现在结构性相关的概念上，那后果可就大了。
比如，我们有这个练习：

```markdown
假想你在火星探索团队中负责软件开发。现在你要给登陆火星的探索小车模拟器编写控制程序，根据地球发送的控制指令来控制火星车的行动。
## 需求1
火星车收到的指令分为三类：
初始化信息：火星车的降落地点（x, y）和朝向（N, S, E, W）信息(2 1 E)；
移动指令：火星车可以前进（M）,一次移动一格；
转向指令：火星车可以左转90度（L）或右转90度（R）。
由于地球和火星之间的距离很远，指令必须批量发送，火星车执行完整批指令之后
(2 1 E MLLR)，
再回报自己所在的位置坐标和朝向 (3 1 N)。

## 需求2    
新加一个指令，如果接收到F指令，车进入极速状态，M会前进两格，L会前进一格然后左拐，R会前进一格然后右拐。
再接收一次F指令，对应的状态会消失
```

这个火星车需求，我会明确告知未来还会加入更多命令，那么我们期望的设计是：

![expect-name-for-sturecture](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-03-expect-name-for-sturecture.png)

而我经常拿到的一种典型的错误设计是：

![wrong-name-for-sturecture](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-04-wrong-name-for-sturecture.png)

后者为什么有问题呢，因为命令是有业务含义的领域词汇，从题目上来讲。我们的命令就只有：M、L、R、F，再加一个初始化命令。只不过有些命令是改变状态的，有些命令是执行行为的，这个很明显概念出现了歧义，Command不只是需求里提到的命令了，还有其他问题我们后面讲。

而这次出错的可不只是毕业生了，问他们这么设计的原因，发现很多人会把命令模式的命令和业务里的命令混淆了，其实这个里面这么搞也不能算是命令模式，如果你非要搞的话，而且命令模式为什么要在类名里出现命令这个单词呢？为什么不能发明一个新概念比如叫Action呢？我们前面说了，当事物第一次出现的时候，给他起个名字，是人的职责，不是大语言模型的职责。但我的经验是，很多人在这个方面真的太随便了。完全没过脑子就起了名字。

有的人说是这样可以减少if-else，减少结构性重复。其实在今天这个时代，重复不重复的代码，关键看这个重复代码是不是你维护。如果是大语言模型维护，那就不太重要。而即便是在之前，当上下文的概念清晰和代码的重复要做取舍的时候，通常我们也会选择前者，毕竟代码首先要读懂才能谈得上维护，概念清晰的收益是很大的。但以前真的很难唠这个嗑，总有人跟你说可读性是主观的，你觉得好读，别人未必觉得，我觉得我这挺好读的，你那个我还不好懂呢。今天我们终于有了客观的标准：大语言模型能不能读懂。你混淆命令模式的命令和业务领域里的命令，那就放大了大语言模型可能会生成出错的概率，那你这个设计就不太行。

其实道理没变过，原来人维护代码的时候，也是一样的，前几年DDD讲的概念完整性、消除歧义在讲啥呢？还不是就在讲这些简单的事情。不过吧，**人的一个毛病是大多数人都认为自己是少数人**，能把握得住，你说了也不听，说服教育很困难。但是在大语言模型时代，你跟大语言模型玩这套，反手就教你做人，你对概念完整性玩忽职守，大语言模型就对你玩忽职守。（当然人仍然可以说这是大语言模型比较差。就是不改自己的恶习，要是这样那可要小心了，习惯好的人，可慢慢就会把习惯不好的人干掉了。毕竟武功再高，也怕一枪撂倒）


## 让大语言模型帮我们识别设计的问题

那么大语言模型能帮我们做什么？其实我们可以让大语言模型来识别设计的问题，我们就用上面两个例子来讲解。

首先是“错误的数据结构”里Receipt类的设计，假设我们还是用UML来表达类，那么我们可以这么说：

![receipt-model-for-POS-cutoff](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-05-receipt-model-for-POS-cutoff.png)

可以看到这里有个小点：其实设计图也是可以给大语言模型的，用plantuml就好了。而更重要的是，这里面我采取了一个很重要的prompt设计，我给他安排了一个身份。为什么要安排一个身份呢？因为设计确实是没有标准答案的，是有主观性的，好坏有些时候是需要一定的三观的偏好的作为基础的，也就是所谓的偏见。我们前面说出现了客观标准也只是选择了大语言模型能理解这一个维度，如果把大语言模型看做一个人，这也是一种主观。但众所周知，大语言模型是很喜欢顺着你说的，喜欢说的四平八稳，而此刻我偏偏就需要他的偏见，所以我捏了一个身份给他。

虽然这个身份不算怎么精心设计，但也起到了作用，我们可以看到输出如下：

![receipt-model-for-POS-answer](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-06-receipt-model-for-POS-answer.png)

看得出，他能帮我们识别问题。然后我们再试试“糟糕的结构性概念命名”那个。

![marsrover-modeling-1-cutoff](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-07-marsrover-modeling-1-cutoff.png)

他也指出了我们的问题，但是呢，在这种稍微复杂的问题上，他出错的概率也多了，可以看出有很多问题。那如果我们换成GPT4会好很多:

![marsrover-modeling-1-gpt4-cutoff](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-08-marsrover-modeling-1-gpt4-cutoff.png)

那么这种问题其实我们可能是不服气的，我们可以揪住其中之前3.5给我们的反馈中的点跟他进行讨论：

![marsrover-modeling-2-cutoff](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-09-marsrover-modeling-2-cutoff.png)

可以看出他给了一些更详尽的意见，他说消除重复？那我就更不服了，我们还可以继续问：

![marsrover-modeling-3-cutoff-wrong](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-10-marsrover-modeling-3-cutoff-wrong.png)

果然被我的胡搅蛮缠给搞服了，这就是我说的，他没有身份，立场就太不坚定了，稍微一问就怂了。虽然前面给了他一个身份，但是问了这么多问后，明显他忘记了。那么这个时候，我们可以继续强化一遍他的身份，这也是一种常用的技巧：

![marsrover-modeling-3-cutoff-right](https://jtong-pic.obs.cn-north-4.myhuaweicloud.com/chatgpt-coding-show/09-chatgpt-coding-show-s2/03-design-issue/S203-11-marsrover-modeling-3-cutoff-right.png)

如何？这几乎就是我在讲课的时候会使用的讲解角度了（对自己的工作又多了一份担心:P）。注意，除了强调身份，这种主观性的问题，让他给出多维度的反馈和思考这种说法是很有必要的，你不这么写他可能就不敢说话，给了他身份他也不肯说你错了。

## 总结

下面又到了AI总结时间，下面是AI的总结：

### Claude 版

1. 结构性设计问题是软件系统中最难解决和避免的问题,它们往往由错误的数据结构或糟糕的概念命名引起。
2. 我们通过两个例子展示了错误的数据结构和糟糕的概念命名导致的结构性设计问题。前者是硬套了一个通信协议的结构,后者是命令模式的命令和业务命令混淆导致的。
3. 我们可以利用大语言模型来识别这些结构性设计问题。但因为大语言模型本身也有主观性,我们需要给它一个合适的身份和角度来表达问题,并要求它给出多维度的反馈。
4. 即便如此,大语言模型的判断也难免会出现错误,这时我们需要跟它进行讨论,不断地提出自己的疑问和论点,直到它表达出我们认可的观点。这需要我们对领域和设计有较深入的理解,才能跟大语言模型进行有效的交流。
5. 总的来说,大语言模型可以作为我们设计评审和检验的工具,但并不代表它能替代人来进行设计。设计本身还是需要理解业务和技术,并进行主观判断的活动。大语言模型只是辅助我们发现问题和讨论设计的一种手段。
所以,对设计来说,大语言模型最大的作用是:检验设计,发现潜在的问题,促进设计讨论和理解。但设计本身还需要依靠人的主观判断。大语言模型只是一个辅助工具和手段。

### GPT-4 版

在使用大语言模型时，我们应该注意以下几点：

1. **明确模型的角色**: 给大语言模型设定一个明确的身份或角色可以帮助我们获得更具针对性和深入的反馈。这种身份可以使模型更加偏向于采取一种特定的观点或分析角度。
2. **多维度反馈**: 在处理主观性较强的问题时，要求模型提供多维度的反馈和思考是很有价值的。这可以帮助我们了解不同的角度和可能性，而不仅仅是一个平淡无奇的答案。
3. **灵活交流**: 通过与模型进行深入的对话和讨论，我们可以挖掘出更多的信息。在对模型的反馈有疑问或不满时，我们可以继续提问，以获得更多的解释和建议。
4. **保持警惕**: 虽然大语言模型可以提供很多有价值的见解，但我们也要意识到它们并不是万能的。在某些复杂或高度主观的设计问题上，人类的判断和经验可能仍然是不可或缺的。
5. **结合实际情况**: 在考虑模型的建议时，我们应该结合实际项目的背景和需求。某些建议可能在理论上看起来很好，但在实际应用中可能并不可行。


3.5就算了，实在拿不出手：P。之所以放两个也是给大家看看Claude的能力，其实我个人使用下来，Claude的逻辑能力确实是不太行，但是他在写作方面还是挺厉害的，写作类的需求可以考虑它。