---
title: 像机器一样思考（二）—— 数据的细节
---

与很多人想的不同，同理心是一件强大的控制工具，你有多理解你要控制的对象，你就多容易控制它。所以我们学习像机器一样思考并不是为了变成机器，而是为了更好的控制机器为我们服务。从这一篇开始，我们进一步讲解这种思考模型的细节。

随着对细节的深入，我们会发现，我们会越来越看不清楚机器的思维和人的思维的疆界。仿佛这之间的区别是很小的，有时候你不知道是因为人这么思考所以这么设计的机器，还是机器这么思考所以我们需要迁就它。

同时，可能你会感到一些些麻烦和思维上的束缚，但总之请记住，一切不得不接受的束缚，都是为了更大的自由。Rails之父DHH曾经说过：

>约束是你的朋友。

这很反直觉，然而随着你编程的经验增多，你会体会到这句话是多么的正确。

## 类型

编程语言分为静态类型（比如Java，C#，Scala）和动态类型（比如JavaScript，Ruby，Python）两种。但不管是静态类型还是动态类型，你不可否认类型总是在那里的，哪怕你不显式的表达出来，也绕不开它的存在，你思考的时候必须思考它。

在[上一篇][1]里，我们有一个例子用到了类型：

```
加法函数
输入： 
  a: Number
  b: Number
输出:
  result: Number 
```
在这一个例子里，我们用到了一种类型：Number。表明我们的参数只能是数字。假如在强类型的语言里，如果我们传进去的参数类型不是数字，就会报错。假如在弱类型的语言里，我们传进去的参数类型不是数字倒是不会报错，但是如果我们使用```>```或```-```之类的运算符对其进行运算的时候，可能就会报错。所以强弱类型的语言无非是出错的时机不同，为了保证我们程序的正确性，不管你用哪种，都摆脱不了要思考数据的类型问题。

仅仅是一个个体数据的时候，考虑类型还是容易考虑的。当我们有一组数据的时候呢？比如上一篇里我们还有这样一个例子：

```
#1 选出集合中的偶数
输入： 
  inputArray: [Number] 
输出：
  evenArray: [Number]
...
```

在这个例子里，inputArray的类型到底是什么呢？是```数字```呢？还是```数组```呢？还是```只有数字的数组```呢？泛泛的说，inputArray的类型是```数组```，而精确地讲，inputArray的类型是```只有数字的数组```。为什么需要精确的指定，只有数字呢？这其实是从实用角度出发，如果我们一个数组里面放各式各样类型的数据，我们就会越来越想不清楚而头脑陷入混乱，在写代码的时候也是每当用到一种类型的数据就要加一个if，就容易漏掉一些情况而引入bug。所以为了我们自己好，还是一个数组里只放一种数据类型吧。

在一些强类型语言（比如Java）里，为了保证这一点，他们还使用了所谓的泛型。有一种常用的情况就是跟我们这个情况类似，大概长成这样：```List<Integer>```。我们就会了解，当涉及到集合的时候，为了防止滥用，人们不惜动用语法。


以上就是我们上一篇用到的类型相关的知识，在这一篇里，我们会走的更深入。

## 结构

在上一篇里，我们的类型还是一个黑盒，在这一篇里，我们要引入结构。每一种语言都有一些基本类型，但是用来描述这个世界的数据，基本结构是不够的。所以每个语言又都提供了一种方法，让我们可以以基本数据类型为“积木”，通过结构化的方式来自定义类型。在大多数语言里，我们使用类来做这件事，但是不管你用什么，最后表达的信息都是类似的。

举例来说，当我们想要表达一个数字的类型时，我们用Number，我们想表达一个字符串的类型时，我们用String。那当我们想表达一个人，这个人有一个姓名属性是String类型的，有一个年龄属性是Number类型的时候。我们需要创造出一个这样的类型，我们就可以这样写：

```
{
  name: String,
  age: Number
}
```
在这里，我就用到了一种结构来表达了人的类型，大家可以看到我用的方式是借鉴了[JSON][2]的表达方式，只是把本应该写值的部分换成了类型。这是一种便于在纸上书写的表达方式，我们在日常工作中进行沟通的时候，随手拿过一张纸，很容易写清楚我想表达的结构。

而最重要的是，它可以简单的表达出很深层的结构，比如我们想要定义一个人这个人有一个孩子，孩子当然也是一个人，也有相同的属性，那我们可以这么写：

```
{
  name: String,
  age: Number,
  child: {
    name: String,
    age: Number
  }
}
```

当然我们可能会说了，万一不止一个孩子呢？好，这就引入了自定义类型中的数组怎么表达的问题。其实可能大家已经发现了，自定义类型它也是一种类型，它存在的位置就是原来写String，Number的地方，那么问题的答案就很符合直觉了：

```
{
  name: String,
  age: Number,
  children: [{
    name: String,
    age: Number
  }]
}
```

看起来跟```[Number]```很像吧？那么对应一个具体的Javascript对象，代码是怎么写的呢？

```
let zhangsan = {
  name: "张三",
  age: 38,
  children: [{
    name: "李四",
    age: 10
  },{
    name: "王五",
    age: 5
  }]
}
```

前文的结构，描述的就是这个代码里的对象的结构。前文的结构是为了限制我们的数据定义，然而有了这个限制，我们就可以思考更复杂的问题。

## 练习

废话不多说，我们还是老规矩，做个练习看看怎么用。

打印某人的成绩单。已知输入的格式是
> ["姓名", "语文成绩", "英语成绩", "数学成绩", "编程成绩"]
> 比如： ["张三",  "95", "80", "75", "80"]

要求打印出成绩单：

```
成绩单
姓名：张三
===============
数学：75
语文：95
英语：80
编程：80
***************
平均分：82.5
总分：330
===============
```

如果对这个题目进行任务划分，我会分成两步：

```
#1 转换为ViewModel
输入： 
  scoresArray: [String] 
输出：
  scoreSheet: {
    name: String,
    chinese: String,
    english: String,
    math: String,
    programming: String,
    average: String,
    summary: String
  }
  
#2 打印成绩单
输入：
    scoreSheet
输出：    
    result: String
```

这两步我干了什么呢：

第一步，我把字符串数组转换为了一个具体的对象类型，它有六个属性，分别对应着我们要打印的成绩单上的六个数据：语文，英语，数学，编程，平均分和总分。
第二步，我把对象转成了一个字符串，打印了出来。

你可能会很奇怪了，打印没有返回值啊？为什么写在输出里？好问题，且听我下回分解～


## 照例，题外话环节。

题外话1: 为什么我们不直接用数组就拼这个字符串呢？一方面，我是在演示结构的使用，另一方面，这是一个小技巧，我们最后打印的这一部分字符串的部分，被称之为表现层（就是表现在人眼前的那一部分），在表现层你最后使用的数据的结构，尽量跟你的表现层的结构一致，这样出bug的几率最低。

题外话2: 这是在js里，如果我们采用强类型语言，这些结构该怎么定义呢？其实很简单嘛，比如那个人的类型结构：

```
Person {
  name: String,
  age: Number,
  children: [Person]
}
```

done。

题外话3： 那我们用[类图][3]可不可以呢？当然也可以，只是要画框子很容易在写属性的时候发现画小了，而且当你画更深层关系的时候就比较麻烦。

//TODO: 这里需要写几个对照例子


## 课后作业

打印所有人的成绩单。已知输入的格式是
> [
["姓名", "语文成绩", "英语成绩", "数学成绩", "编程成绩"],
...
]

比如： 
> ［
["张三",  "95", "80", "75", "80"],
["李四",  "80", "70", "85", "90"]
]

要求打印出成绩单：

```
成绩单
姓名|数学|语文|英语|编程|平均分|总分 
========================
张三|75|95|80|80|82.5|330
李四|85|80|70|90|81.25|325
========================
全班总平均分：xxx
全班总分中位数：xxx
```

请列出本题的任务

  [1]: https://www.jianshu.com/p/c86329151cba
  [2]: http://www.json.org/
  [3]: http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/