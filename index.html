<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/user-centered-software-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/user-centered-software-development/" class="post-title-link" itemprop="url">以用户为中心的软件开发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天这个时代迭代开发已经成为常识，甚至政治正确，随便谁就能给你扯两句mvp。敏捷也从一个开发的名词变成了管理名词，迭代、测试、反馈这类名词满天飞。</p>
<p>人人都在说这些术语，仿佛他们真的就懂怎么做软件了。起码，觉得自己真的懂怎么创新了。然而经不起细聊，一旦深入下去聊一个mvp，聊聊他的迭代计划。就会发现露馅了，张嘴闭嘴谈的都是功能。这个迭代要交付几个功能，这个mvp多了什么功能？他的竞争对手都有哪些功能？却很少听到用户。人人都在喊，以用户为中心。口号喊得震天响，但你看他们的行为模式，他们的语言中，并没有用户的身影，更像只是在否定别人、固执己见的时候拿这个来当借口。</p>
<p>我时常觉得这个事情不太对劲。但是也没有想到更好的方法。敏捷中使用的故事卡比功能的视角要好一点。因为在故事卡里，你要写下用户的价值。但是，我一直也不知道这个价值是从哪儿来的。是先开枪后画靶子我们想做某个功能了，所以硬安的一些价值，还是真的存在的？价值的单位应该是什么呢？没有单位的东西就无法管理。无法管理，也就无法优化。我们交付的价值是越来越多吗？还是交付的不如以前了？用什么来判断？</p>
<p>回答不了这些问题，不管输赢都是有点不明不白的。这些问题的核心问题就是价值的单位应该是什么？怎么算一个价值？一直没想清楚这些问题，直到我看了我们公司设计团队的一个框架MERLIN，又在《创新的窘境》作者的新书《与运气竞争》里看到了理论依据，这个问题在我这里才算是告一段落。我明白了，以用户为中心的软件开发大概应该怎么做。</p>
<h2 id="方法核心"><a href="#方法核心" class="headerlink" title="方法核心"></a>方法核心</h2><p>如果我们想以用户为中心进行软件开发。那么我们的分析方法应该是围绕着用户展开的。</p>
<p>这个方向倒是不新鲜，一直以来我们在inception的时候做用需求分析时我们的方法就是围绕着用户展开的，一个典型的分析过程，如下图所示。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-01.jpg" alt="用户旅途"></p>
<p>我们会在上面画一条轴，标示出用户旅途。这是用户在使用软件的时候的，他的一个全过程。然后在对应的时间点上，标记出我们的功能。这样我们的功能就不是平白出来的。每一个都联系了用户价值。相对于一般人会更容易理解功能，在ThoughtWorks，我们更多标记的是用户故事。比起功能，用户故事增加了有关价值的线索，因为用户故事首先就是要写出价值。</p>
<p>一直以来我觉得这个图还是不够给力。首先，从用户旅途上的点，到功能的映射这一步，简直是个magic move。对未来的读者来说，并不能很好的传递为什么是这样的一个功能，而不是别的功能？毕竟实现一个用户的价值方法有很多。于是后续在执行的过程当中，难免会僵化行事。</p>
<p>其次，上面的旅途，还可以再抽象和封装。简言之，旅途本身也应该是有抽象层次的。一个旅途上的一个点，可能也是一段新的旅途。</p>
<p>所以现在我觉得，一个更系统的做法应该是这样的，首先做服务设计：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-02.jpg" alt="更宏观的用户旅途"></p>
<p>系统化的分析用户的行为，过程中与企业有哪些触点，在这些触点上，借用《与运气竞争》里的思维框架来讲，用户“雇佣”企业的产品到底是来做什么的，也就是动机有哪些。</p>
<p>然后将这些点再进一步细化，采用故事的模式：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-03.jpg" alt="故事板"></p>
<p>图上的一行会讲一个故事，就像电影分镜或者漫画一样，来表达用户使用的故事，真正的故事，而不是用户故事那种东西，我们叫这个东西故事板。<br>在故事板上，我们描绘了一个故事，这个故事里，用户获得了一种体验。一个故事对应一个体验。在基本需求都已经得到满足的今天，体验是新的最有价值的事情，以体验为中心才是以用户为中心。故事板恰好给了我们一个非常符合人类认知习惯的方式来描述什么是一个体验。也就回答了开头的问题，什么是价值的单位。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-04.jpg" alt="故事板与用户故事的关系"></p>
<p>当我们定义出了价值的单位，就可以从这一单位的价值里面映射出故事卡，来进行开发过程的管理：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-05.jpg" alt="故事板是MVP的细分"></p>
<p>这里就是我们的重点，我们将来交付的软件、交付的服务、我们交付的一个MVP本质上是交付给了用户一组体验。MVP的迭代则应该是更多的体验或某些旧体验的升级（也就是同一个动机，换了一个不同的故事来满足）。</p>
<p>最终我们把用户的价值很好的表达了出来，并且找到了用户体验的基本单位——故事板，由于故事板也可以转化为用户故事，结合早已经存在的各种敏捷开发方法，也就可以对体验的交付进行度量和管理，达到以用户为中心进行软件开发。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>很早之前我就觉得MVP是TDD思想在产品策略上的延伸，TDD一个很重要的价值就是避免自嗨从而消除浪费。程序员有时候会因为自嗨写出来好多用不到的功能和设计，这些都是浪费。但是程序员能减少的浪费很有限，最终的最终还是要从需求的源头——用户层面来减少浪费才能真的做好。所谓顾客就是上帝，软件开发中用户就是上帝，这句话的意思不是说用户说什么你就做什么，而是说你只有贴近用户，才能得到上帝的启示，现场有神明，就是这么个道理。</p>
<p>有了MVP之后，就像开发有了测试驱动。我们就可以避免很多过度设计。但是MVP作为测试，粒度太大了，不好分析，不好写断言，不能得到精细的反馈。这里我们把它分解到故事板层面，就可以得到精确的测试目标，也就可以做真正精细的测试，真正做到以用户为中心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/bad-smell-of-visualize-arch-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/bad-smell-of-visualize-arch-design/" class="post-title-link" itemprop="url">架构可视化的坏味道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="抽象的坏味道"><a href="#抽象的坏味道" class="headerlink" title="抽象的坏味道"></a>抽象的坏味道</h2><p><a href="https://jtong.github.io/2020/01/30/something-about-software-development/visualize-arch-design-introduce-c4/" target="_blank" rel="noopener">上文</a>说过，C4说穿了就是几个东西：关系-线、元素-方块和角色（角色不过是图形不同的方块）、关系表述-线上的文字、元素的描述-方块里的文字，虚线框（如前文所说，在C4里面虚线框的表达力被极大的限制了。）</p>
<p>这些东西一点都不新，我们自己随便找个白板，无非也是用这几个东西来表达架构，它的优点在于引进了一些分层，使得我们思路不是特别混乱，容易给别人看懂我们的思路，也容易帮助自己整理思路。</p>
<p>所以C4不能帮你做好架构设计，但是它能让你的设计中的问题暴露出来。被自己或其他人纠正。</p>
<p>可视化的威力就在这里，但根据我的经验，即便你用上了C4也不见得就能表达清楚，不过好消息是，终于我们可以聊一些高级的表达问题了。</p>
<p>可视化之后，我们能看到自己的表达问题，大概的问题有两个：抽象层次和抽象粒度。这个是表达方面永恒的问题，也就是软件设计永恒的问题，没有万灵丹，但是用上了可视化手段之后还是有机会让生活更美好一点的。</p>
<p>这两个问题可能太抽象了，不容易意识到，那我们可以看图，从图上的具体表现来发现坏味道。一般会有几个迹象表明我们有可视化的坏味道：</p>
<ol>
<li>一张图上过分密密麻麻的线</li>
<li>一张图上太过多元素（也就是方块）也是坏味道</li>
<li>一张图上太少的元素，比如角色特别少</li>
<li>每个图上文字表达不契合，有的太泛泛，有的太细节也是问题。</li>
<li>无限制的画更多张图，基本上也就失去了使用图形化表达的意义。</li>
</ol>
<p>那么对应的手段就有：</p>
<h2 id="合成更大的元素"><a href="#合成更大的元素" class="headerlink" title="合成更大的元素"></a>合成更大的元素</h2><p>当我们发现密密麻麻的线、太多的元素，闻到这个味道的时候。我们可以考虑是不是该把里面的一些元素合成更大的元素了。Component可以合成Container，Container可以合成System，这样就会分成更多的图，每张图就变得没那么多线和元素了。</p>
<p>紧接着会面临下一个问题：怎么合成一个更大的系统，Container是明确的，所以Component合成Container不是问题，问题是Container怎么合成一个系统，为什么是这些Container合成这个系统，而不是另外几个？或者多加几个、减几个？</p>
<p>这个问题没有标准答案，但是有一些其他的框架可以提供一些思考的维度。</p>
<p>比如可以结合akf扩展立方来思考</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-01.png" alt="akf扩展立方"></p>
<p>X轴就比较容易，一方面看你的容器本身的描述来发现设计上是不是支持横向复制的，另一方面则是看你的部署图。<br>Z轴相对难一些，只是比较偏技术。比如当技术上有性能瓶颈，则需要注意这一个维度，有时不得不搞出一些特殊的容器出来，有时已经存在这些容器了，他们可能单独属于一个系统（类似于大数据分析的系统），或者一个系统的某一个局部（这就是我说的虚线框的表达力被限制的地方）。</p>
<p>Y轴给人的感觉是最容易操作的，但实际上却是最难的做好的，Y轴的背后是业务，往往我们觉得就按业务切成多张图就好了么。这种想法就表现出我们其实很看轻理解业务的难度，于是也总是出问题的地方。如果你能跨过这个心理障碍，决定去认真做一下，那么也有一些工具可以帮助我们做好。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-02.jpg" alt="领域模型与架构设计"></p>
<p>最经典的工具组合就是求助于DDD，结合康威定律和步速，考虑维护的团队、使用的角色、变化的节奏，这块展开就复杂了，有机会再聊。</p>
<p>这里说一个最简单的做法。按照用户角色分。同一种角色，由于它的，公司里的职能，他的职责都是已经被定好的。天然在系统上就有一种隔离性。比如招聘专员、会计、出纳。他们使用的系统肯定是不一样。</p>
<p>但说简单，其实也不简单。我见过一些图，上面的角色只有两个，内部用户和外部用户。而另一些图，细化到了persona的级别，或者把职级都放上去了。所以无论再简单的原则，最后都会掉进抽象的坑。</p>
<h2 id="画一些共识图来忽略掉一些通用的元素"><a href="#画一些共识图来忽略掉一些通用的元素" class="headerlink" title="画一些共识图来忽略掉一些通用的元素"></a>画一些共识图来忽略掉一些通用的元素</h2><p>有时候合成了更大的元素，元素依然很多，线条依然很密。画多张图也不够切分的。这个时候我们可以求助于共识。</p>
<p>人与人交流，彼此之间如果已经有一些共识存在就可以少废很多话，共识多到一定程度只需要确认一个眼神就完成交流了。所以毫无疑问做好共识管理，就可以大幅简化我们的架构图。</p>
<p>所以在我们做架构可视化的时候，经常会先画一个技术共识图，比如以一个我们的能力建设的数字平台为例，我们就画了一个下面这样的技术共识图。：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-03.png" alt="技术共识图"></p>
<p>然后在后面画具体的图的时候，我就可以省略掉一些共识的元素，像nginx和数据库就没有了，可以更关注在业务上，而不是技术上来画图。</p>
<h2 id="通过制定主题，限制文字的抽象层次"><a href="#通过制定主题，限制文字的抽象层次" class="headerlink" title="通过制定主题，限制文字的抽象层次"></a>通过制定主题，限制文字的抽象层次</h2><p>其实上面的技术共识图就是类似的做法，只是用于技术方面，如果用于业务方面，我们可以用一些抽象的名词或动词来代替一类业务，比如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/bad-smell-of-visualize-arch-design/pic-04.jpg" alt="数字平台系统景观图"></p>
<p>上图是一个系统景观图。当前这个主题是希望，人们一眼看清楚这个系统里面的相关角色都在使用什么系统，并且他们关注什么，职责是什么。所以具体学什么，怎么学的，都不是那么重要。所以我们就用学习一词代表了一系列的业务。</p>
<p>当主题确定的时候，很多纷杂的信息就没有了。一定要克制住自己，试图在一张图上，表达足够多信息的冲动。</p>
<h2 id="只画重要的图，剩下的交流的时候再画。"><a href="#只画重要的图，剩下的交流的时候再画。" class="headerlink" title="只画重要的图，剩下的交流的时候再画。"></a>只画重要的图，剩下的交流的时候再画。</h2><p>除了像上面说的，不要试图在一张图上给他足够的信息。同时也，不要试图把所有的信息都表达出来。</p>
<p>绝大多数的图可能只在交流具体业务的时候才画，推荐使用动态图。<br>这个手边没有例子，找到再说吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>即便有了C4这么，好用的可视化工具。我们依然会看到，自己会掉进抽象的坑。所以在使用的时候一定要注意坏味道，经常检察是不是犯了抽象层次和抽象力度的错，才能做好可视化。这件事上，没有谁能幸免，所以要时常自省，与诸君共勉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/reuse-obsession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/reuse-obsession/" class="post-title-link" itemprop="url">复用的着相</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>着相是佛家用语，指的是执着于外相偏离了本质。<br>仙剑奇侠传中有一个故事。讲的是一个成精了的佛珠。想要让更多的人向佛，于是施法，让这些人失去了记忆，只想一心礼佛。使人向佛，本来是好事，但强人所难，脱离了本质，便是着了相，也可以说反而是入了魔。<br>这个小故事告诉我们，在认知的世界里，我们很容易被表象所欺骗，忽略了本质。为此，佛家发明了这么一个名词来专门指出这种现象。</p>
<p>复用也是一样。复用本来是通过消除重复的方式。得到一系列可以复用的组件。从而在未来的开发工作中，更快速的响应需求变化，也就是所谓的提升响应力。<br>然而很多复用的结果，会造成代码是变少了，改起来却更难了。复用是增加了，可读性却下降了。考虑到软件开发是一个团队协作的工作，而我们这个行业的离职率又能到百分之二十之多。难以学习的代码确实是难以维护的，尽管你可以抱怨接手的人无能，但总之是降低了响应力，也就违背了复用的本质。<br>什么情况下会出现这样的场景呢？主要是因为视角的单一，只从自己单一的视角看到了重复而不是在做全局优化。这个说法可能稍微有些抽象，那我说几个相对具体的情况。</p>
<h2 id="当我们只关注功能视角的时候"><a href="#当我们只关注功能视角的时候" class="headerlink" title="当我们只关注功能视角的时候"></a>当我们只关注功能视角的时候</h2><p>需求有很多的描述视角，可以只在功能角度描述，比如“网站要有任务卡，任务卡上有文字版学习内容，视频讲解、也有作业题。”也可以加入业务视角，比如“学生要报名特训营，才能参加特训营。学生进入特训营后，就看到了任务卡列表。学生在任务卡上阅读学习资料，阅读完学习资料后做题来验证他是否学到，做完后提交交由助教审阅。”当我们只看功能视角的时候，可能会忽视业务上的不同，变的在功能角度过分抽象，最后当业务变化的时候，反而响应速度比较弱。<br>一个简单的后台，我们看起来所有东西长得都一样，不过是列表页面，添加页面修改页面，再加点儿删除什么的功能。说穿了都是crud，干脆我把这事弄成一一个组件好了，每个页面只需要简单配置一下，就可以出来自己的一套，增删改查页面。<br>这种视角完全没有考虑到，不同的实体，它们其实所在的业务是不一样的，关心它们的人也是不一样的。最后，彼此的演化方向也总会出现一些不同，你把它定义成一种东西，对于我每做一个修改，都要背负着其他所有实体的特异性。于是就逐渐拖慢了我改变的速度，降低了响应能力。</p>
<h2 id="无谓的自动化"><a href="#无谓的自动化" class="headerlink" title="无谓的自动化"></a>无谓的自动化</h2><p>有追求的程序员一定会考虑提升工作效率，通过一些自动化的手段来缩短流程，提高效率。不过有时候，这种追求也会有害。<br>在我们的系统里有一个面包屑功能，就是典型的“页面A / 页面B / 页面C”那种面包屑。团队成员提出，一个个页面写面包屑好烦啊，干脆做一个根据URL生成面包屑的功能吧。乍一看好像提高了效率，但实际上URL上的名词和你想显示在面包屑上的名字是可能出现不同的。<br>比如在我们的场景里，我们提供一个任务卡的预览功能，你的面包屑可能是“xx后台 / xx 训练营管理界面 / xx卡预览”，而学生正式使用任务卡的时候，他可能是 “ 学习中心 / xx 训练营 / xx卡 ”。而他们的url里可能都会出现’/programs/$pid/tasks/$tid’。同样的program、task翻译出来的文字完全不同。你为了支持这点不同，又要扩展一些额外功能来做这种区分，做来做去，可能还不如直接写来的方便，至多抽几个常量来简单的消除一下重复。</p>
<h2 id="当我们只从代码上看重复性的时候"><a href="#当我们只从代码上看重复性的时候" class="headerlink" title="当我们只从代码上看重复性的时候"></a>当我们只从代码上看重复性的时候</h2><p>这个我就不举例子了，其实很多犯这个错误的人都是重构的支持者，不过学艺不太精。因为如果你仔细看的话，重构里好多怀味道都有一个跟他对立的怀味道，比如发散式变化和霰弹式修改。如果我们只看代码就会违背复用的本质——更好的响应变化。<br>这个跟我说的第一个场景，只关注功能视角是类似的问题，这个可能更具象一点，只关注代码。</p>
<h2 id="无视上下文的时候"><a href="#无视上下文的时候" class="headerlink" title="无视上下文的时候"></a>无视上下文的时候</h2><p>这个可以看作是只有功能视角的一种情况，很多功能我们觉得有重复性，提升成一个概念，然而其实根本是两个东西，他们只是刚好叫一个名字。<br>比如过去很多软件里，是有一个统一的用户组概念，不管你在哪个业务上下文里，你都需要扩展这个用户组的概念来管理用户的权限。这个带来的结果就是用户组变得越来越臃肿，每次修改都要改一下别的组的功能。在我们的网校数字平台里，学生学习有学习小组，老师出题有出题小组，这两个小组业务完全不一样，这个时候如果都用统一的用户组来管理的话，那就势必会造成无谓的耦合，损害响应力。</p>
<p>这些故事告诉我们，我们不是在真空里去做复用。我们做的软件都是有它的商业目的。我们的工程实践也都是为商业目的服务的。当我们说tech@core的时候，让我们说技术就是业务的时候。诚然，他给技术人员带来了更多的权利，然而权利越大，责任也越大。技术人员也需要跳出技术，具备更多的业务视角和体验视角。而不仅仅是沉浸在技术得自high当中。才能真正的发挥出各种实践的价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/growth-method-of-team/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/growth-method-of-team/" class="post-title-link" itemprop="url">团队的精进之道</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】</p>
<p>之前写过一篇文章《编程的精进之法》，总结了ThoughtWorks中一点工作方法。现在看来，那篇文章其实应该叫个人精进之法。然而现在不是个人英雄的年代了，我们需要再深想一步，一个团队应该怎么办？</p>
<p>当我们在带领一个团队的时候，我们想的总是，如何做好任务分配，平衡团队战斗能力，交付最好的结果。于是做的时候就会下意识的去简单、被动的因材分工，那么随着项目的进展，人员的流动，各种意外的发生使得我们在项目后期感到处处掣肘，于是只能加班以示诚意。</p>
<p>我刚入行的时候，经历的各个项目都是如此，一直觉得这种事情就是天经地义的，直到认识了一个项目经理。该项目经理是个高人，他在项目开始的时候，问清楚每个人擅长的部分，然后让每个人去做自己不擅长的部分，不会？去找擅长的人帮忙。比如，张三说我以前做过用户权限管理，李四说我以前做过单据管理，王五说我以前做过工作流。（交代一下例子的上下文，那家公司主要就做一个大的领域，那个时候也不像现在前后端分这么清楚，项目经理有时候还要身兼Tech Lead）他就会说，好，张三去做工作流，王五去做单据管理，李四去做用户权限管理，遇到不会的，谁擅长什么你们都知道了啊，去问。</p>
<p>虽然看起来有点乱来，但是他负责的项目从来没出过问题。后来我加入了ThoughtWorks才知道，听到一个口号：“把项目成功交付看作能力建设的副产品”，才知道这是这口号的一种朴素实现。<br>很多团队能力不强，团队的领导者就总是在向外寻找方法的帮助。寻找方法帮助其实没有错，但是寻找方法帮助的人，心态往往都是错的。当我们在向外诉求方法的时候，很多人的潜意识，是假设我们团队成员能力不变的情况下，通过一种魔法般的方法，就可以改变团队的绩效，这种思路在真实世界里是走不远的。</p>
<p>在ThoughtWorks，我们认为，软件开发中的一切问题，根本上都是人的能力问题。如何发展每个成员才是问题的关键，因为成员如果没有进步，始终是治标不治本的。所以我们采用的一切实践，不管是以前曾采用的还是以后会采用的，核心目的都只有一个：发展人的能力。因此才有了那个听起来很耸动的口号：“把项目成功交付当成能力建设副产品”。</p>
<p>如何发展人的能力？讲东西吗？不太靠谱，信息仅靠分享是没用的，我经常把刚讲过一遍的知识，让人复述；把结对时刚写完的代码全删掉让同伴重写一遍，能做到的人不多。记也记不住，做也做不到。</p>
<p>就像我之前《然而培训并没有什么用》里说的，做练习？没时间，项目太忙了。而且，就算你有时间，我们拿出时间来做练习，你能保证到了跟练习不一样的场景下，团队成员们都能用好吗？把学会的知识在新场景下用好这件事，还是挺看天赋的。</p>
<p>讲东西不靠谱，做练习没时间，那难怪大家不考虑能力建设了。不过，如果我们反过来想，这个问题就变得没那么难办了，既然没有时间做能力建设，那么也许一切活动都可以看作是能力建设。所以那个项目经理的招数虽然看起来比较乱来，但却是这个思路，我在项目开始的时候，不是着急去以最快的速度交付结果，而是通过任务分配，发展团队成员的能力。在一个较长的时期里平均来看，我们就是在以最快的速度交付结果。</p>
<p>所以，回到我们的主题，就是团队的精进之道就是把交付过程中的一切活动都看作能力建设，把整个团队构造成促进每个成员成长的生态系统。</p>
<p>说起来好像挺简单，我只要换个角度看就好了，然而如果想要做到并没有那么简单。这里面差异微妙而关键。</p>
<p>比如以上一篇文章《软件开发的精进之法》讲到的方法为例。一个人要划任务，然后估时间，然后做的时候计时，根据实际结果进行反思。我们可以把这个方法做成非常邪恶的，仿佛流水线上工人的强制要求。我不关心你为什么超时，就通过这种方法来控制程序员，要求每个人都严格按照一个死板而僵化的步骤做一些简单重复的机械动作。也可以用这个方法来锻炼一个人的自我认知和发现知识漏洞等能力，促使他以最快的速度成长，等他成长起来马上给他更重要的任务，比如评估技术、评估项目、带新人、做架构等等。这两种结果的差异，背后就是领导者认识的差异，团队成员认识的差异。从这个认识的不同我们早在很多年前，就被一些大牛们观察到，作为敏捷宣言里的一句话表达了出来：“个体与交互 胜过 流程和工具”。</p>
<p>团队里的流程和工具，是为了成就个体，促进交互，还是为了抹杀个体，消除交互，这个微小而关键的差异，是一切的本质。有多少团队学了ThoughtWorks的一些实践，搞了看板、开放工作空间、TDD、CI，团队氛围依然压抑，成员之间交流不畅，个体成长不受尊重，领导与员工玩“猫和老鼠”。这样只学了形没有学到神的做法，最后的结果不会太好。</p>
<p>与之相反的做法呢？在上一篇文章《软件开发的精进之法》的开篇曾经简单的提到，新时代的管理者比起老板，更像老师。师者，传道，授业，解惑。各位老师，你们准备好了么？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/working-as-a-human-being/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/working-as-a-human-being/" class="post-title-link" itemprop="url">像人一样工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标题耸动吗？可能你会奇怪，我们不都是人吗？什么叫像人一样工作？</p>
<p>这个问题啊，你还别不认，我们不像人一样工作已经有个把世纪了。这一切都是从工业时代开始的。</p>
<p>工业时代带来的一个问题就是劳动异化，劳动异化说的是，资本家从劳动者手里买走了劳动力，从而使得劳动者的劳动性质产生了某种变化，这种变化叫做被异化。异化会产生什么问题呢？问题在于劳动力被买走了，劳动的意义也被买走了，所以劳动者在劳动中除了定时领工资没有任何意义，在生活中才有意义。没有意义感之后，人就不是人了，所以劳动者在劳动的时候不是人，是个机器，参考摩登时代：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-01-moden-times.gif" alt="image.gif"></p>
<p>资本家非常清楚这个道理，比如福特就曾经有句名言：我就想雇两只手，怎么来了个人呢？</p>
<p>这个问题一直延续到了现在，对程序员也是一样的。不然也不会有前一阵的996.ICU运动，这就是数字时代的工人运动。马云说，他自己超时工作如何如何，这个话说的就没文化，您是资本家，您劳动充满了意义感，而其他人是被异化的劳动者，劳动过程中没有意义感，它能一样吗？</p>
<p>我之前有几篇文章，讲了像机器一样思考的方式来思考软件和任务。而我们毕竟不是机器，理解机器并不是为了变成机器，何况我们也变不成机器。所以我们可以像机器一样思考，最终还是要像人一样工作。机器和人的差别在哪呢？回想一下当柯洁和李世石代表人类坐在机器面前，看着绝对不会犯错的机器，说出绝望的言论时，有没有让你觉察到我们跟机器的本质区别是我们会犯错这个关键约束条件？有些人可能不喜欢这个本质区别，但我觉得这没什么不好，这就好像苹果和梨，没有好坏之分，只是不同，工业时代把人变成机器，数字时代让人重新做人这是个好事。（尽管转变的过程中会有阵痛，但最终的结果也只能是这样，我坚信着。）</p>
<p>既然我们是人，我们接受这个前提，我们就要采用人工作的方式，而不是机器的工作方式。</p>
<p>机器工作的方式是什么样的呢？我们来看个动画：</p>
<p><a href="https://www.bilibili.com/video/av51228411" target="_blank" rel="noopener">https://www.bilibili.com/video/av51228411</a></p>
<p>这个问题在哪呢？在敏捷社区里有一副很有名的画，可以很好的说明人和机器的区别：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-02.png" alt="image.png"></p>
<p>看这个过程像不像前面机器公敌里的机器人作画的场面？</p>
<p>如果我们按照像机器一样思考教的里面画好了任务后，按照上图的方式去实现，就叫像机器一样工作，实际上这个行业里大量的项目都是这么干的，真是悲哀。每个人领一个模块，最后拼成一个功能，绝大多数人都不知道端到端什么样给客户提供了价值没有。这种工业时代的做事方法最大的问题就是把人当成了机器，像上面那组图一样工作，然而人做事是从粗略到丰富的画面一点点变过来的，就像下面这张图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-03.png" alt="image.png"></p>
<p>图片来源： <a href="https://acejoy.com/2018/04/20/438/" target="_blank" rel="noopener">https://acejoy.com/2018/04/20/438/</a></p>
<p>可以看到第一张图里，每一步都做得很完美，但是不到最后一步，它不是一个完成的成品。观察一下打印机，就是这么工作的，哪怕过程中出了状况，中断了工作，已经完成的部分每一个细节都是完美的。</p>
<p>而我们人是会犯错的，并不能做到像第一张图那样工作，反而是会采用第二张图那种方式。除了避免犯错，还有一个核心差异促使我们这么这么干，那就是机器是不知道疲劳和厌倦的，而人会，所以人在一个漫长的造物过程中，需要一种东西帮助自己持续获得前进的动力，那就是文章开头所说的意义感。</p>
<p>意义感是个很个人的事情，每个人对意义的定义不同。但工作中的意义感又确实有一种模式化的方式获得，那就是创造闭环。尽管人和人有很多的差异，但是只要完成一个闭环，大多数人都会产生或多或少的意义感。第二张图里，每一步都是一个完成了闭环的输出物，第一张是草图，第二张是简单涂色的图，第三张是完成稿。每一步我们都觉得完成了些什么，每一步我们都会有一点意义感。</p>
<p>作为一个人，我们需要这种东西，所以我们创造出了很多按照这种方式工作的方法，所谓的敏捷、所谓的迭代、所谓的冲刺、所谓的PDCA、所谓的TDD等等等等。一切的一切都在创造这种闭环，然后缩小闭环周期。而与之相反的各种工作方法却是在割裂闭环或拉长闭环周期，让大多数人都活在一段缺乏意义感的流程中或像鸵鸟把头埋到地里一样获得一种虚幻的安全感。天下方法千千万，这两种区别是本质区别，我们推广敏捷本质上是在追求前者的普及，与后者对抗，这是两种价值观、两种立场、两种社会算法的的对抗。</p>
<p>当我们用TDD的方式写代码的时候，当我们用PDCA一点点的精进我们的匠艺的时候，当我们每次冲刺的交付物都得到用户反馈的时候，当我们努力缩小反馈环追求更小闭环的时候，不管外面是不是有一个邪恶的资本主义体系在控制着我们娱乐至死，我们真实的感受到了自己像人一样工作着，感受到了劳动的意义，那这就是值得去做的。</p>
<p>那么这个值得去做的事情由谁来让它成为现实呢？我想来想去，只有团队的Leader，作为团队的领导者，你要去思考到底要求大家采用什么实践去做事的时候，除了想一想效率之外，也要想一想怎样的做法会让大家感受到意义，感受到像人一样在工作。在效率与意义之间的平衡，这是每个领导者的社会责任。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/visualize-arch-design-introduce-c4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/visualize-arch-design-introduce-c4/" class="post-title-link" itemprop="url">可视化架构设计——C4介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好多年前，徐昊说过的一句话给了我很大启发，他说“纸上的不是架构，每个人脑子里的才是”。这句话告诉我们，即便是天天工作在一个团队里的人，对架构的认识也可能是不一样的。每个人嘴上说的是类似的话，但心里想象的画面仍然是不一样的。在我多年的工作中，我越来越认可这句话所揭示出的道理。软件开发是一个团队协作的工作，混乱的理解会造成架构的无意义腐化、技术债的无意识积累、维护成本的无价值上升。</p>
<p>最近听到一句话，“那些精妙的方案之所以落不了地，是因为设计上没有兼容人类的愚蠢”。话糙理不糙，虽然最终人们选择的方案的思想都是十年前甚至几十年前就已经存在的，然而在技术升级到足以“兼容”人类的愚蠢之前，这些思想只能在学术的故纸堆里睡大觉。然而话糙确实也会有一个问题，将一个思想性问题转化成了一个情绪性问题。人们容易把一些糟心的事情归因到人类的愚蠢，宣泄了自己的不满情绪后就停止思考了。作为知识工作者，我们的思维不能停步，我们需要思考到底人类有哪些愚蠢，分别用什么方法去避免或者“兼容”。</p>
<p>可以肯定彼此明明对自己开发的软件有不一样的认识却天天在一起讨论问题并试图把软件做好是一件愚蠢的事情，为了兼容这种愚蠢我们需要采用可视化的方法。</p>
<p>为什么需要可视化呢，主要还是语言不靠谱。人类语言真的是太随意了，只要你想，你可以说你见过一个方形的圆，并为此与别人辩论。但是无论如何你也画不出来一个方形的圆，这就是我们需要可视化的原因。</p>
<p>今天我们介绍一个工具，叫做<a href="https://c4model.com/" target="_blank" rel="noopener">C4 model</a>，这是我近几年见到的一个比较难得跟我的认知有大量共鸣的工具。</p>
<p>该工具的作者在多年的咨询中经常发现，很多个人画出来的架构图都是不一样的，但也不是说他们谁画错了，而是每个人的抽象层次不一样。抽象层次这种东西，说起来好像存在，但真要说清楚还挺难，于是作者类比地图，提出了缩放的概念。（两年前我在教学生的时候提过同样的概念）如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-01.png" alt="国家级"></p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-02.png" alt="省级"></p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-03.png" alt="市级"></p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-04.png" alt="道路级"></p>
<p>上面的四张地图就是想说明，当我们看待真实世界的“架构图”的时候，也是要不停的缩放，在每一个层次刻意忽略一些细节才能表达好当前抽象层次的信息。所以他类比着把架构也提出了四个抽象层次：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-05.png" alt="image.png"></p>
<p>从上到下依次是系统System、容器Container、组件Component和代码Code。（咦，那为什么叫C4呢，因为系统的图叫System Context，系统上下文图。为了凑四个C也是够拼的。）</p>
<p>基于这四个层次的抽象，C4模型由4张核心图和3张附属图组成，分别用于描述不同的场景，下面我们一一介绍一下。</p>
<h2 id="四张核心图"><a href="#四张核心图" class="headerlink" title="四张核心图"></a>四张核心图</h2><h3 id="系统上下文图"><a href="#系统上下文图" class="headerlink" title="系统上下文图"></a>系统上下文图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-06.png" alt="image.png"><br>如上图所示，这个图表达的是你所开发的系统和它的用户以及它所依赖的系统之间的关系。从这个图上我们已经看出来C4图形的几个关键图形：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-07.png" alt="image.png"></p>
<p>C4说穿了就是几个要素：关系——带箭头的线、元素——方块和角色、关系描述——线上的文字、元素的描述——方块和角色里的文字、元素的标记——方块和角色的颜色、虚线框（在C4里面虚线框的表达力被极大的限制了，我觉得可以给虚线框更大的扩展空间）</p>
<p>通过在不同的抽象层次上，重新定义方块和虚线框的含义来限制我们只能在一个抽象层次上表达，从而避免在表达的时候产生抽象层次混乱的问题。</p>
<p>那么在系统上下文图里，方块指代的是软件系统，蓝色的表示我们聚焦的系统，也就是我开发的系统（也可能是我分析的系统，取决于我是谁），灰色表示我们直接依赖的系统，虚线框表示的是企业的边界。通过这些图形化的元素表达我们可以看出来各个系统彼此之间的关系。</p>
<h3 id="容器图"><a href="#容器图" class="headerlink" title="容器图"></a>容器图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-08.png" alt="image.png"></p>
<p>当我们放大一个系统，就会看到容器，如上图所示，C4模型认为系统是由容器组成的。容器是我个人认为，C4模型最大的创举，尤其是在这个单体架构快速崩塌的时代。所谓容器，既不是Docker的容器，也不是JavaEE里的容器，是借用了进程模型，每一个容器都是指有自己独立的进程空间的一种存在。不管是在服务器上的单独进程空间，还是在浏览器里的单独进程空间，只要是单独的进程空间就可以看作一个容器。当然如果你容器化做得好，Docker的Container和这个Container可以一一对应。有了这个概念的存在我们就可以更清晰的去表达我们的架构，而不是总是用一些模糊的东西。</p>
<h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-09.png" alt="image.png"></p>
<p>当我们放大一个容器，我们就会看到组件，如上图所示。组件在这里面很好的把接口和它的实现类打包成一个概念来表达关系。我个人觉得有时候一些存在于代码中，但又不是接口的某些东西，比如Service、Controller、Repository之类也可以用组件图来表达，如果你学了一些没有明确抽象层次的架构知识或者一些单体时代的遗留经验的时候，你可以画出来一些组件图，来印证自己的理解，如下图，我画的我对DDD战术设计里面的一些概念的理解：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-10.png" alt="image.png"></p>
<p>比起模糊的，堆砌在一起文字，这种表达要清晰的很多，哪怕我的理解是不对的，也容易指出和讨论。</p>
<h3 id="代码图"><a href="#代码图" class="headerlink" title="代码图"></a>代码图</h3><p>代码图没什么可说的，就是UML里的类图之类很细节的图。一般是不画的，都是代码生成出来。除非非常重要的且还没有写出代码的组件才画代码图。</p>
<p>以上就是C4的核心图，我们可以看到四种不同的抽象层次的定义会让我们更容易固定住我们讨论的层次，这点上我觉得C4是非常有价值的。</p>
<h2 id="三张扩展图"><a href="#三张扩展图" class="headerlink" title="三张扩展图"></a>三张扩展图</h2><p>架构设计设计要考虑的维度很多，仅四张核心图是不够的，所以作者又提供了三张扩展图，可以让我们关注更多的维度。</p>
<h3 id="系统景观图"><a href="#系统景观图" class="headerlink" title="系统景观图"></a>系统景观图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-11.png" alt="image.png"></p>
<p>看得出来，系统景观图是比上下文图更丰富的系统级别的表达。不像上下文图只关注聚焦系统和它的直接关系，连一些间接相关的系统都会标示出来，那些系统的用户以及用户之间的关系也会标示出来，只是内部的用户会用灰色标记。</p>
<p>这个图有什么用呢？在我们分析一个企业的时候，我们需要一个工具帮助我们把一家公司给挖个底掉，做到完全穷尽，才能看到企业的全景图从而理解局部的正确定位以做好局部设计为全局优化服务。之前我试过以四色建模的红卡、事件风暴的事件两种工具教人去掌握这种能力，当学员是程序员的时候都无法快速掌握这种顺藤摸瓜的分析技巧，毕竟跟程序员的思维还是有些差异的。但是我用了系统景观图之后，学员毫不费力的就掌握了这种分析能力。所以我后来都是用这个图来教程序员探索企业的数字化全景图，效果极好，推荐给大家。</p>
<h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-12.png" alt="image.png"></p>
<p>动态图不同于其他图都是表达静态关系的，它是用来表达动态关系的，也就是不同的元素之间是如何调用来完成一个业务的。所以动态图不仅仅在一个层面上可以工作，它在系统级、容器级和组件级都可以画，表达的目标是不一样的。</p>
<p>我之前曾经写过名为《像机器一样思考》的一系列文章，里面我也发明了类似的图，不同于他的关系线上标注的是调用的方法、函数，我更关注的是数据，使用效果也很好。</p>
<p>什么时候是用动态图呢？举个小例子，我之前做一个内部的小系统，只有一个有经验的工程师带着10多个毕业生，我便要求他们在开始工作之前都画出动态图来，交由有经验的工程师去评估他们的思路是否正确，如果有问题，就在开始之前就扼杀掉了烂设计。不管是毕业生还是初级工程师，改代码的能力都比写代码的能力要差很多，所以将烂设计扼杀在实现之前还是有帮助的。</p>
<h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/visualize-arch-design-introduce-c4/pic-13.png" alt="image.png"></p>
<p>前面的几张图都是站在开发的角度思考，但是一个没有充分思考过部署的架构很容易变成一个运维的灾难。所以作者提供了一个部署图。考虑到DevOps运动如火如荼，这个图可以变成很好的Dev和Ops之间沟通的桥梁。我们在实操中发现，Dev和Ops关注点的不同、语言的不一致，在这张图上表现得非常清楚。</p>
<p>图上最大的的实线框不同于虚线框，它表达的是数据中心，当你开始考虑异地载备的时候它就有了意义。数据的同步、实例的数量都会影响你部署图的内容。部署图基本都是容器级的，它会很好的表达出来容器到底部署了几个实例，部署在什么样的操作系统上，一个节点部署了几个容器之类，我们在实际使用中，发现需要考虑的信息太多，自己就抽象出了类似于亚马逊上实例规格的Small、Large之类的术语来表达机器配置，增进了开发和运维之间的交流准确性。</p>
<h2 id="为什么C4值得推荐"><a href="#为什么C4值得推荐" class="headerlink" title="为什么C4值得推荐"></a>为什么C4值得推荐</h2><p>够直观，对于程序员来说容易理解，容易使用。<br>我们在开头的时候说过，只有每个人脑子里的才是架构图，那么如果我们使用一个工具，工具本身的理解就很容易出错，那就陷入理解的死循环了。经过很多不同工具的教授尝试，C4模型是最容易理解，最容易使用的工具。可能它的概念是复用了程序员已有的一些认知模型，教给程序员后，都可以迅速的使用起来，并问出一些高质量的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在思维的世界里，我们都是盲人，很多东西我们以为自己知道，实际上画出来之后，才发现自己很多东西没想到，很多想的是乱的，同时别人也才可以给我们反馈。</p>
<p>有了上面的这个工具，我们就可以开始可视化的架构设计之路了，但路上还有一个心魔需要战胜。我们的文化里出错是一件很丢人的事情，所以我们喜欢用一些模糊的描述避免被别人挑战，而可视化是让我们精确的描述出我们的理解，来欢迎别人的挑战。这一个坎不太容易跨过去，但是一旦跨过去了，大家形成了正向的互动之后，我们的进步速度会变得很快，从而把封闭的人远远的甩在后面，获得组织级的成长推力。我自己就在跟别人的交流之后获得了更深入的洞见，本文已经分享了一些，还有一些内容<a href="https://jtong.github.io/2020/01/30/something-about-software-development/bad-smell-of-visualize-arch-design/" target="_blank" rel="noopener">下一篇文章</a>再跟大家分享。</p>
<p>图片来源：<br><a href="https://c4model.com/" target="_blank" rel="noopener">https://c4model.com/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/first-scene-of-software-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/first-scene-of-software-development/" class="post-title-link" itemprop="url">软件开发工作的第一现场</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>我的同事王健最近写了一篇文章。名字叫《从汽车贴膜看专业团队》。看了之后感触良多。特别是现场管理，和全功能团队两点。</p>
<p>我有一个观点，说到专业性，传统行业比我们IT行业要强得多。从这篇文章，我们可以看出来，不管是管理人员的现场管理，还是全功能团队，也就是一线人员的全栈能力，传统行业都比我们要强一些。我相信有人就会有些不服了，不管什么现场管理，全功能团队我们也在做呀。</p>
<p>说的没有错，但是，你在it行业里还真不容易找到这么专业的一个团队。而在传统行业里，这种水平的一个团队现在是越来越常见了。这是为什么呢？按说大家都是人，通常来讲，IT行业的人不是素质还高一点吗？我们这个行业的专业团队，不是应该更常见吗？虽然我们不一定要比你强，但是也不会比你弱得这么明显啊。</p>
<p>这当然一方面是由于我们这个行业的工作比较复杂，不容易做到全栈，但我觉得更重要的是，it行业是属于知识工作，知识工作者的现场是非常的不明显，极难做到现场管理。<br>我们IT行业的管理者，不管是项目经理，产品经理，还是技术领导者，大家也是基本和团队坐在一起。但是坐在一起，并不意味着，就能够真的在现场。</p>
<p>我们看到在那个贴膜团队里，团队领导只需要看一眼，发现有气泡，就知道质量有问题。也就是说，在传统行业进行现场管理的时候，问题都是非常直观的，非常容易发现。在软件行业想做到一点就难的多，几年前，我记得我的同事熊节也曾经写过一篇文章，文章的核心洞见就是软件开发的现场，在代码里。</p>
<p>这个洞见指导思特沃克工作很多年 ，公司里有很多人提出过类似的观点，于是我们的很多方法就是建筑在这些类似的观点之上。</p>
<p>然而，如果我们想要追求IT工作者开发效率的极限的话，这个洞见还不够极致。经过几年的工作，我发现，代码只是软件开发工作的第二现场，软件开发工作的第一现场，在语言里。<br>这里说的语言，不是，编程语言，也不是广义的人类语言，比如汉语、英语。指的是我们在从事软件开发工作中所使用的一系列术语，和相关的一系列呈现方式和沟通工具。借用一个技术术语，我们所说的语言是一套仅供软件开发所有相关人员使用的、组合的DSL，DSL全称：Domain specific language，中文名叫做：领域特定语言。</p>
<p>DSL就DSL，还组合的DSL，为什么要说的这么拗口呢？什么叫组合的DSL?我们知道在软件开发的过程当中，需要各种不同的角色参与。每个角色有自己特定的领域，泛泛的讲可以分为三类：我们把产品经理和设计人员所使用的领域特定语言叫做设计语言，把开发和测试使用的语言叫做技术语言，把业务人员、组织管理者使用的语言，叫做业务语言。</p>
<p>所以我们使用的这套，领域特定语言，是把这三类语言组合在一起而形成的一套语言。所以这就意味着我们这套语言非常容易充满歧义，造成每个角色自说自话却难以被发现。</p>
<p>软件工程里的核心观点是一个问题发现的越晚，修正它的成本就越高。比代码更早的是沟通，比沟通更早的就是语言。我们用语言去描述沟通的错误，去描述代码中的错误，我们用什么来描述语言的错误呢？还是语言，这就使得整个工作困难重重，难以达成共识。所以我们更需要非常严肃的对待，软件开发工作的第一现场。</p>
<p>之前一些方法试图建立纯粹的统一语言，所有人都说一套语言，这个方法已经被行业事实上放弃了，我们要承认，各自不同的语言有些部分可以简单统一成一种表达以消除歧义，有些部分只能结合。也就是说相关人员要懂多门语言这个现实是我们必须接受的，软件正在吞噬世界，语言只会越来越复杂。就像我们再努力消除污染，也不能幻想世界回到工业文明以前了。就算我们再努力的去建立统一语言，也不可能是一门简单的语言，只能是多门DSL的一个杂合体。</p>
<p>不过由于历史的原因，在行业放弃的过程中，由于反对预先设计走的过了头，不谈建模，不谈标准化成了一种奇怪的政治正确，导致很多优秀的工具和方法被边缘化了。其实我们憎恨的只是预先设计造成的反馈速度变慢。连带着憎恨预先设计时代的一些工具，就有点上纲上线了。</p>
<p>幸而最近几年，各种领域建模的设计方法又重新回归。最近大行其道的，领域驱动设计，就是在很严肃的，对待业务语言的设计和使用。而在前端领域，Design System试图解决前端开发和设计师之间的语言分歧问题。我个人在从事软件开发工程师的培养方面发现，很多传统的可视化工具，比如说UML。如果不以繁重的预先设计为目的，来使用这些工具，仅把它们用作提高沟通效率的工具，他们的威力是十分惊人的。</p>
<p>以我本人的团队为例，我们使用ant design为基础，设计了我们的design system。使得我们可以在三天之内得到一个可以点击的软件原型，并在此基础上，进行各利益相关方之间的需求交流和反馈。在交流的过程当中，我们也刻意的统一了我们的语言。使得我们尽管是一个远程团队，但是当我们在交流的时候，很清楚的知道我们在对信息架构在哪一层进行反馈。这不但使得业务方可以反馈技术方，其实技术方也在引导业务方。语言的影响是双向的。</p>
<p>在技术领域里，我们也选择了隔离性更好的技术架构，使得我们MVP的代码不会变成我们演进道路上必须长期背负的负累。而之所以在一篇聊“语言”的文章里提技术架构，是因为我们认为，真正的架构不是纸上的，却也不是代码里的，而是每个团队成员心里的架构。实施一个架构必然也是要进行大量沟通，也需要统一语言。</p>
<p>而在交流业务的时候，我们刻意的划分了各种不同的子领域又在每个领域当中统一了名词。统一名词还是比较简单的，最难的是划分领域，我们为此投入了大量的工作，也犯了一些错误，但这些付出是值得的，这之后，我们的沟通变得非常流畅。</p>
<p>具体的实践有机会再跟大家分享。我在这里仅仅聊一下沟通顺畅带来的价值。沟通顺畅的威力并不仅仅表现在沟通的时候可以很顺畅的传递信息，最重要的是当有团队成员对信息理解出现错误的时候，可以很容易的暴露和给予反馈。</p>
<p>这个优势在IT行业至关重要。IT行业的人员流动率接近25%，这意味着每年我们团队中至少有1/4的人是新人。而即便我们想尽方法让我们的团队保持稳定，随着敏捷和精益创业的相关思想已经慢慢成为我们的工作常识，每个项目存在的时间都不会太长，从而使得IT团队是经常性的重组，有时是团队被打散，有时是同一个系统从一个团队交给了另一个团队。如果缺乏一种有效的反馈机制，那么无论是人员流动还是组织重组，所造成的切换成本都是一个可观的数字。尽管这个切换成本是无法消除的，但是尽量减少切换成本是我们每个专业人员应该追求的，尤其是团队中的技术领导者。</p>
<p>技术领导者重音在领导，而不在技术。尤其在Tech@Core的今天，技术就是业务。优秀的技术领导者更不能把自己变成一个救火队员，只是被动的响应，尽管救火队员往往很容易被人所看到而获得一些关注和赞扬，但在我们中国的文化里，我们都知道还有更高一层的境界，这个境界存在于很多典故中，比如上医治未病，善战者无赫赫之功。同理，我们软件开发领域的技术领导者们也应该努力使大多数问题发生的基础消灭于无形，这就需要我们走出我们的舒适区，深入到软件开发的第一现场，进行现场管理才能达成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-03/" class="post-title-link" itemprop="url">像机器一样思考（三）—— 穷尽就是力量</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过前两篇的内容学习，我相信大家已经差不多学会了这个思考模型。本篇的重点是用它来解决更复杂的问题。当我们开始解决一些稍微复杂点的问题的时候，我们会发现差不多的态度是不行的，我们需要严谨的态度进行缜密的思考才能真正发挥出这个思考模型的力量。</p>
<p>慢慢你会发现，这个思考模型本身不会让你思维缜密，而思维缜密了才能用好这个思考模型。它带来的最大的好处，是让你自己开始看到自己思维的欠缺，从而不再是个思维世界的盲人。</p>
<h2 id="穷尽"><a href="#穷尽" class="headerlink" title="穷尽"></a>穷尽</h2><p>那么，我们开始做点复杂的题目。也没复杂多少，我们扩展一下上一篇的题目，算学生的成绩单：</p>
<p>打印所有人的成绩单。已知输入的格式是</p>
<blockquote>
<p>[“学号”, “学号”, “学号”]<br>比如：<br>[“TWA20160101”,  “TWA20160102”, “TWA20160103”]</p>
</blockquote>
<p>我们有一个全局函数可以给我们提供所有的学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function loadAllScore()&#123;</span><br><span class="line">    return [&#123;</span><br><span class="line">        name: &quot;张三&quot;,</span><br><span class="line">        id: &quot;TWA20160101&quot;,</span><br><span class="line">        chinese: &quot;95&quot;,</span><br><span class="line">        english: &quot;80&quot;,</span><br><span class="line">        math: &quot;95&quot;,</span><br><span class="line">        programming: &quot;80&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要求打印出成绩单类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名|数学|语文|英语|编程|平均分|总分 </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">张三|75|95|80|80|82.5|330</span><br><span class="line">李四|85|80|70|90|81.25|325</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">全班总分平均数：xxx</span><br><span class="line">全班总分中位数：xxx</span><br></pre></td></tr></table></figure>

<p>仅对这个题目进行划分，我们一定觉得很简单，对吧。就仿照着之前的写呗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#1 生成成绩单view model</span><br><span class="line">输入：</span><br><span class="line">  studentIds: [String]</span><br><span class="line">输出：</span><br><span class="line">  scoreSheet: &#123;</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">#2 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">  scoreSheet</span><br><span class="line">输出：</span><br><span class="line">  result: String</span><br></pre></td></tr></table></figure>

<p>我相信很多人都是这么想的，然而不幸的告诉这么想的同学，这种写法是错误的。原因其实也很简单，请问，#1输出里的chinese等成绩是怎么得到的呢？没有来源吧？你说你调了<code>loadAllScore</code>函数？那为什么不写在输入里呢？</p>
<p>所以说，我们遗漏了一些输入。回到我们开始的标题上：穷尽。</p>
<p>可能有很多人听说过一个分析问题的基本原则：完全穷尽，各自独立。很多人听到这个时候，会很困惑：穷尽什么？独立什么？经过我们这些练习，我相信在编程领域，你们这个困惑会小很多。</p>
<p>所谓各自独立，说的就是在我们划分任务的过程中，每一个任务都对应一个代码块或一个函数，这些代码块和函数，是互相不包含的（不是不依赖，这是翻译的问题，各自独立的独立指的是Exclusive不是Independent）。</p>
<p>所谓的完全穷尽，说的是我们需要穷尽这个代码块或函数里所有的输入和输出。不能遗漏任何一个输入，任何一个输出。我们的每一项，它的属性，也不能有遗漏，我不能说分析<code>studentScores</code>只想到部分属性，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">studentScores:[&#123;</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure>

<p>这样是不行的。如果我们不严于律己穷尽所有的数据项，我们就会在写代码的时候遇到各种问题。能否穷尽与否，也看出来你思维的缜密与否。</p>
<p>是不是开始感觉到麻烦了，刚开始做的时候是有些慢的，但我们坚持穷尽这个好习惯，就会渐渐的感受到自己能力的成长。如果你穷尽了所有的输入输出，那么各种可能遇到的问题就像是如来佛手里的孙猴子，无论有什么变数也尽在你掌握之中了。</p>
<p>那么如果我们穷尽输入输出的话，我们这个题目真正的任务应该怎么分解呢？可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#1 获得学生成绩</span><br><span class="line">输入：</span><br><span class="line">    studentIds: [String]</span><br><span class="line">    studentInfo: [&#123;</span><br><span class="line">        id: String,</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">    &#125;]</span><br><span class="line">输出：</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">#2 计算总计</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">输出：</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#3 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">    summary</span><br><span class="line">输出：</span><br><span class="line">    result: String</span><br></pre></td></tr></table></figure>

<p>可能你会奇怪，为什么会分成3步呢？或者说，我们该怎么判断分几步呢？这其实没有一个标准答案，我建议初学者尽量步子小一点，多分几步，经验丰富的人就可以步子大一点。不过有一个反直觉的经验可以分享给大家，你步子大了，开发速度不见得快，因为人是会犯错的。</p>
<p>这个题是写出来了，但是我们还是不太清楚怎么穷尽对吧。说是穷尽输入输出，到底输入输出都有多少大类呢？这个也是可以穷尽的。</p>
<p>输入总共有下面几大类：</p>
<ol>
<li>参数</li>
<li>读取全局变量</li>
<li>调用全局函数后得到的返回值</li>
<li>读取局部作用域变量（比如this）</li>
<li>调用局部函数后得到的返回值</li>
<li>hard code的数据</li>
</ol>
<p>输出总共有下面几大类：</p>
<ol>
<li>返回值</li>
<li>修改全局变量</li>
<li>调用全局函数时传的参数</li>
<li>修改局部作用域变量（比如this）</li>
<li>调用局部函数时传的参数</li>
</ol>
<h2 id="来去"><a href="#来去" class="headerlink" title="来去"></a>来去</h2><p>听起来不错，不过从哪来，到哪去，还是要写清楚的，我们的studentInfo从哪里来？我们的result又到哪里去了？加上这个来去，我们最终的版本是长这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#1 获得学生成绩</span><br><span class="line">输入：</span><br><span class="line">    studentIds: [String]</span><br><span class="line">    studentInfo: [&#123;</span><br><span class="line">        id: String,</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">    &#125;]: loadAllScore()</span><br><span class="line">输出：</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">#2 计算总计</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">输出：</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#3 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">    summary</span><br><span class="line">输出：</span><br><span class="line">    result: String: console.log()</span><br></pre></td></tr></table></figure>


<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>引入加分策略<br>少数民族 +10分<br>体育特长 +20分<br>艺术特长 +15分</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>好像输入和输出的可能性太多了，这很容易让人乱啊。<br>是这样的，所以为什么到了函数式编程我们需要强调纯函数，只有一个输入来源和一个输出去处，一般来讲就是输入只有参数，输出只有返回值。所以你看，如果你把一个领域都穷尽掉，你也会自己发明出那些靠谱的实践，换句话说，如果你能在用这套思维模型的过程中逐渐发现跟各种最佳实践都很容易配合使用，那就对了。（其实也不是什么配合使用，因为它跟代码是等价的，所以容易写代码的方法就容易用它，这是当然的。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-04/" class="post-title-link" itemprop="url">像机器一样思考（四）—— 一图抵千言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>当我们把一个完整的功能拆解为一个个输入输出穷尽，互相独立的任务后，它是容易转化为代码了，可是这种方式并不容易思考规模更大的问题（光从哪来到哪去就够我们绕的）。把我们的大脑看成一台电脑，我们就是那种内存很低的电脑，问题规模一大，我们就会死机，然后就只能重启了。具体表现为我们思考时会觉得晕。每次晕的时候可能都重启了一下:)。</p>
<p>怎么办呢？其实也很简单，内存不够硬盘来凑。对我们的大脑来说，最常见的“硬盘”就是纸。而正如电脑的硬盘传输速度总是不如内存的，加了硬盘计算效率不一定快。我们需要一种对传输友好的编码方式，这种方式就是画图。</p>
<h2 id="画图的规则"><a href="#画图的规则" class="headerlink" title="画图的规则"></a>画图的规则</h2><p>我们的画图方法受时序图启发而发明，具体的规则如下：</p>
<ol>
<li>本图基本元素由方块和带箭头的线组成</li>
<li>一个方块只代表一个函数或一个代码块，通常是函数，方块中可以写字，可以表达函数是属于哪个类或哪个实例等信息。</li>
<li>指向方块的线代表该函数的输入，背离方块的线代表函数的输出。</li>
<li>数据流动的时间轴遵守先从左到右，再从上到下的顺序。</li>
<li>每一对输入输出（输入在上，输出在下）加一个方块，表达了一次函数调用。</li>
</ol>
<p>举例：<br>比如下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function c()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>画成图是这个样子的</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-01.png" alt=" function call"></p>
<p>在这个图上我们可以清晰的看出来，函数a调用了函数b，函数b调用了函数c。而函数a自己，是在最顶层调用的，也就是所谓的程序入口。<br>整张图是从左往右表示时间顺序。</p>
<p>什么情况下既有从左到右，也有从上到下呢？比如下面这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">    &#x2F;&#x2F; b codes</span><br><span class="line">&#125;</span><br><span class="line">function c()&#123;</span><br><span class="line">    &#x2F;&#x2F; c codes</span><br><span class="line">&#125;</span><br><span class="line">function a()&#123;</span><br><span class="line">    b();</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    c();</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数a先调用了函数b，然后再执行一段a里面的代码，再调了函数c，然后再执行了一段a里面的代码，然后返回。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-02.png" alt=" a call b+c "></p>
<h2 id="正常的使用方式"><a href="#正常的使用方式" class="headerlink" title="正常的使用方式"></a>正常的使用方式</h2><p>我们正常使用这个实践的时候，这个过程是反过来的，我们可能先看画出了上面这张图。不过这回，我们要画的认真一点，为了后面可以导出任务列表，我需要加上标号，如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-03.png" alt="(a-b)+(a-c) with detail"></p>
<p>然后从这张图里按照标号导出任务列表，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1 函数a</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line"></span><br><span class="line">#2 函数b</span><br><span class="line">输入：</span><br><span class="line">    paramY: TypeY</span><br><span class="line">输出：</span><br><span class="line">    cValue: TypeB</span><br><span class="line"></span><br><span class="line">#3 函数c</span><br><span class="line">输入： </span><br><span class="line">    paramZ: TypeZ</span><br><span class="line">输出：</span><br><span class="line">    aValue: TypeC</span><br></pre></td></tr></table></figure>

<p>然而这里有个问题，对于<code>函数b</code>和<code>函数c</code>来说，输入输出倒是很正确，对于<code>函数a</code>来说，难道<code>函数b</code>和<code>函数c</code>的返回值不是它的输入吗？相应的，<code>函数b</code>和<code>函数c</code>的参数也是它的输出。</p>
<p>所以真正完善的IO是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#1 函数a</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">    cValue: TypeB: 函数b</span><br><span class="line">    aValue: TypeC: 函数c</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line">    paramY: TypeY: 函数b</span><br><span class="line">    paramZ: TypeZ: 函数c</span><br><span class="line"></span><br><span class="line">#2 函数b</span><br><span class="line">输入：</span><br><span class="line">    paramY: TypeY</span><br><span class="line">输出：</span><br><span class="line">    cValue: TypeB</span><br><span class="line"></span><br><span class="line">#3 函数c</span><br><span class="line">输入： </span><br><span class="line">    paramZ: TypeZ</span><br><span class="line">输出：</span><br><span class="line">    aValue: TypeC</span><br></pre></td></tr></table></figure>

<p>写出的代码大概如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">    &#x2F;&#x2F; b codes</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function c()&#123;</span><br><span class="line">    &#x2F;&#x2F; c codes</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function a()&#123;</span><br><span class="line">    let bValue &#x3D; b(paramX);</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    let cValue &#x3D; c(paramZ);</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在在真正的工作中，<code>函数b</code>和<code>函数c</code>这样的函数是非常少的，大部分都是<code>函数a</code>这样既被调也调别人的函数。如果每一个都按照这样去切分，恐怕就不是一个高效的方法了，即便列出来也很乱。不但不能帮助思考，反而会阻碍思考。</p>
<p>当按照模块的角度去拆分task不work的时候，我们就要按照测试的角度来切分task了，这个思维的切换是TDD的核心。我们需要按照测试的视角来切分任务，从一个函数的实现视角转为一个函数的调用视角。</p>
<p>这样做的好处有三个：</p>
<ol>
<li>封装复杂性，当我们按照模块去拆分的时候，如前文所说，复杂性会变高，思考负担会加大。而按照测试的视角来切分呢，复杂性当然不会消失，但是被封装了，方便我们在分析的时候减少思考负担。</li>
<li>跳出盒子外来看盒子的视角。我们在画前面的图的时候，实际上是在我们要实现的这个程序内在看，完全没有使用者的视角，也就是所谓的在盒子内，。当我们站在测试的视角看的时候，我们就跳出了盒子外，他更容易让我们发现哪里可能设计上有问题，比如设计出的接口是不是好用。</li>
<li>在ThoughtWorks，我们有一个观点：叫做任务不是步骤。当我们按步骤来考虑问题的时候，对怎么算做完这个问题的答案往往是模糊的（往往只落在行为上，而不是结果上）。当我们只考虑函数实现的时候，也会有类似的问题，因为一个数据类型包含的情况太多了，想到某种类型的数据我们就会停止思考当前问题转而去想其他问题，于是我们很容易漏掉一些情况，以测试角度看待任务会让我们更容易看清楚我们的工作是不是真的做完了。</li>
</ol>
<p>最棒的是，我们可以照着任务列表写出测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;test case 1 for function b&quot;, () &#x3D;&gt;&#123;</span><br><span class="line">    let paramX &#x3D; &#x2F;&#x2F; TypeX的测试数据</span><br><span class="line">    </span><br><span class="line">    let actualBValue &#x3D; b(paramX); &#x2F;&#x2F; 调用b函数的实际返回值</span><br><span class="line">    </span><br><span class="line">    let exceptedBValue &#x3D; &#x2F;&#x2F; 调用b函数的期望的返回值</span><br><span class="line">    expect(actualBValue).is(expectedBValue); &#x2F;&#x2F;断言</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以此类推...</span><br></pre></td></tr></table></figure>

<p>所以，我们是在以测试驱动的方式做任务划分，你可以叫它测试驱动的任务切分。</p>
<p>如果要映射到测试，我们的任务列表就缺了一些东西，那就是所谓的测试用例。因为同一个函数可能有不同的测试用例，所以加上用例我们的任务列表应该长成这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1 场景一</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line">测试用例:</span><br><span class="line">    用例1：</span><br><span class="line">        inputValue1</span><br><span class="line">        ----</span><br><span class="line">        outputValue1</span><br><span class="line">    用例2：</span><br><span class="line">        inputValue2</span><br><span class="line">        ----</span><br><span class="line">        outputValue2</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 以此类推...</span><br></pre></td></tr></table></figure>

<p>我们看到因为输入输出的顺序已经定好了，为了书写的速度，我们就省略了名字。如果你觉得不舒服也可以写上名字。如果你觉得这样太浪费时间，你可以把每组用例用一句话描述。毕竟一切为了实用嘛。</p>
<p>是不是感觉后面讲的很抽象啊，不知道具体怎么做啊？不要着急，后面有例子。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>请把上一篇的任务列表，画成图</li>
<li>试着按照测试用例的方式画，没有思路可以阅读完第五篇和第六篇再来画。</li>
</ol>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="题外话-1"><a href="#题外话-1" class="headerlink" title="题外话-1"></a>题外话-1</h3><p>视角的切换对于软件开发来说是至关重要的一个能力。为了说明这个的价值，我们甚至发明了一个概念——数字化人才</p>
<p>然而大多数人都不具备，所以对于大多数人来说，具备这个能力，最起码的好处就是变成了一种稀缺性人才，对于获得高薪是有帮助的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-05/" class="post-title-link" itemprop="url">像机器一样思考（五）—— 第一个应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 09:55:21" itemprop="dateCreated datePublished" datetime="2020-01-30T09:55:21+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过前面四篇，我们已经具备了最基本的思考编程的能力。我们开始做一个真正的应用吧。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>我们现在做一个应用，该应用是一个命令行应用。当程序启动的时候，我们会看到一个命令行的主界面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加学生</span><br><span class="line">2. 生成成绩单</span><br><span class="line">3. 退出</span><br><span class="line">请输入你的选择（1～3）：</span><br></pre></td></tr></table></figure>

<p>如果我们输入1，那么界面就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入学生信息（格式：姓名, 学号, 民族, 班级, 学科: 成绩, ...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果输入格式不正确，就返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请按正确的格式输入（格式：姓名, 学号, 学科: 成绩, ...）：</span><br></pre></td></tr></table></figure>

<p>如果输入格式正确就会返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生xxx的成绩被添加</span><br></pre></td></tr></table></figure>

<p>然后打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加学生</span><br><span class="line">2. 生成成绩单</span><br><span class="line">3. 退出</span><br><span class="line">请输入你的选择（1～3）：</span><br></pre></td></tr></table></figure>
<p>等于回到了主界面。<br>如果我们在主界面输入了2，那么界面就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的学生的学号（格式： 学号, 学号,...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果我们输入的不正确，就会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请按正确的格式输入要打印的学生的学号（格式： 学号, 学号,...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果输入的格式正确，则会打印成绩单并回到主界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名|数学|语文|英语|编程|平均分|总分 </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">张三|75|95|80|80|82.5|330</span><br><span class="line">李四|85|80|70|90|81.25|325</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">全班总分平均数：xxx</span><br><span class="line">全班总分中位数：xxx</span><br></pre></td></tr></table></figure>

<p>如果我们输入的学号不存在，该学号在计算时就会被忽略。</p>
<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>这个题目比之前的复杂一点，我们可以先按照功能简单列一下任务列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1 打印主菜单</span><br><span class="line">#2 添加学生成绩</span><br><span class="line">#3 生成成绩单</span><br><span class="line">#4 退出</span><br></pre></td></tr></table></figure>

<p>然而这个列表是跟我们的程序不等价的。我们还是应该列出跟程序等价的任务列表。为了便于表达，我们就需要画图。我们先不考虑面向对象，直接面向过程的划分，我们画出来的图大概是下面这个样子：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-05/pic-01.png" alt="image"></p>
<p>也许你觉得这个做法并不够好，我也这么觉得，那我们可以重构这个图，画出一种更好的解法：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-05/pic-02.png" alt="image"></p>
<p>可以看出，这两种做法，在图形上看并没有明显的区别，但是命名上暴露出了思路的不同，后者明显减少了程序对外输入输出的次数。所以不要随便命名。<br>但如果没有上面那个图，我们是看不出来buildReport这个函数他打印了还是没打印，这就需要我们有一套约定俗成的用语规范，从用语规范中可以看出来我们到底做了什么。</p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol>
<li>针对两张图，分别列出所有的任务。</li>
<li>在脑中模拟一下，如果测试先行的方式写代码，两种实现的时间花费各会是多少。按照任务列表逐项估出时间，并比较两种实现的时间差异。</li>
</ol>
<h2 id="题外话-1"><a href="#题外话-1" class="headerlink" title="题外话 - 1"></a>题外话 - 1</h2><p>对于接触本文章的编程初学者，我需要多说几句：我们可以看到，其实一个真正的应用也是由一些简单函数构成的，那就说明编程思想和技巧并不受限于应用的表象。前端、后端、应用、系统之类的名词，往往是从分工的角度来讲的，如果从个人发展的角度来讲，不要拿这些名词限制自己。这也是我们这个系列只讲一些简单应用的缘故，抽象来讲思路是一样的。</p>
<h2 id="题外话-2"><a href="#题外话-2" class="headerlink" title="题外话 - 2"></a>题外话 - 2</h2><p>到这里，你应该能感觉到我们这些题目，其实是一个个思维训练，对于这个思维训练，最重要的事情有三点：</p>
<ol>
<li>语文问题（用词精确，前后一致）</li>
<li>接口问题（完全穷尽）</li>
<li>每个函数之间互相不知道对方的内在实现（各自独立）<br>能做好这三点，代码就能完胜行业里的大多数人：）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
