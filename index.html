<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/tech-leadership/working-as-a-human-being/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/tech-leadership/working-as-a-human-being/" class="post-title-link" itemprop="url">像人一样工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标题耸动吗？可能你会奇怪，我们不都是人吗？什么叫像人一样工作？</p>
<p>这个问题啊，你还别不认，我们不像人一样工作已经有个把世纪了。这一切都是从工业时代开始的。</p>
<p>工业时代带来的一个问题就是劳动异化，劳动异化说的是，资本家从劳动者手里买走了劳动力，从而使得劳动者的劳动性质产生了某种变化，这种变化叫做被异化。异化会产生什么问题呢？问题在于劳动力被买走了，劳动的意义也被买走了，所以劳动者在劳动中除了定时领工资没有任何意义，在生活中才有意义。没有意义感之后，人就不是人了，所以劳动者在劳动的时候不是人，是个机器，参考摩登时代：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-01-moden-times.gif" alt="image.gif"></p>
<p>资本家非常清楚这个道理，比如福特就曾经有句名言：我就想雇两只手，怎么来了个人呢？</p>
<p>这个问题一直延续到了现在，对程序员也是一样的。不然也不会有前一阵的996.ICU运动，这就是数字时代的工人运动。马云说，他自己超时工作如何如何，这个话说的就没文化，您是资本家，您劳动充满了意义感，而其他人是被异化的劳动者，劳动过程中没有意义感，它能一样吗？</p>
<p>我之前有几篇文章，讲了像机器一样思考的方式来思考软件和任务。而我们毕竟不是机器，理解机器并不是为了变成机器，何况我们也变不成机器。所以我们可以像机器一样思考，最终还是要像人一样工作。机器和人的差别在哪呢？回想一下当柯洁和李世石代表人类坐在机器面前，看着绝对不会犯错的机器，说出绝望的言论时，有没有让你觉察到我们跟机器的本质区别是我们会犯错这个关键约束条件？有些人可能不喜欢这个本质区别，但我觉得这没什么不好，这就好像苹果和梨，没有好坏之分，只是不同，工业时代把人变成机器，数字时代让人重新做人这是个好事。（尽管转变的过程中会有阵痛，但最终的结果也只能是这样，我坚信着。）</p>
<p>既然我们是人，我们接受这个前提，我们就要采用人工作的方式，而不是机器的工作方式。</p>
<p>机器工作的方式是什么样的呢？我们来看个动画：</p>
<p><a href="https://www.bilibili.com/video/av51228411" target="_blank" rel="noopener">https://www.bilibili.com/video/av51228411</a></p>
<p>这个问题在哪呢？在敏捷社区里有一副很有名的画，可以很好的说明人和机器的区别：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-02.png" alt="image.png"></p>
<p>看这个过程像不像前面机器公敌里的机器人作画的场面？</p>
<p>如果我们按照像机器一样思考教的里面画好了任务后，按照上图的方式去实现，就叫像机器一样工作，实际上这个行业里大量的项目都是这么干的，真是悲哀。每个人领一个模块，最后拼成一个功能，绝大多数人都不知道端到端什么样给客户提供了价值没有。这种工业时代的做事方法最大的问题就是把人当成了机器，像上面那组图一样工作，然而人做事是从粗略到丰富的画面一点点变过来的，就像下面这张图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/working-as-a-human-being/pic-03.png" alt="image.png"></p>
<p>图片来源： <a href="https://acejoy.com/2018/04/20/438/" target="_blank" rel="noopener">https://acejoy.com/2018/04/20/438/</a></p>
<p>可以看到第一张图里，每一步都做得很完美，但是不到最后一步，它不是一个完成的成品。观察一下打印机，就是这么工作的，哪怕过程中出了状况，中断了工作，已经完成的部分每一个细节都是完美的。</p>
<p>而我们人是会犯错的，并不能做到像第一张图那样工作，反而是会采用第二张图那种方式。除了避免犯错，还有一个核心差异促使我们这么这么干，那就是机器是不知道疲劳和厌倦的，而人会，所以人在一个漫长的造物过程中，需要一种东西帮助自己持续获得前进的动力，那就是文章开头所说的意义感。</p>
<p>意义感是个很个人的事情，每个人对意义的定义不同。但工作中的意义感又确实有一种模式化的方式获得，那就是创造闭环。尽管人和人有很多的差异，但是只要完成一个闭环，大多数人都会产生或多或少的意义感。第二张图里，每一步都是一个完成了闭环的输出物，第一张是草图，第二张是简单涂色的图，第三张是完成稿。每一步我们都觉得完成了些什么，每一步我们都会有一点意义感。</p>
<p>作为一个人，我们需要这种东西，所以我们创造出了很多按照这种方式工作的方法，所谓的敏捷、所谓的迭代、所谓的冲刺、所谓的PDCA、所谓的TDD等等等等。一切的一切都在创造这种闭环，然后缩小闭环周期。而与之相反的各种工作方法却是在割裂闭环或拉长闭环周期，让大多数人都活在一段缺乏意义感的流程中或像鸵鸟把头埋到地里一样获得一种虚幻的安全感。天下方法千千万，这两种区别是本质区别，我们推广敏捷本质上是在追求前者的普及，与后者对抗，这是两种价值观、两种立场、两种社会算法的的对抗。</p>
<p>当我们用TDD的方式写代码的时候，当我们用PDCA一点点的精进我们的匠艺的时候，当我们每次冲刺的交付物都得到用户反馈的时候，当我们努力缩小反馈环追求更小闭环的时候，不管外面是不是有一个邪恶的资本主义体系在控制着我们娱乐至死，我们真实的感受到了自己像人一样工作着，感受到了劳动的意义，那这就是值得去做的。</p>
<p>那么这个值得去做的事情由谁来让它成为现实呢？我想来想去，只有团队的Leader，作为团队的领导者，你要去思考到底要求大家采用什么实践去做事的时候，除了想一想效率之外，也要想一想怎样的做法会让大家感受到意义，感受到像人一样在工作。在效率与意义之间的平衡，这是每个领导者的社会责任。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/something-about-software-development/user-centered-software-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/something-about-software-development/user-centered-software-development/" class="post-title-link" itemprop="url">以用户为中心的软件开发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天这个时代迭代开发已经成为常识，甚至政治正确，随便谁就能给你扯两句mvp。敏捷也从一个开发的名词变成了管理名词，迭代、测试、反馈这类名词满天飞。</p>
<p>人人都在说这些术语，仿佛他们真的就懂怎么做软件了。起码，觉得自己真的懂怎么创新了。然而经不起细聊，一旦深入下去聊一个mvp，聊聊他的迭代计划。就会发现露馅了，张嘴闭嘴谈的都是功能。这个迭代要交付几个功能，这个mvp多了什么功能？他的竞争对手都有哪些功能？却很少听到用户。人人都在喊，以用户为中心。口号喊得震天响，但你看他们的行为模式，他们的语言中，并没有用户的身影，更像只是在否定别人、固执己见的时候拿这个来当借口。</p>
<p>我时常觉得这个事情不太对劲。但是也没有想到更好的方法。敏捷中使用的故事卡比功能的视角要好一点。因为在故事卡里，你要写下用户的价值。但是，我一直也不知道这个价值是从哪儿来的。是先开枪后画靶子我们想做某个功能了，所以硬安的一些价值，还是真的存在的？价值的单位应该是什么呢？没有单位的东西就无法管理。无法管理，也就无法优化。我们交付的价值是越来越多吗？还是交付的不如以前了？用什么来判断？</p>
<p>回答不了这些问题，不管输赢都是有点不明不白的。这些问题的核心问题就是价值的单位应该是什么？怎么算一个价值？一直没想清楚这些问题，直到我看了我们公司设计团队的一个框架MERLIN，又在《创新的窘境》作者的新书《与运气竞争》里看到了理论依据，这个问题在我这里才算是告一段落。我明白了，以用户为中心的软件开发大概应该怎么做。</p>
<h2 id="方法核心"><a href="#方法核心" class="headerlink" title="方法核心"></a>方法核心</h2><p>如果我们想以用户为中心进行软件开发。那么我们的分析方法应该是围绕着用户展开的。</p>
<p>这个方向倒是不新鲜，一直以来我们在inception的时候做用需求分析时我们的方法就是围绕着用户展开的，一个典型的分析过程，如下图所示。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-01.jpg" alt="用户旅途"></p>
<p>我们会在上面画一条轴，标示出用户旅途。这是用户在使用软件的时候的，他的一个全过程。然后在对应的时间点上，标记出我们的功能。这样我们的功能就不是平白出来的。每一个都联系了用户价值。相对于一般人会更容易理解功能，在ThoughtWorks，我们更多标记的是用户故事。比起功能，用户故事增加了有关价值的线索，因为用户故事首先就是要写出价值。</p>
<p>一直以来我觉得这个图还是不够给力。首先，从用户旅途上的点，到功能的映射这一步，简直是个magic move。对未来的读者来说，并不能很好的传递为什么是这样的一个功能，而不是别的功能？毕竟实现一个用户的价值方法有很多。于是后续在执行的过程当中，难免会僵化行事。</p>
<p>其次，上面的旅途，还可以再抽象和封装。简言之，旅途本身也应该是有抽象层次的。一个旅途上的一个点，可能也是一段新的旅途。</p>
<p>所以现在我觉得，一个更系统的做法应该是这样的，首先做服务设计：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-02.jpg" alt="更宏观的用户旅途"></p>
<p>系统化的分析用户的行为，过程中与企业有哪些触点，在这些触点上，借用《与运气竞争》里的思维框架来讲，用户“雇佣”企业的产品到底是来做什么的，也就是动机有哪些。</p>
<p>然后将这些点再进一步细化，采用故事的模式：<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-03.jpg" alt="故事板"></p>
<p>图上的一行会讲一个故事，就像电影分镜或者漫画一样，来表达用户使用的故事，真正的故事，而不是用户故事那种东西，我们叫这个东西故事板。<br>在故事板上，我们描绘了一个故事，这个故事里，用户获得了一种体验。一个故事对应一个体验。在基本需求都已经得到满足的今天，体验是新的最有价值的事情，以体验为中心才是以用户为中心。故事板恰好给了我们一个非常符合人类认知习惯的方式来描述什么是一个体验。也就回答了开头的问题，什么是价值的单位。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-04.jpg" alt="故事板与用户故事的关系"></p>
<p>当我们定义出了价值的单位，就可以从这一单位的价值里面映射出故事卡，来进行开发过程的管理：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/user-centered-software-development/pic-05.jpg" alt="故事板是MVP的细分"></p>
<p>这里就是我们的重点，我们将来交付的软件、交付的服务、我们交付的一个MVP本质上是交付给了用户一组体验。MVP的迭代则应该是更多的体验或某些旧体验的升级（也就是同一个动机，换了一个不同的故事来满足）。</p>
<p>最终我们把用户的价值很好的表达了出来，并且找到了用户体验的基本单位——故事板，由于故事板也可以转化为用户故事，结合早已经存在的各种敏捷开发方法，也就可以对体验的交付进行度量和管理，达到以用户为中心进行软件开发。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>很早之前我就觉得MVP是TDD思想在产品策略上的延伸，TDD一个很重要的价值就是避免自嗨从而消除浪费。程序员有时候会因为自嗨写出来好多用不到的功能和设计，这些都是浪费。但是程序员能减少的浪费很有限，最终的最终还是要从需求的源头——用户层面来减少浪费才能真的做好。所谓顾客就是上帝，软件开发中用户就是上帝，这句话的意思不是说用户说什么你就做什么，而是说你只有贴近用户，才能得到上帝的启示，现场有神明，就是这么个道理。</p>
<p>有了MVP之后，就像开发有了测试驱动。我们就可以避免很多过度设计。但是MVP作为测试，粒度太大了，不好分析，不好写断言，不能得到精细的反馈。这里我们把它分解到故事板层面，就可以得到精确的测试目标，也就可以做真正精细的测试，真正做到以用户为中心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/dojo-over-method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/dojo-over-method/" class="post-title-link" itemprop="url">道场胜于道法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="能力建设的鬼打墙"><a href="#能力建设的鬼打墙" class="headerlink" title="能力建设的鬼打墙"></a>能力建设的鬼打墙</h2><p>我们为了变强，会订阅很多公众号，牛人博客，收藏很多视频，看很多文章。做了很多松鼠的行为，然而最终大多数人并没有变强。<br>我去看了很多学校，大多数学生面临的成长问题与十几年前并无太大区别。<br>我去看了很多家公司，大多数公司面临的能力问题跟十几年前并无太大区别。<br>十几年前，我们买一台电脑都贵得要死，现在跟一台手机差不多钱了。<br>十几年前，我们想学编程连个像样的教程都没有，现在互联网上的教程不要太多。<br>为什么会这样呢？<br>因为信息的多少，并不是学成才的关键。很多人可能知道我又要说刻意练习了，可是按照刻意练习理论，要练一万小时才能成才。但我们从业者练了不止一万小时了吧，每天996，3年就该1万小时了吧，为啥能力还是个问题呢？<br>因为工作的关系，我不得不思考这个问题，思考的久了，我自己有个理论。我在想，刻意练习把问题过分简化了，学习过程可不是那么简单的，大面上讲，我觉得刻意练习理论是工作的，只是过于粗糙，需要精细化的考虑一下，仔细思考一下刻意练习的背后到底是一个怎样的过程。</p>
<h2 id="刻意练习的元模型"><a href="#刻意练习的元模型" class="headerlink" title="刻意练习的元模型"></a>刻意练习的元模型</h2><p>经过对自己的学习过程进行反观内视，加上跟很多人的交流，我大概抽取了一个闭环的元模型。<br><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/dojo-is-more-important-than-method/pic-01.png" alt="image.png"></p>
<p>我发现首先要有问题供学习者思考，我称之为我思，有些问题比较简单，直接可以思考，有些问题比较难，需要先学习一些基础知识才能理解问题本身，后者就是读书的原因之一。</p>
<p>理解问题之后，就要开始解决问题，毕竟企业里的能力建设都是要解决问题的，必须学以致用。为了能学以致用，那自然就需要练习，但练习不一定是非要专门的练习题，只要将所学知识应用，也算是练习了。练习需要有反馈，知道你做的对还是不对。</p>
<p>经过练习之后，需要对整个过程进行反思、总结，产出经验和洞见。有数据供反思时分析和有反思的习惯是很重要的，我发现傻做的人很多，反思的人很少，真的是大家都在泥坑里，只有少数人会仰望星空。</p>
<h3 id="成才三要素之一——环走通"><a href="#成才三要素之一——环走通" class="headerlink" title="成才三要素之一——环走通"></a>成才三要素之一——环走通</h3><p>按这个环来分析，如果想要成才，首先环要走通。<br>我思的瓶颈在于认知障，所以还是比较简单的，扩大知识面就好了。<br>我做的瓶颈才是最麻烦的，要走通这个环，最难以达成的瓶颈的其实是我做的环节，在互联网时代，你想获得知识已经很容易了，只要你想，你总能找到可以用的知识。<br>但是学到了知识能不能实践其实是关键，你学了大量高并发的知识，但是你工作环境下没有高并发的环境供你练习，你也学不会。你想学软件开发的方法学，却在一个简单机械重复的环境下天天垒那种过些日子就没用处的代码，并不会有所提升。<br>这就是我为什么开始说，道场胜于道法，你没有一个练习场，你学到的知识都卡在第一环节了。<br>然而一个合格的道场本身并不是那么容易具备的，这个我们在后面慢慢讲。</p>
<p>那么在我反思这个环节上，首先你要有反思的习惯，这个是比较反人性的，所以具备的人本就不多。即便你具备了，一个人的认知又容易受自己的偏见蒙蔽，容易看不清事物的全貌。需要老师的启发式引导，同学的研讨印证。一个具备好的老师同学的环境其实是道场的一部分，你所处的环境里根本没人跟你聊这些，你很容易陷到自己的认知瓶颈里很久都不得突破。</p>
<p>其次要有数据供自己反思，不过只要有了这个习惯和意识，数据什么的好搞，比如编程的话，可以参考我的《编程的精进之法》。</p>
<h3 id="成才三要素之二——提高频率"><a href="#成才三要素之二——提高频率" class="headerlink" title="成才三要素之二——提高频率"></a>成才三要素之二——提高频率</h3><p>一旦环走通之后，频率就是我们接下来要面临的问题。<br>一些简单的内容可以通过设计针对性的练习来提升<br>能进行针对性练习的环境就是我们最好的道场，而现实并不是这样的。<br>我当年练习投篮的时候，就发现，如果是自己一个人练的话，不但要投还要捡球。这单位时间内能练习投篮的频率就降低了。<br>等你把投篮练的差不多了，发现在比赛中能投进和练习时能投进有不一样。<br>这对这两种，你要建立两个环境，互相不能偏废，我称之为专项训练的环境和综合训练的环境。<br>在我们教学生编程的时候，就采用了这两种不同的环境，我们会设置一些非常小的练习，针对性的练习结构化编程、集合的处理、数据结构的设计和数据的转换。<br>然后会设计大作业进行这些技能的组合使用，这个时候需求到具体技术的映射是模糊的。<br>最后会设计项目，团队协作做项目，这个时候需求本身也是模糊的，团队成员之间的配合也需要锻炼。<br>前两种都属于专项训练，分别练习的是专项的技术和专项技术的组合，最后一个属于综合训练，锻炼在模糊不确定性下使用确定性的技术来完成需求的能力。</p>
<p>这些良好设计的环境都是为我们和我们的客户的校招新员工设计的，普通员工的日常工作中难以具备这样的环境。<br>那么只需要考虑一件事就好了，我们的日常工作中有多少机会来进行练习。如何改造我们的工作环境来，使之成为个体提升的环境是关键。传说中，少林寺的和尚吃饭睡觉都在练功其实就是在讲这个简单的道理：提高频率必须从环境改造下手。</p>
<h3 id="成才三要素之三——降低废品率"><a href="#成才三要素之三——降低废品率" class="headerlink" title="成才三要素之三——降低废品率"></a>成才三要素之三——降低废品率</h3><p>解决了闭环、频率问题之后，还有一个不得不面对的因素：废品率。<br>在练习过程当中，并不是所有的练习都是有价值的，大量的练习都是无效的，甚至有些是错误的，在反思阶段会产生反模式。<br>随着闭环次数的增多，熟练度就会提升，不但正确的做法的熟练度会上升，错误做法的熟练度也会上升，如果反思阶段思考的不足，还会得到一些既不是正确做法也不是错误做法的纯粹的无效做法的熟练度。<br>这些熟练度都是问题，都是成长过程中的废品，而如何降低废品率，是高段位竞争者之间的胜负手。<br>这个的获得可以靠反思的时候总结，也可以靠阅读实践者的文章书籍。<br>比如如果纯自己摸索可能最后总会获得大泥球的架构，但是如果阅读了DDD之类的文章书籍就能知道可以靠上下文和聚合的方式进行解耦。<br>但是这种实践者写的书籍不像具体的知识那样好懂，通常都是非常抽象的。没有懂行的人指导或研讨，跟看天书也差不多。有时跨过了理解这个坎，又会发现现实环境不允许你进行试验。不管工作流程还是协作方式，从根本上限制了问题的根本解决。（不然问题早就解决了）</p>
<h2 id="道场建设的窘境"><a href="#道场建设的窘境" class="headerlink" title="道场建设的窘境"></a>道场建设的窘境</h2><p>在分析了刻意练习的原模型之后，我们会发现，在今天这个时代，能力建设最大的瓶颈是道场，如何将道场建设起来，比学习知识重要的多，好的练习、好的环境、好的同学比其他的都要重要。</p>
<p>而现实中，最大的道场就是实际工作环境。所以不管能力建设在开始看起来多么人畜无害，由于涉及到工作环境的改造，最终都会影响到组织的改造和调整。想想也是合理的，按照康威定律，什么样的组织架构需要什么样的软件架构匹配，什么样的软件架构需要什么样的能力匹配，如果旧的环境能够提供足够的练习场，那么能力建设根本就不是个问题，既然能力建设是个问题了，那么在能力建设的需求下，现有组织架构必然是要进行改进的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/presepective-of-requirement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/presepective-of-requirement/" class="post-title-link" itemprop="url">需求的视角</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>在我培养学生的时候，我发现一个很有趣的现象，有些人可以非常好的理解需求，并且能发现需求当中的逻辑矛盾，给出非常好的反馈。更多的人，只是听了需求，然后没有任何反应，去做的时候呢，才发现有问题。最可怕的是，明明需求有问题，做的时候他也没发现问题，最后做出来的功能是有bug的。</p>
<p>想起我吐槽一个学生，让你扫马路，你就把土扫到路两边，只管中间干净。跟你说两边也要干净你就把两边的扫到中间，说两边和中间都得干净就在两边和中间的间隔处推上细细的一条垃圾线。</p>
<p>吐槽虽然可以让人很爽，但不能解决问题，只是享受了优越感。作为以能力建设为己任的培养者，这种优越感反而是一种打脸，毕竟学员能做到才是我的成功，他做不到我能做到有啥好优越的呢，让他做到才是我应该追求的优越感。所以我就陷入了深深的思索，到底怎么能让学员把需求理解清楚呢？看着他们，我开始反观内视我自己，我是如何做到的呢？</p>
<p>首先我想到，这个是个场景思考的问题，虽说思考用户场景，很多公司是PO、BA或产品经理的工作，但所谓好的程序员要能顶上半个产品经理，既然我们说是数字人才，每个人都要能理解软件的使用场景才行。我自己就是会拿到需求后，在脑子里重新构建场景。然而道理说起来简单，做起来并不简单，不管我强调多少次，要关注场景，结果也不会好，会的立刻恍然大悟（那种恍然大悟是一种原来我这种做法还有名字的感觉……），大部分不会的人还是那样……</p>
<h2 id="跳出盒子外"><a href="#跳出盒子外" class="headerlink" title="跳出盒子外"></a>跳出盒子外</h2><p>进过长期的观察，我发现他们是在盒子内思考，而跳不出盒子外。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-01.png" alt="跳到盒子的外面，才能发现场景"></p>
<p>什么是盒子内思考呢？比如一支白板笔。</p>
<p>如果我在白板笔的盒子内看的话。我就会看到笔帽，笔芯和笔管。我可能会关注，笔芯是海绵的，笔帽和笔管是塑料的，不是金属的。这样思考就有一个问题等我考虑到颜料的时候，我就不知道应该采用什么样的原料。就必须要问一个问题，这个白板笔是用来干嘛用？因为如果我在盒子里看白板这个东西，对我是没有任何含义的。</p>
<p>那盒子外就很好理解了，同样是描述一支白板笔，我要考虑他，写出来的东西好不好擦。写出来的字迹是否清晰可见？粗细是否适中？能用多长时间？成本是多少是，买一个新的还是加墨水儿更合适？一旦跳到盒子外，我还要考虑多角色比如制造商，分销商，销售终端，买家不同角色看他的视角。小小一支笔，也不是那么简单的。</p>
<p>回归软件开发的上下文，盒子内就是功能视角，比如：学习平台要有写成长日志的功能。盒子外则是业务视角，比如：学员参加了学习后，每天要写成长日志，总结当日所学，练习总结能力，助教要给他们进行检查和反馈。比起前者，后者很容易想到，既然是练习总结能力，是不是应该有模板和范文？</p>
<p>我常试好多的方法，试图让初学者可以跳出盒子外，大部分都没啥效果，不要说初学者不会，很多工作过多年的人也有这类问题，也学不会。也曾一度让我怀疑，这是一种天赋，好在不想对天赋低头的心，最终还是找到了一种实操性很好的方法。</p>
<h2 id="故事线"><a href="#故事线" class="headerlink" title="故事线"></a>故事线</h2><p>我会要求学生画一种图。我们管它叫故事线，是一种场景思维的辅助工具。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-02.png" alt="故事线"></p>
<p>这个工具是这样的用的，每当你要做一个功能，就画一条故事线，在故事线里面，首先你要定义故事起点。这个故事的起点是一个业务动机。比如说一个系统可以创建用户，那么这个创建用户的业务动机是什么呢？我问出去的时候，学生们就会开始思考，想到了说创建用户的业务动机是有一个新人入职了。</p>
<p>有了业务动机，别人才会使用你的系统，否则你的系统只是你的自嗨而已。不要说学生了，很多工作多年的人在设计系统的时候，依然不思考这个问题。有了动机，你也可以去对比各种不同的解决方案，去想有没有更好的解决方案？比如在我们这个例子里，动机就是有人入职了要创建用户，但那么有人入职了之后，谁会来这个系统里面创建用户呢？这就涉及到方案的不同。可能我们定义的角色是hr。也可能我们这是一家小公司，反正就是那么几个人，最后就跟一个系统管理员说一声，他登上来录进去就好了，对于一家小公司来说，这也可以接受，所以你就会发现，这两个都是可行的方案。</p>
<p>我们在实践中发现，有了业务动机这个概念之后，大家就会对场景有更多的思考，也能协作着来对比方案而不是瞎吵架了。</p>
<p>故事线的后面就比较好画了。我们就画他在这个系统里面为了满足他的业务动机，他需要一步一步怎么做的。注意只画成功路径，过程中遇到的异常，先不要考虑。这对很多人来说，也是一个很难做到的事情。</p>
<p>在故事线的最后，需要画出来说，这个故事结束了之后，那么最终，业务的下一个起点是什么？</p>
<p>还是以创建用户为例，当我们为用户创建完了之后，我们的下一步是什么呢？下一步可以试试，发个邮件给用户，也可以是，把用户名密码拷给，我们的新员工本人或者他的经理。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/presepective-of-requirement/pic-03.png" alt="学生做的一个案例"></p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>如前所述，很多人是没有场景思维的，他想问题只能想到这个盒子内，而跳不到盒子外去关注使用它的场景。对于这种情况，我们就算明确的指出，他没有场景化思维，大部分情况下是不会有任何的作用的，大部分人依然没有场景化思维。他就像我《数字人才的刻“意”练习——开篇》里讲到的画画需要关注线条一样，我们需要告诉大家，应该关注在什么地方才会具有场景化思维。那么在这种情况下，我们只需要给他一个非常好的辅助工具，他就真的可以做到跳到盒子外。故事线就是这样一个工具。实践中发现，哪怕是毕业生，几次练习之后也可以快速掌握这种思维方式，更不要说有多年工作经验的程序员。</p>
<p>虽然在我们项目中是有所谓的业务分析师的，但是优秀的程序员一定会在脑子里重建这些场景。如果程序员不能以这样的方式画出来的话，那么程序员做开发的时候也会出现一些问题，比如没有想全，做出来的程序有问题的情况。所以教给程序员自己这么思考问题是非常重要的，在理解完业务分析师传达的需求之后，可以在脑子里把这条线画出来，非常有价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/talk-about-digital-talent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/talk-about-digital-talent/" class="post-title-link" itemprop="url">聊聊数字人才</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>本来是开篇的一部分，结果越写越长，索性就单发了一篇</em></p>
<h2 id="什么是数字人才"><a href="#什么是数字人才" class="headerlink" title="什么是数字人才"></a>什么是数字人才</h2><p>这些年，很多企业都在搞数字化转型，也都非常缺这方面的人才，所以纷纷提出了数字人才的说法。最近似乎都上升到了国家战略的样子：</p>
<blockquote>
<p>（七）强化数字人才教育。深化教育改革，建立健全高等院校、中等职业学校学科专业动态调整机制，加快推进面向数字经济的新工科建设，积极发展数字领域新兴专业，促进计算机科学、数据分析与其他专业学科间的交叉融合，扩大互联网、物联网、大数据、云计算、人工智能等数字人才培养规模。进一步扩大和落实高校专业设置自主权，鼓励高校根据经济社会发展需要和自身办学能力，加大数字领域相关专业人才培养。加强数字人才教育师资力量培养培训，推动实现基础教育、职业教育、高等教育普遍开展数字知识和技能教育，逐步建立健全多层次、多类型数字人才培养体系。加大职业教育数字化资源共建共享力度，加快建设适应数字经济发展的职业教育相关专业教学标准体系，进一步优化中等职业学校信息化相关专业设置。（教育部牵头，发展改革委、人力资源社会保障部按职责分工负责）</p>
</blockquote>
<p>摘自： <a href="http://www.gov.cn/xinwen/2018-09/26/content_5325444.htm" target="_blank" rel="noopener">http://www.gov.cn/xinwen/2018-09/26/content_5325444.htm</a></p>
<p>那到底什么是数字人才呢？其实全世界也没有一个明确的定义，但简单粗暴的说，围绕软件开发的各种角色就算是数字人才。这个定义可以算是满足充分条件的，是否必要就见仁见智了。那我这里就是借用了数字人才这个词来表达，软件的构造者这么一个角色。</p>
<p>废了那么大劲就是说软件开发，那为啥我不说程序员呢？因为角色会限制我们的视野，一旦我说了程序员这个角色，我们就会把自己定义在编码这个视角上，什么需求啊、软件设计啊、组织流程啊，跟我没啥关系，这也恰恰是很多人在职业发展后期遇到瓶颈的原因，怪不得别人，全是自己画地为牢。</p>
<h2 id="数字人才的特点"><a href="#数字人才的特点" class="headerlink" title="数字人才的特点"></a>数字人才的特点</h2><p>软件开发是一个复杂工作，而且是一个复杂的知识工作。复杂就复杂了，这好理解，为啥强调知识工作呢？知识工作有两个特点：</p>
<ol>
<li><p>所有的工作不是正交的，分工不能切的很完美。</p>
</li>
<li><p>效率提升的关键点不是在于对how的回答，而是在于对what的回答。</p>
</li>
</ol>
<p>第一点说的是什么呢？在体力工作者的上下文里，我们是拆成流程来工作的，每个环节的人不需要懂上个环节的知识，做好自己这个环节就好了，你想象一下流水线上的工人，彼此其实只要做好自己的事情就好了，不懂上下游的知识和技能也无所谓。这就是所谓的正交，彼此不需要了解，不了解也互不干扰工作。但知识工作不一样，知识工作固然也是拆成流程来做的，但是知识工作里有个极为重要的动作叫反馈，就是下游接收到上游信息的时候，要告诉上游自己理解了没有、上游的信息哪里是落不了地的等等，尤其在复杂知识工作上下文里，反馈可以说是最重要的事情，没有之一。你想要反馈，你就必须至少需要懂得上游的一个环节的人的部分心智模型，否则反馈也反馈不到点子上。注意，是至少，通常你需要懂得要超过一个环节，因为反馈往往不只跨一个环节，如下图所示：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/talk-about-digital-talent/pic-01.png" alt="知识工作者协作信息流"></p>
<p>如果仅仅是第一点，还不是什么大不了的事情，毕竟大家一起工作，时间久了总能了解自己的上游环节的心智模型，互联网行业里都有好的程序员相当于半个产品经理的说法，问题在于第二点。我们做工作如果只追求按部就班，那就慢慢被竞争对手干掉了，每个企业都是要追求效率提升的。要提升效率就得回答一个问题，到底知识工作者的效率是怎么提升的，所以才有这个第二点，也是彼得德鲁克的观点：知识工作者的效率提升在于对what回答，而不是对how的回答。</p>
<p>什么是对how的回答呢？也就是说在每个环节提问怎么做才能提升效率，每个环节的输入和输出都是固定的，也就是待完成的事情的定义是确定的，只要在这个限制下改变做事的方法，而不用改变事情本身的定义。</p>
<p>而知识工作者的效率提升是一个纵观全局后的颠覆性优化，也就是所谓的颠覆性创新。这个颠覆性往是通过跨环节跨角色来产生的，比如最早敏捷里的技术实践，把测试引入了开发环节，把构建也引入了开发环节，而管理实践也是把验收提前，改变了对交付的定义，后来的DevOps则强调打破Dev和Ops的壁垒，都带来了极大的效率提升。一旦跨了环节跨了角色，那么输入输出都会变，事情本身的定义也就变了，我们需要经常拷问自己到底解决的问题是什么，改变了要解决的问题的定义，所以称之为对what的回答。</p>
<p>一旦问题的定义发生了变化，进而我们甚至要反复拷问自己到底什么是效率，比如，我们的效率到底指的是有100个需求，我们以最短的时间做完了，还是说用户或客户当有一个需求出现，我们可以用最短的时间满足它呢？一旦效率的定义发生变化，整个生产体系都会产生颠覆性变化，也就是我前面提到的颠覆性优化，而且因为这些颠覆性优化往往是局部劣化却达到了整体优化，有时连旧的评价体系都给颠覆掉了，导致按照旧的评价体系来看，新的方法可能还是很糟糕的，在看不到全局的人眼中看来，只会看到颠覆性看不到优化从而产生抵触，这都是正常的。可以说，如果没有抵触发生，都算不上颠覆性优化。</p>
<p>由于知识工作自身的这些特点，软件开发又比一般的知识工作还要复杂，我们觉得数字人才必须是一种多视角人才，这其中至少有三大类视角：商业视角、技术视角和用户视角：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/talk-about-digital-talent/pic-02.jpg" alt="描绘软件的三个视角"></p>
<p>所以这个系列文章不会只讲某一种角色的视角，我希望通过这系列文章培养出多视角的人才，所以在标题中淡化了某一种角色的强调，尽管出于我的技术出身，难免技术部分会重一些，最后写出来的数字人才的技术部分的刻意练习会多一些，不过我想也是对读者有价值的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/deliberate-practice-for-digital-talent/what-worth-to-be-recited/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/deliberate-practice-for-digital-talent/what-worth-to-be-recited/" class="post-title-link" itemprop="url">什么值得背</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一个蹒跚学步场景的启发"><a href="#一个蹒跚学步场景的启发" class="headerlink" title="一个蹒跚学步场景的启发"></a>一个蹒跚学步场景的启发</h2><p>我们家娃最近在学钱的加减，几元几角减去几元几角等于多少这种问题。在这之前，她已经学会了加减法借位等基本数学知识，但做钱的加减还是不行。</p>
<p>个位的元角减去个位的元角没问题，比如7元8角减去5元9角这种没问题。但是这个10元5角减去8元6角这种题目，他就不会借位了，因为她理解的借位只会像一位数借位，10元这个不是个位数，所以总是算错。</p>
<p>我给她讲道理呢，她就说：听不懂……</p>
<p>这就尴尬了，怎么讲他都不会，那就用我的老招数呗，刻意练习，我自己出了几道类似新题，让她练，还是经常算错。有趣的是，也不是每次都不对，有点六脉神剑时灵时不灵的感觉。仔细观察了一下发现呢，竟然是做过的她背过了一部分表象，比如10元减8元要借位怎么借她背过了，但出的新题里，有的题借位有的题不借位，所以就时而对时而错，不过这道理给小孩子讲了没用……</p>
<p>这种场景我在教毕业生学写程序时候也遇到过，有些学员多做几道题自己就悟出来了，好像开窍了一样；有些学员就背过一些表象，于是就六脉神剑时灵时不灵了。因为编程比元角计算可复杂多了，所以一直也不知道怎么破这个局。</p>
<p>如今这个场景又出现我眼前，以一种噪音更少的方式出现了，我依然不能通过多做同类题目的方式解决，这说明这个方向是彻头彻尾错误的。</p>
<p>最后我没招了，我说，来，我把我怎么解题的说一遍，你背下来。我其实也不知道为啥我要这样干，就是个脑子里突然闪过的想法，纯粹死马当活马医吧。</p>
<p>于是我就说，10元5角减8元6角这个题我是怎么解的呢，我们的计算规则是元减元，角减角，但因为5角减不了6角，所以要跟10元借一位，借完之后呢，10元就变成了9元，5角就变成了15角，然后15角减6角得到9角，9元减8元得到了1元，所以最后答案是1元9角。</p>
<p>我就让她背，背的时候，她就在借位环节问问题了，我也解答了问题，全部过程能背下来之后，她就好像突然开窍了一样，换几个题都会了。</p>
<h2 id="背后的“原因”"><a href="#背后的“原因”" class="headerlink" title="背后的“原因”"></a>背后的“原因”</h2><p>这神奇结果让我很意外，赶紧分析了一下，为什么给这个实践会起作用。我感觉，大约的原因是，初学者由于领域知识的缺乏，他对于自己为什么不会这事是缺乏语言描述的。甚至于她到底哪个点不会都说不出来。说不出来就是在瞎做，算不得刻意练习，刻意练习非常强调针对性的专项训练，知识工作者真正需要锻炼的是大脑里思考问题的方式，只是做题，如果思路不对的话（比如中间某几步是蒙的），那真正欠缺乏锻炼的部分根本没锻炼到。但找到这个点很难，因为问题往往是隐藏在思考过程中的。</p>
<p>之前的实践恰恰可以针对这个问题产生影响，我给这个实践起了一个名字，叫背诵解题思路。这两个词拆开正好就是我们这个实践的两个关键点，一就是背诵，如果我们只是听一遍解题思路，会出现听起来很有道理觉得自己学到了东西但实际什么都没带走的情况，跟不明觉厉也没差多少。大家都可以自己测试一下，听起来很清楚的道理自己背一遍总会在某个地方卡壳，那个地方可能就是我们需要锻炼的点。</p>
<p>另一个关键点就是解题思路，这就贴合了我们的标题，什么值得背。我们在谈到教学总会比较迷信所谓循循善诱，觉得死记硬背是不好的（都市传说，背诵会扼杀创造力）。但其实记忆是一切的基础，只是要明确，我们记忆的目的是为了什么？最终的最终是为了应用，为了改造世界。我们经常背一些知识点，定理定律规则，这些东西都是死的，不能改造世界，而较少被人关注的解题思路，尤其是高手的解题思路才是改造世界的出路。人跟人思考的过程差异之大是令人乍舌的，有时即使看起来很简单的题，你看一下高手的解题思路，都会发现很大差别。各行各业的高手都是类似的，之前看过科比的一档节目，叫细节，看完之后才知道，运动员在运动场上处理的信息量有多大。</p>
<h2 id="对程序员的价值"><a href="#对程序员的价值" class="headerlink" title="对程序员的价值"></a>对程序员的价值</h2><p>这个实践对于我们程序员有什么价值呢？在编程中，有很多问题是没有标准答案的，比如任务分解、比如软件设计等，前面说的需要学生开窍的场景其实都属此类。虽然没有标准答案，但是我们又想提高自己，就只能去学习高手的解题思路。其实，很多工程实践已经是把高手的做事方式讲给我们听了，但做的时候他们脑子里是怎么想的呢？这只有在自己做的时候自己摸索。而这个自己摸索的过程通常效率是很低的，会有很多只得其形不得其神的情况。这对团队中带人的人，像我这样需要教人工程实践的人都要面临的一个困境，很难大规模的培养出优秀的程序员。究其原因可能有很多，但魔鬼一定是隐藏在细节里，现在我觉得背诵解题思路可能是一个解。怎么解呢？</p>
<p>举个例子，工程实践中，tdd是最难学的一个，tdd就是高手的做事方式。最近在参与熊节的tdd练功房，有位同学就第一道最简单的题写了自己的解法：<br><a href="https://www.jianshu.com/p/13d7a0a0e5be" target="_blank" rel="noopener">https://www.jianshu.com/p/13d7a0a0e5be</a></p>
<p>这个解法到了后面有点过度设计，但本题练的是编程的手艺，所以重点在过程中的细节，那一个个细小的步骤，我敢说是很多程序员会忽略的。</p>
<p>再举个例子，面向对象封装继承多态，最难的就是封装。我们最近出了一道重构的题目给某公司，在重构的过程中要把分散的基本数据类型的数据封装成对象。分散的数据如下所示：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/what-worth-to-be-recited/pic-01.png" alt="充满坏味道的代码"> </p>
<p>这个能力其实是最难锻炼的，上面这些数据谁跟谁应该封装在一起，谁跟谁不应该。这也属于没有标准答案的问题。作业结果也证明了这一点。怎么办呢？同样，可以试着背一下高手的解题思路。（想知道这个题的思路吗？等我后面的文章，没错这里是广告）</p>
<p>综上，对于一些实践类的内容，总是会出现不管怎么练也不开窍的情况，比如如何高效的TDD，比如软件设计。这个时候，大家可以试试让被教授的人背诵一下解题思路，说不定会有效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/marsrover-tdd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/marsrover-tdd/" class="post-title-link" itemprop="url">练功房MarsRover讲解（初稿）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="聊聊集成"><a href="#聊聊集成" class="headerlink" title="聊聊集成"></a>聊聊集成</h2><p>从业务域角度看集成，首先要定义什么是单元，传递一个命令就是单元，。</p>
<p>那么，在这个领域里，我们的测试应该有多少个呢？</p>
<p>首先，要看我们有多少个变化因子，marsrover面向的四个不同方向状态在接受三个命令时的处理是不一样的。所以四乘三共有12个case。这些都是单元测试。测试的是单个命令的场景。</p>
<p>接着需要考虑场景之间的联动，也是一种集成测试。那你可能需要发带有几个命令的字符串，看看结果是不是对的。</p>
<p>happy path完了，再考虑一下异常分支，没发送命令是一个case，发送了不支持的命令也是一个case。后者好像没说要怎么处理呢，记得澄清。本文就不深入聊这些细节了。</p>
<p>另外，由于本题没有提出最大长度问题，这个我们可以先不测，但是这个是个技术原因必须限制的数字，毕竟单批量发送还是不限制不行的。根据我们上一篇，在实际工作中一定要探讨这个问题，并明确在规格上发布给使用者，不要脑补，如过业务方确实无所谓，就由我们提出一个数字，双方都认可了，放在一个地方。</p>
<p>而在方案域，集成则有不同的含义。不同的设计也会需要不同的集成测试。</p>
<p>先说分层，我会把与外面交互的部分划为一层，也就是把“0 0 N”和“MLRR”之类解析成领域概念的为一层。</p>
<p>解析完之后处理核心业务逻辑的部分再分一层，靠main或XXController之类的调度。</p>
<p>那么这两层的集成呢就是方案域的集成测试了。不过这个时候，你会发现，解析的部分单独测，解析出来的结果执行的部分单独测，最后他们集成起来的部分只需要mock测试测一个用例就好了。</p>
<p>不但测试简单了，扩展其实也会简单，这样我们将来如果命令发生变化比如，开始这么写命令 “M2 L R”也就是移动的时候加入了数字控制移动多少格，为了好解析，我们加入了空格来分隔。这种变化对于执行的来说，并无感知，因为这个变化悲伤层负责解析的部分已经隔离掉了。</p>
<h2 id="聊聊设计"><a href="#聊聊设计" class="headerlink" title="聊聊设计"></a>聊聊设计</h2><p>这个题一开始，很多人肯定是一大串if来解决3个command的if和四个方向的if。</p>
<p>写完之后呢，就会开始重构，重构成什么样子的就都有了，比如下面这个：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/marsrover-tdd/pic-01.jpg" alt="image.jpeg"></p>
<p>这个重构完，通常if就没有了。</p>
<p>但是有很明显的循环依赖，所有人都能改MarsRover，这封装性也太差了。那我们提取一个数据传输对象来提升一下封装性吧，像下面这样：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/marsrover-tdd/pic-02.jpg" alt="image.jpeg"></p>
<p>这么做循环依赖貌似少了，封装性也提高了，但Direction和RoverStatus还是有个循环依赖，进一步消除一下试试：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/marsrover-tdd/pic-03.jpg" alt="image.jpeg"></p>
<p>终于，所有的循环依赖都干掉了，但这图看着好复杂啊而且有个问题，那就是Command和DIrection严重耦合，Direction的三个方法明显是Command的延伸，每加一个Command，Direction脱不了也要加个方法。这个设计肯定是不好的。我们可以发现DirectionValue实际上是可以不知道Move的相关概念的，方向之间自然的有左右关系，所以可以改造成这样的设计：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/marsrover-tdd/pic-04.jpg" alt="image.jpeg"></p>
<p>每个DirectionValue都有一个index，左转可以通过+3然后%4的方式完成，右转可以通过+1然后%4的方式完成，不需要外面的其他概念，实现也很简单。</p>
<p>这下貌似清静了，但实际上Move这个Command里面有四个if还是不好消掉，如果因此搞四个新的子类，会有点啰嗦。这个时候如果采用函数式的方式，把DirectionValue的四个值和对应的移动算法用一个Map封装起来，其实就比较简单了。</p>
<p>这个题做到这，可以加入一些新需求，比如：</p>
<p>新需求1，加一个新指令，如果接受到B指令，那么久会进入倒车状态，这个时候M跟正向的时候是反的。注意，指令的操作虽然反了，但是朝向不能变。比如朝北的M之后，y坐标是减了，但是朝向必须还是北。</p>
<p>新需求2，有一个雷达功能，执行完判断一下自己是不是掉沟里了，如果掉沟里了，就再map上打个记号X（只是表达这个意思，不一定非要是字符串X），后面的rover会忽略走向这个记号的命令（当火星车掉到沟里时，调用init方法创建一辆新的火星车，但旧的火星车还要在沟里，不能消失）。判断无法动的方式目前先用随机数吧，正好练练mock。</p>
<p>新需求3，地图有不同的地形，有的地形能触发无法移动，有的不能。掉沟里是火星车自己在地图上打的标记，不同地形是火星车在来到火星时就知道的地图信息（考虑，X标在哪？真实的地图上吗？真实的世界的映射的地图，和标记了X的地图应该是个什么关系？）</p>
<p>新需求4，车也有状态，有的状态，车会忽略一些指令，比如左转坏了，会忽略左转指令</p>
<p>新需求5，车还分类型，比如Bus，占两格，他的坐标是车头的坐标，但是它左拐时周边必须有可以拐的空间（右侧两格都不能是X），否则会忽略掉指令。</p>
<p>Bus可能会在拐弯时坏掉，</p>
<p>引入卡车，卡车占两格，不同于Bus的是，卡车如果车头处没有坏掉，可以接受特殊指令来脱钩车头，其他车接受这个指令无反应。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-03/" class="post-title-link" itemprop="url">像机器一样思考（三）—— 穷尽就是力量</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过前两篇的内容学习，我相信大家已经差不多学会了这个思考模型。本篇的重点是用它来解决更复杂的问题。当我们开始解决一些稍微复杂点的问题的时候，我们会发现差不多的态度是不行的，我们需要严谨的态度进行缜密的思考才能真正发挥出这个思考模型的力量。</p>
<p>慢慢你会发现，这个思考模型本身不会让你思维缜密，而思维缜密了才能用好这个思考模型。它带来的最大的好处，是让你自己开始看到自己思维的欠缺，从而不再是个思维世界的盲人。</p>
<h2 id="穷尽"><a href="#穷尽" class="headerlink" title="穷尽"></a>穷尽</h2><p>那么，我们开始做点复杂的题目。也没复杂多少，我们扩展一下上一篇的题目，算学生的成绩单：</p>
<p>打印所有人的成绩单。已知输入的格式是</p>
<blockquote>
<p>[“学号”, “学号”, “学号”]<br>比如：<br>[“TWA20160101”,  “TWA20160102”, “TWA20160103”]</p>
</blockquote>
<p>我们有一个全局函数可以给我们提供所有的学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function loadAllScore()&#123;</span><br><span class="line">    return [&#123;</span><br><span class="line">        name: &quot;张三&quot;,</span><br><span class="line">        id: &quot;TWA20160101&quot;,</span><br><span class="line">        chinese: &quot;95&quot;,</span><br><span class="line">        english: &quot;80&quot;,</span><br><span class="line">        math: &quot;95&quot;,</span><br><span class="line">        programming: &quot;80&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要求打印出成绩单类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名|数学|语文|英语|编程|平均分|总分 </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">张三|75|95|80|80|82.5|330</span><br><span class="line">李四|85|80|70|90|81.25|325</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">全班总分平均数：xxx</span><br><span class="line">全班总分中位数：xxx</span><br></pre></td></tr></table></figure>

<p>仅对这个题目进行划分，我们一定觉得很简单，对吧。就仿照着之前的写呗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#1 生成成绩单view model</span><br><span class="line">输入：</span><br><span class="line">  studentIds: [String]</span><br><span class="line">输出：</span><br><span class="line">  scoreSheet: &#123;</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">#2 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">  scoreSheet</span><br><span class="line">输出：</span><br><span class="line">  result: String</span><br></pre></td></tr></table></figure>

<p>我相信很多人都是这么想的，然而不幸的告诉这么想的同学，这种写法是错误的。原因其实也很简单，请问，#1输出里的chinese等成绩是怎么得到的呢？没有来源吧？你说你调了<code>loadAllScore</code>函数？那为什么不写在输入里呢？</p>
<p>所以说，我们遗漏了一些输入。回到我们开始的标题上：穷尽。</p>
<p>可能有很多人听说过一个分析问题的基本原则：完全穷尽，各自独立。很多人听到这个时候，会很困惑：穷尽什么？独立什么？经过我们这些练习，我相信在编程领域，你们这个困惑会小很多。</p>
<p>所谓各自独立，说的就是在我们划分任务的过程中，每一个任务都对应一个代码块或一个函数，这些代码块和函数，是互相不包含的（不是不依赖，这是翻译的问题，各自独立的独立指的是Exclusive不是Independent）。</p>
<p>所谓的完全穷尽，说的是我们需要穷尽这个代码块或函数里所有的输入和输出。不能遗漏任何一个输入，任何一个输出。我们的每一项，它的属性，也不能有遗漏，我不能说分析<code>studentScores</code>只想到部分属性，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">studentScores:[&#123;</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure>

<p>这样是不行的。如果我们不严于律己穷尽所有的数据项，我们就会在写代码的时候遇到各种问题。能否穷尽与否，也看出来你思维的缜密与否。</p>
<p>是不是开始感觉到麻烦了，刚开始做的时候是有些慢的，但我们坚持穷尽这个好习惯，就会渐渐的感受到自己能力的成长。如果你穷尽了所有的输入输出，那么各种可能遇到的问题就像是如来佛手里的孙猴子，无论有什么变数也尽在你掌握之中了。</p>
<p>那么如果我们穷尽输入输出的话，我们这个题目真正的任务应该怎么分解呢？可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#1 获得学生成绩</span><br><span class="line">输入：</span><br><span class="line">    studentIds: [String]</span><br><span class="line">    studentInfo: [&#123;</span><br><span class="line">        id: String,</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">    &#125;]</span><br><span class="line">输出：</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">#2 计算总计</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">输出：</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#3 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">    summary</span><br><span class="line">输出：</span><br><span class="line">    result: String</span><br></pre></td></tr></table></figure>

<p>可能你会奇怪，为什么会分成3步呢？或者说，我们该怎么判断分几步呢？这其实没有一个标准答案，我建议初学者尽量步子小一点，多分几步，经验丰富的人就可以步子大一点。不过有一个反直觉的经验可以分享给大家，你步子大了，开发速度不见得快，因为人是会犯错的。</p>
<p>这个题是写出来了，但是我们还是不太清楚怎么穷尽对吧。说是穷尽输入输出，到底输入输出都有多少大类呢？这个也是可以穷尽的。</p>
<p>输入总共有下面几大类：</p>
<ol>
<li>参数</li>
<li>读取全局变量</li>
<li>调用全局函数后得到的返回值</li>
<li>读取局部作用域变量（比如this）</li>
<li>调用局部函数后得到的返回值</li>
<li>hard code的数据</li>
</ol>
<p>输出总共有下面几大类：</p>
<ol>
<li>返回值</li>
<li>修改全局变量</li>
<li>调用全局函数时传的参数</li>
<li>修改局部作用域变量（比如this）</li>
<li>调用局部函数时传的参数</li>
</ol>
<h2 id="来去"><a href="#来去" class="headerlink" title="来去"></a>来去</h2><p>听起来不错，不过从哪来，到哪去，还是要写清楚的，我们的studentInfo从哪里来？我们的result又到哪里去了？加上这个来去，我们最终的版本是长这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#1 获得学生成绩</span><br><span class="line">输入：</span><br><span class="line">    studentIds: [String]</span><br><span class="line">    studentInfo: [&#123;</span><br><span class="line">        id: String,</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">    &#125;]: loadAllScore()</span><br><span class="line">输出：</span><br><span class="line">    studentScores:[&#123;</span><br><span class="line">        name: String,</span><br><span class="line">        chinese: String,</span><br><span class="line">        english: String,</span><br><span class="line">        math: String,</span><br><span class="line">        programming: String,</span><br><span class="line">        average: String,</span><br><span class="line">        summary: String</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">#2 计算总计</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">输出：</span><br><span class="line">    summary: &#123;</span><br><span class="line">      totalAverage: Number,</span><br><span class="line">      totalMidden: Number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#3 打印成绩单</span><br><span class="line">输入：</span><br><span class="line">    studentScores</span><br><span class="line">    summary</span><br><span class="line">输出：</span><br><span class="line">    result: String: console.log()</span><br></pre></td></tr></table></figure>


<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>引入加分策略<br>少数民族 +10分<br>体育特长 +20分<br>艺术特长 +15分</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>好像输入和输出的可能性太多了，这很容易让人乱啊。<br>是这样的，所以为什么到了函数式编程我们需要强调纯函数，只有一个输入来源和一个输出去处，一般来讲就是输入只有参数，输出只有返回值。所以你看，如果你把一个领域都穷尽掉，你也会自己发明出那些靠谱的实践，换句话说，如果你能在用这套思维模型的过程中逐渐发现跟各种最佳实践都很容易配合使用，那就对了。（其实也不是什么配合使用，因为它跟代码是等价的，所以容易写代码的方法就容易用它，这是当然的。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-04/" class="post-title-link" itemprop="url">像机器一样思考（四）—— 一图抵千言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【旧文搬家】<br>当我们把一个完整的功能拆解为一个个输入输出穷尽，互相独立的任务后，它是容易转化为代码了，可是这种方式并不容易思考规模更大的问题（光从哪来到哪去就够我们绕的）。把我们的大脑看成一台电脑，我们就是那种内存很低的电脑，问题规模一大，我们就会死机，然后就只能重启了。具体表现为我们思考时会觉得晕。每次晕的时候可能都重启了一下:)。</p>
<p>怎么办呢？其实也很简单，内存不够硬盘来凑。对我们的大脑来说，最常见的“硬盘”就是纸。而正如电脑的硬盘传输速度总是不如内存的，加了硬盘计算效率不一定快。我们需要一种对传输友好的编码方式，这种方式就是画图。</p>
<h2 id="画图的规则"><a href="#画图的规则" class="headerlink" title="画图的规则"></a>画图的规则</h2><p>我们的画图方法受时序图启发而发明，具体的规则如下：</p>
<ol>
<li>本图基本元素由方块和带箭头的线组成</li>
<li>一个方块只代表一个函数或一个代码块，通常是函数，方块中可以写字，可以表达函数是属于哪个类或哪个实例等信息。</li>
<li>指向方块的线代表该函数的输入，背离方块的线代表函数的输出。</li>
<li>数据流动的时间轴遵守先从左到右，再从上到下的顺序。</li>
<li>每一对输入输出（输入在上，输出在下）加一个方块，表达了一次函数调用。</li>
</ol>
<p>举例：<br>比如下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function c()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>画成图是这个样子的</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-01.png" alt=" function call"></p>
<p>在这个图上我们可以清晰的看出来，函数a调用了函数b，函数b调用了函数c。而函数a自己，是在最顶层调用的，也就是所谓的程序入口。<br>整张图是从左往右表示时间顺序。</p>
<p>什么情况下既有从左到右，也有从上到下呢？比如下面这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">    &#x2F;&#x2F; b codes</span><br><span class="line">&#125;</span><br><span class="line">function c()&#123;</span><br><span class="line">    &#x2F;&#x2F; c codes</span><br><span class="line">&#125;</span><br><span class="line">function a()&#123;</span><br><span class="line">    b();</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    c();</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数a先调用了函数b，然后再执行一段a里面的代码，再调了函数c，然后再执行了一段a里面的代码，然后返回。</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-02.png" alt=" a call b+c "></p>
<h2 id="正常的使用方式"><a href="#正常的使用方式" class="headerlink" title="正常的使用方式"></a>正常的使用方式</h2><p>我们正常使用这个实践的时候，这个过程是反过来的，我们可能先看画出了上面这张图。不过这回，我们要画的认真一点，为了后面可以导出任务列表，我需要加上标号，如下图：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-04/pic-03.png" alt="(a-b)+(a-c) with detail"></p>
<p>然后从这张图里按照标号导出任务列表，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1 函数a</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line"></span><br><span class="line">#2 函数b</span><br><span class="line">输入：</span><br><span class="line">    paramY: TypeY</span><br><span class="line">输出：</span><br><span class="line">    cValue: TypeB</span><br><span class="line"></span><br><span class="line">#3 函数c</span><br><span class="line">输入： </span><br><span class="line">    paramZ: TypeZ</span><br><span class="line">输出：</span><br><span class="line">    aValue: TypeC</span><br></pre></td></tr></table></figure>

<p>然而这里有个问题，对于<code>函数b</code>和<code>函数c</code>来说，输入输出倒是很正确，对于<code>函数a</code>来说，难道<code>函数b</code>和<code>函数c</code>的返回值不是它的输入吗？相应的，<code>函数b</code>和<code>函数c</code>的参数也是它的输出。</p>
<p>所以真正完善的IO是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#1 函数a</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">    cValue: TypeB: 函数b</span><br><span class="line">    aValue: TypeC: 函数c</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line">    paramY: TypeY: 函数b</span><br><span class="line">    paramZ: TypeZ: 函数c</span><br><span class="line"></span><br><span class="line">#2 函数b</span><br><span class="line">输入：</span><br><span class="line">    paramY: TypeY</span><br><span class="line">输出：</span><br><span class="line">    cValue: TypeB</span><br><span class="line"></span><br><span class="line">#3 函数c</span><br><span class="line">输入： </span><br><span class="line">    paramZ: TypeZ</span><br><span class="line">输出：</span><br><span class="line">    aValue: TypeC</span><br></pre></td></tr></table></figure>

<p>写出的代码大概如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">    &#x2F;&#x2F; b codes</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function c()&#123;</span><br><span class="line">    &#x2F;&#x2F; c codes</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function a()&#123;</span><br><span class="line">    let bValue &#x3D; b(paramX);</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    let cValue &#x3D; c(paramZ);</span><br><span class="line">    &#x2F;&#x2F;a codes;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在在真正的工作中，<code>函数b</code>和<code>函数c</code>这样的函数是非常少的，大部分都是<code>函数a</code>这样既被调也调别人的函数。如果每一个都按照这样去切分，恐怕就不是一个高效的方法了，即便列出来也很乱。不但不能帮助思考，反而会阻碍思考。</p>
<p>当按照模块的角度去拆分task不work的时候，我们就要按照测试的角度来切分task了，这个思维的切换是TDD的核心。我们需要按照测试的视角来切分任务，从一个函数的实现视角转为一个函数的调用视角。</p>
<p>这样做的好处有三个：</p>
<ol>
<li>封装复杂性，当我们按照模块去拆分的时候，如前文所说，复杂性会变高，思考负担会加大。而按照测试的视角来切分呢，复杂性当然不会消失，但是被封装了，方便我们在分析的时候减少思考负担。</li>
<li>跳出盒子外来看盒子的视角。我们在画前面的图的时候，实际上是在我们要实现的这个程序内在看，完全没有使用者的视角，也就是所谓的在盒子内，。当我们站在测试的视角看的时候，我们就跳出了盒子外，他更容易让我们发现哪里可能设计上有问题，比如设计出的接口是不是好用。</li>
<li>在ThoughtWorks，我们有一个观点：叫做任务不是步骤。当我们按步骤来考虑问题的时候，对怎么算做完这个问题的答案往往是模糊的（往往只落在行为上，而不是结果上）。当我们只考虑函数实现的时候，也会有类似的问题，因为一个数据类型包含的情况太多了，想到某种类型的数据我们就会停止思考当前问题转而去想其他问题，于是我们很容易漏掉一些情况，以测试角度看待任务会让我们更容易看清楚我们的工作是不是真的做完了。</li>
</ol>
<p>最棒的是，我们可以照着任务列表写出测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;test case 1 for function b&quot;, () &#x3D;&gt;&#123;</span><br><span class="line">    let paramX &#x3D; &#x2F;&#x2F; TypeX的测试数据</span><br><span class="line">    </span><br><span class="line">    let actualBValue &#x3D; b(paramX); &#x2F;&#x2F; 调用b函数的实际返回值</span><br><span class="line">    </span><br><span class="line">    let exceptedBValue &#x3D; &#x2F;&#x2F; 调用b函数的期望的返回值</span><br><span class="line">    expect(actualBValue).is(expectedBValue); &#x2F;&#x2F;断言</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以此类推...</span><br></pre></td></tr></table></figure>

<p>所以，我们是在以测试驱动的方式做任务划分，你可以叫它测试驱动的任务切分。</p>
<p>如果要映射到测试，我们的任务列表就缺了一些东西，那就是所谓的测试用例。因为同一个函数可能有不同的测试用例，所以加上用例我们的任务列表应该长成这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1 场景一</span><br><span class="line">输入：</span><br><span class="line">    paramX: TypaX</span><br><span class="line">输出：</span><br><span class="line">    bValue: TypeA</span><br><span class="line">测试用例:</span><br><span class="line">    用例1：</span><br><span class="line">        inputValue1</span><br><span class="line">        ----</span><br><span class="line">        outputValue1</span><br><span class="line">    用例2：</span><br><span class="line">        inputValue2</span><br><span class="line">        ----</span><br><span class="line">        outputValue2</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; 以此类推...</span><br></pre></td></tr></table></figure>

<p>我们看到因为输入输出的顺序已经定好了，为了书写的速度，我们就省略了名字。如果你觉得不舒服也可以写上名字。如果你觉得这样太浪费时间，你可以把每组用例用一句话描述。毕竟一切为了实用嘛。</p>
<p>是不是感觉后面讲的很抽象啊，不知道具体怎么做啊？不要着急，后面有例子。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>请把上一篇的任务列表，画成图</li>
<li>试着按照测试用例的方式画，没有思路可以阅读完第五篇和第六篇再来画。</li>
</ol>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="题外话-1"><a href="#题外话-1" class="headerlink" title="题外话-1"></a>题外话-1</h3><p>视角的切换对于软件开发来说是至关重要的一个能力。为了说明这个的价值，我们甚至发明了一个概念——数字化人才</p>
<p>然而大多数人都不具备，所以对于大多数人来说，具备这个能力，最起码的好处就是变成了一种稀缺性人才，对于获得高薪是有帮助的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/programmer-dojo/thinking-as-a-machine-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/programmer-dojo/thinking-as-a-machine-05/" class="post-title-link" itemprop="url">像机器一样思考（五）—— 第一个应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:01:09" itemprop="dateCreated datePublished" datetime="2020-01-30T10:01:09+00:00">2020-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过前面四篇，我们已经具备了最基本的思考编程的能力。我们开始做一个真正的应用吧。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>我们现在做一个应用，该应用是一个命令行应用。当程序启动的时候，我们会看到一个命令行的主界面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加学生</span><br><span class="line">2. 生成成绩单</span><br><span class="line">3. 退出</span><br><span class="line">请输入你的选择（1～3）：</span><br></pre></td></tr></table></figure>

<p>如果我们输入1，那么界面就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入学生信息（格式：姓名, 学号, 民族, 班级, 学科: 成绩, ...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果输入格式不正确，就返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请按正确的格式输入（格式：姓名, 学号, 学科: 成绩, ...）：</span><br></pre></td></tr></table></figure>

<p>如果输入格式正确就会返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生xxx的成绩被添加</span><br></pre></td></tr></table></figure>

<p>然后打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加学生</span><br><span class="line">2. 生成成绩单</span><br><span class="line">3. 退出</span><br><span class="line">请输入你的选择（1～3）：</span><br></pre></td></tr></table></figure>
<p>等于回到了主界面。<br>如果我们在主界面输入了2，那么界面就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的学生的学号（格式： 学号, 学号,...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果我们输入的不正确，就会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请按正确的格式输入要打印的学生的学号（格式： 学号, 学号,...），按回车提交：</span><br></pre></td></tr></table></figure>

<p>如果输入的格式正确，则会打印成绩单并回到主界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成绩单</span><br><span class="line">姓名|数学|语文|英语|编程|平均分|总分 </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">张三|75|95|80|80|82.5|330</span><br><span class="line">李四|85|80|70|90|81.25|325</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">全班总分平均数：xxx</span><br><span class="line">全班总分中位数：xxx</span><br></pre></td></tr></table></figure>

<p>如果我们输入的学号不存在，该学号在计算时就会被忽略。</p>
<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>这个题目比之前的复杂一点，我们可以先按照功能简单列一下任务列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1 打印主菜单</span><br><span class="line">#2 添加学生成绩</span><br><span class="line">#3 生成成绩单</span><br><span class="line">#4 退出</span><br></pre></td></tr></table></figure>

<p>然而这个列表是跟我们的程序不等价的。我们还是应该列出跟程序等价的任务列表。为了便于表达，我们就需要画图。我们先不考虑面向对象，直接面向过程的划分，我们画出来的图大概是下面这个样子：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-05/pic-01.png" alt="image"></p>
<p>也许你觉得这个做法并不够好，我也这么觉得，那我们可以重构这个图，画出一种更好的解法：</p>
<p><img src="https://personal-blog.obs.cn-north-4.myhuaweicloud.com/thinking-as-a-machine-05/pic-02.png" alt="image"></p>
<p>可以看出，这两种做法，在图形上看并没有明显的区别，但是命名上暴露出了思路的不同，后者明显减少了程序对外输入输出的次数。所以不要随便命名。<br>但如果没有上面那个图，我们是看不出来buildReport这个函数他打印了还是没打印，这就需要我们有一套约定俗成的用语规范，从用语规范中可以看出来我们到底做了什么。</p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol>
<li>针对两张图，分别列出所有的任务。</li>
<li>在脑中模拟一下，如果测试先行的方式写代码，两种实现的时间花费各会是多少。按照任务列表逐项估出时间，并比较两种实现的时间差异。</li>
</ol>
<h2 id="题外话-1"><a href="#题外话-1" class="headerlink" title="题外话 - 1"></a>题外话 - 1</h2><p>对于接触本文章的编程初学者，我需要多说几句：我们可以看到，其实一个真正的应用也是由一些简单函数构成的，那就说明编程思想和技巧并不受限于应用的表象。前端、后端、应用、系统之类的名词，往往是从分工的角度来讲的，如果从个人发展的角度来讲，不要拿这些名词限制自己。这也是我们这个系列只讲一些简单应用的缘故，抽象来讲思路是一样的。</p>
<h2 id="题外话-2"><a href="#题外话-2" class="headerlink" title="题外话 - 2"></a>题外话 - 2</h2><p>到这里，你应该能感觉到我们这些题目，其实是一个个思维训练，对于这个思维训练，最重要的事情有三点：</p>
<ol>
<li>语文问题（用词精确，前后一致）</li>
<li>接口问题（完全穷尽）</li>
<li>每个函数之间互相不知道对方的内在实现（各自独立）<br>能做好这三点，代码就能完胜行业里的大多数人：）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
